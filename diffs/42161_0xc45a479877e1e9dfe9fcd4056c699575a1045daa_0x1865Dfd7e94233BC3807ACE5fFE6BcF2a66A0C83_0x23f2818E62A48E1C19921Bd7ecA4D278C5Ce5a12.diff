diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/AToken.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/AToken.sol
index f5e5fd0..c98ba96 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/AToken.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/AToken.sol
@@ -8,7 +8,6 @@ import {IERC20} from "../../dependencies/openzeppelin/contracts/IERC20.sol";
 import {GPv2SafeERC20} from "../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
 import {VersionedInitializable} from "../../misc/aave-upgradeability/VersionedInitializable.sol";
 import {Errors} from "../libraries/helpers/Errors.sol";
-import {WadRayMath} from "../libraries/math/WadRayMath.sol";
 import {IPool} from "../../interfaces/IPool.sol";
 import {IAToken} from "../../interfaces/IAToken.sol";
 import {IAaveIncentivesController} from "../../interfaces/IAaveIncentivesController.sol";
@@ -16,6 +15,7 @@ import {IInitializableAToken} from "../../interfaces/IInitializableAToken.sol";
 import {ScaledBalanceTokenBase} from "./base/ScaledBalanceTokenBase.sol";
 import {IncentivizedERC20} from "./base/IncentivizedERC20.sol";
 import {EIP712Base} from "./base/EIP712Base.sol";
+import {TokenMath} from "../libraries/helpers/TokenMath.sol";
 
 /**
  * @title Aave ERC20 AToken
@@ -23,7 +23,7 @@ import {EIP712Base} from "./base/EIP712Base.sol";
  * @notice Implementation of the interest bearing token for the Aave protocol
  */
 abstract contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IAToken {
-  using WadRayMath for uint256;
+  using TokenMath for uint256;
   using SafeCast for uint256;
   using GPv2SafeERC20 for IERC20;
 
@@ -60,61 +60,76 @@ abstract contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP7
   ) public virtual;
 
   /// @inheritdoc IAToken
-  function mint(address caller, address onBehalfOf, uint256 amount, uint256 index)
+  function mint(address caller, address onBehalfOf, uint256 scaledAmount, uint256 index)
     external
     virtual
     override
     onlyPool
     returns (bool)
   {
-    return _mintScaled(caller, onBehalfOf, amount, index);
+    return _mintScaled({
+      caller: caller,
+      onBehalfOf: onBehalfOf,
+      amountScaled: scaledAmount,
+      index: index,
+      getTokenBalance: TokenMath.getATokenBalance
+    });
   }
 
   /// @inheritdoc IAToken
-  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index)
+  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 scaledAmount, uint256 index)
     external
     virtual
     override
     onlyPool
+    returns (bool)
   {
-    _burnScaled(from, receiverOfUnderlying, amount, index);
+    bool zeroBalanceAfterBurn = _burnScaled({
+      user: from,
+      target: receiverOfUnderlying,
+      amountScaled: scaledAmount,
+      index: index,
+      getTokenBalance: TokenMath.getATokenBalance
+    });
+
     if (receiverOfUnderlying != address(this)) {
       IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);
     }
+    return zeroBalanceAfterBurn;
   }
 
   /// @inheritdoc IAToken
-  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {
-    if (amount == 0) {
+  function mintToTreasury(uint256 scaledAmount, uint256 index) external virtual override onlyPool {
+    if (scaledAmount == 0) {
       return;
     }
-    _mintScaled(address(POOL), TREASURY, amount, index);
+    _mintScaled({
+      caller: address(POOL),
+      onBehalfOf: TREASURY,
+      amountScaled: scaledAmount,
+      index: index,
+      getTokenBalance: TokenMath.getATokenBalance
+    });
   }
 
   /// @inheritdoc IAToken
-  function transferOnLiquidation(address from, address to, uint256 amount, uint256 index)
+  function transferOnLiquidation(address from, address to, uint256 amount, uint256 scaledAmount, uint256 index)
     external
     virtual
     override
     onlyPool
   {
-    _transfer(from, to, amount, index);
+    _transfer({sender: from, recipient: to, amount: amount, scaledAmount: scaledAmount.toUint120(), index: index});
   }
 
   /// @inheritdoc IERC20
   function balanceOf(address user) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
-    return super.balanceOf(user).rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+    return super.balanceOf(user).getATokenBalance(POOL.getReserveNormalizedIncome(_underlyingAsset));
   }
 
   /// @inheritdoc IERC20
   function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
-    uint256 currentSupplyScaled = super.totalSupply();
-
-    if (currentSupplyScaled == 0) {
-      return 0;
-    }
-
-    return currentSupplyScaled.rayMul(POOL.getReserveNormalizedIncome(_underlyingAsset));
+    return super.totalSupply().getATokenBalance(POOL.getReserveNormalizedIncome(_underlyingAsset));
   }
 
   /// @inheritdoc IAToken
@@ -153,6 +168,57 @@ abstract contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP7
     _approve(owner, spender, value);
   }
 
+  /// @inheritdoc IERC20
+  function transferFrom(address sender, address recipient, uint256 amount)
+    external
+    virtual
+    override(IERC20, IncentivizedERC20)
+    returns (bool)
+  {
+    uint256 index = POOL.getReserveNormalizedIncome(_underlyingAsset);
+    uint256 scaledBalanceOfSender = super.balanceOf(sender);
+    _spendAllowance(
+      sender,
+      _msgSender(),
+      amount,
+      // This comment explains the logic behind the allowance spent calculation.
+      //
+      // Problem:
+      // Simply decreasing the allowance by the input `amount` is not ideal for scaled-balance tokens.
+      // Due to rounding, the actual decrease in the sender's balance (`amount_out`) can be slightly
+      // larger than the input `amount`.
+      //
+      // Definitions:
+      // - `amount`: The unscaled amount to be transferred, passed as the `amount` argument.
+      // - `amount_out`: The actual unscaled amount deducted from the sender's balance.
+      // - `amount_in`: The actual unscaled amount added to the recipient's balance.
+      // - `allowance_spent`: The unscaled amount deducted from the spender's allowance. Equivalent to `amount_out`.
+      // - `amount_logged`: The amount logged in the `Transfer` event. Equivalent to `amount`.
+      //
+      // Solution:
+      // To fix this, `allowance_spent` must be exactly equal to `amount_out`.
+      // We calculate `amount_out` precisely by simulating the effect of the transfer on the sender's balance.
+      // By passing `amount_out` to `_spendAllowance`, we ensure `allowance_spent` is as close as possible to `amount_out`.
+      // `amount_logged` is equal to `amount`. `amount_in` is the actual balance increase for the recipient, which is >= `amount` due to rounding.
+      //
+      // Backward Compatibility & Guarantees:
+      // This implementation is backward-compatible and secure. The `_spendAllowance` function has a critical feature:
+      // 1. It REQUIRES the allowance to be >= `amount` (the user's requested transfer amount).
+      // 2. The amount consumed from the allowance is `amount_out`, but it is capped at the `currentAllowance`.
+      // This means if a user has an allowance of 100 wei and calls `transferFrom` with an `amount` of 100, the call will succeed
+      // even if the calculated `amount_out` is 101 wei. In that specific scenario, the allowance consumed will be 100 wei (since that is the `currentAllowance`),
+      // and the transaction will not revert. But if the allowance is 101 wei, then the allowance consumed will be 101 wei.
+      //
+      // uint256 amount_in = amount.getATokenTransferScaledAmount(index);
+      // uint256 amount_out = balanceBefore - balanceAfter = scaledBalanceOfSender.getATokenBalance(index) - (scaledBalanceOfSender - amount_in).getATokenBalance(index);
+      // Due to limitations of the solidity compiler, the calculation is inlined for gas efficiency.
+      scaledBalanceOfSender.getATokenBalance(index)
+        - (scaledBalanceOfSender - amount.getATokenTransferScaledAmount(index)).getATokenBalance(index)
+    );
+    _transfer(sender, recipient, amount.toUint120());
+    return true;
+  }
+
   /**
    * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()
    * @param from The source address
@@ -164,12 +230,20 @@ abstract contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP7
 
     uint256 index = POOL.getReserveNormalizedIncome(underlyingAsset);
 
-    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);
-    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);
+    uint256 scaledBalanceFromBefore = super.balanceOf(from);
+    uint256 scaledBalanceToBefore = super.balanceOf(to);
+    uint256 scaledAmount = uint256(amount).getATokenTransferScaledAmount(index);
 
-    _transfer(from, to, amount, index);
+    _transfer({sender: from, recipient: to, amount: amount, scaledAmount: scaledAmount.toUint120(), index: index});
 
-    POOL.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);
+    POOL.finalizeTransfer({
+      asset: underlyingAsset,
+      from: from,
+      to: to,
+      scaledAmount: scaledAmount,
+      scaledBalanceFromBefore: scaledBalanceFromBefore,
+      scaledBalanceToBefore: scaledBalanceToBefore
+    });
   }
 
   /**
@@ -178,20 +252,23 @@ abstract contract AToken is VersionedInitializable, ScaledBalanceTokenBase, EIP7
    * @param sender The source address
    * @param recipient The destination address
    * @param amount The amount getting transferred
+   * @param scaledAmount The scaled amount getting transferred
    * @param index The next liquidity index of the reserve
    */
-  function _transfer(address sender, address recipient, uint256 amount, uint256 index) internal virtual {
+  function _transfer(address sender, address recipient, uint256 amount, uint120 scaledAmount, uint256 index)
+    internal
+    virtual
+  {
     uint256 senderScaledBalance = super.balanceOf(sender);
-    uint256 senderBalanceIncrease =
-      senderScaledBalance.rayMul(index) - senderScaledBalance.rayMul(_userState[sender].additionalData);
+    uint256 senderBalanceIncrease = senderScaledBalance.getATokenBalance(index)
+      - senderScaledBalance.getATokenBalance(_userState[sender].additionalData);
 
     uint256 recipientScaledBalance = super.balanceOf(recipient);
-    uint256 recipientBalanceIncrease =
-      recipientScaledBalance.rayMul(index) - recipientScaledBalance.rayMul(_userState[recipient].additionalData);
+    uint256 recipientBalanceIncrease = recipientScaledBalance.getATokenBalance(index)
+      - recipientScaledBalance.getATokenBalance(_userState[recipient].additionalData);
 
     _userState[sender].additionalData = index.toUint128();
     _userState[recipient].additionalData = index.toUint128();
-    uint120 scaledAmount = amount.rayDiv(index).toUint120();
 
     super._transfer(sender, recipient, scaledAmount);
 
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/ATokenInstance.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/ATokenInstance.sol
index 4f540a8..1234c5e 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/ATokenInstance.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/ATokenInstance.sol
@@ -16,7 +16,7 @@ import {AToken} from "../protocol/tokenization/AToken.sol";
  * @notice Instance of the interest bearing token for the Aave protocol
  */
 contract ATokenInstance is AToken {
-  uint256 public constant ATOKEN_REVISION = 3;
+  uint256 public constant ATOKEN_REVISION = 4;
 
   constructor(IPool pool, address rewardsController, address treasury) AToken(pool, rewardsController, treasury) {}
 
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/DataTypes.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/DataTypes.sol
index 3debcd4..06e6aa3 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/DataTypes.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/DataTypes.sol
@@ -212,6 +212,8 @@ library DataTypes {
     InterestRateMode interestRateMode;
     address onBehalfOf;
     bool useATokens;
+    address oracle;
+    uint8 userEModeCategory;
   }
 
   struct ExecuteWithdrawParams {
@@ -235,9 +237,9 @@ library DataTypes {
     address asset;
     address from;
     address to;
-    uint256 amount;
-    uint256 balanceFromBefore;
-    uint256 balanceToBefore;
+    uint256 scaledAmount;
+    uint256 scaledBalanceFromBefore;
+    uint256 scaledBalanceToBefore;
     address oracle;
     uint8 fromEModeCategory;
   }
@@ -292,7 +294,7 @@ library DataTypes {
     UserConfigurationMap userConfig;
     address asset;
     address userAddress;
-    uint256 amount;
+    uint256 amountScaled;
     InterestRateMode interestRateMode;
     address oracle;
     uint8 userEModeCategory;
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/Errors.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/Errors.sol
index 6c493d8..c8ba3d0 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/Errors.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/Errors.sol
@@ -35,7 +35,6 @@ library Errors {
   error BorrowingNotEnabled(); // 'Borrowing is not enabled'
   error NotEnoughAvailableUserBalance(); // 'User cannot withdraw more than the available balance'
   error InvalidInterestRateModeSelected(); // 'Invalid interest rate mode selected'
-  error CollateralBalanceIsZero(); // 'The collateral balance is 0'
   error HealthFactorLowerThanLiquidationThreshold(); // 'Health factor is below the liquidation threshold'
   error CollateralCannotCoverNewBorrow(); // 'There is not enough collateral to cover a new borrow'
   error NoDebtOfSelectedType(); // 'For repayment of a specific type of debt, the user needs to have debt that type'
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/IAToken.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/IAToken.sol
index e42351f..436c809 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/IAToken.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/IAToken.sol
@@ -24,38 +24,47 @@ interface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {
    * @notice Mints `amount` aTokens to `user`
    * @param caller The address performing the mint
    * @param onBehalfOf The address of the user that will receive the minted aTokens
-   * @param amount The amount of tokens getting minted
+   * @param scaledAmount The scaled amount of tokens getting minted
    * @param index The next liquidity index of the reserve
    * @return `true` if the the previous balance of the user was 0
    */
-  function mint(address caller, address onBehalfOf, uint256 amount, uint256 index) external returns (bool);
+  function mint(address caller, address onBehalfOf, uint256 scaledAmount, uint256 index) external returns (bool);
 
   /**
-   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`
-   * @dev In some instances, the mint event could be emitted from a burn transaction
-   * if the amount to burn is less than the interest that the user accrued
+   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`.
+   * @dev Passing both the unscaled and scaled amounts enhances precision. The `scaledAmount` is used for precise balance updates,
+   * while the `amount` is used for the underlying asset transfer, preventing cumulative rounding errors.
+   * @dev In some instances, a mint event may be emitted from a burn transaction if the amount to burn is less than the interest that the user accrued.
    * @param from The address from which the aTokens will be burned
    * @param receiverOfUnderlying The address that will receive the underlying
-   * @param amount The amount being burned
+   * @param amount The amount of underlying to be burned (non scaled)
+   * @param scaledAmount The scaled amount of aTokens to be burned (scaled)
    * @param index The next liquidity index of the reserve
+   * @return `true` if the the new balance of the user is 0
    */
-  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external;
+  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 scaledAmount, uint256 index)
+    external
+    returns (bool);
 
   /**
    * @notice Mints aTokens to the reserve treasury
-   * @param amount The amount of tokens getting minted
+   * @param scaledAmount The scaled amount of tokens getting minted
    * @param index The next liquidity index of the reserve
    */
-  function mintToTreasury(uint256 amount, uint256 index) external;
+  function mintToTreasury(uint256 scaledAmount, uint256 index) external;
 
   /**
-   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken
+   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidator reclaims the aToken.
+   * @dev Passing both the unscaled and scaled amounts enhances precision. The `scaledAmount` is used for precise balance updates,
+   * while the `amount` is used for logging and consistency, preventing cumulative rounding errors.
    * @param from The address getting liquidated, current owner of the aTokens
    * @param to The recipient
-   * @param value The amount of tokens getting transferred
+   * @param amount The amount of tokens getting transferred (non-scaled)
+   * @param scaledAmount The scaled amount of tokens getting transferred (scaled)
    * @param index The next liquidity index of the reserve
    */
-  function transferOnLiquidation(address from, address to, uint256 value, uint256 index) external;
+  function transferOnLiquidation(address from, address to, uint256 amount, uint256 scaledAmount, uint256 index)
+    external;
 
   /**
    * @notice Transfers the underlying asset to `target`.
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/IPool.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/IPool.sol
index 38aad59..2320fbc 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/IPool.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/IPool.sol
@@ -504,17 +504,17 @@ interface IPool {
    * @param asset The address of the underlying asset of the aToken
    * @param from The user from which the aTokens are transferred
    * @param to The user receiving the aTokens
-   * @param amount The amount being transferred/withdrawn
-   * @param balanceFromBefore The aToken balance of the `from` user before the transfer
-   * @param balanceToBefore The aToken balance of the `to` user before the transfer
+   * @param scaledAmount The scaled amount being transferred/withdrawn
+   * @param scaledBalanceFromBefore The aToken scaled balance of the `from` user before the transfer
+   * @param scaledBalanceToBefore The aToken scaled balance of the `to` user before the transfer
    */
   function finalizeTransfer(
     address asset,
     address from,
     address to,
-    uint256 amount,
-    uint256 balanceFromBefore,
-    uint256 balanceToBefore
+    uint256 scaledAmount,
+    uint256 scaledBalanceFromBefore,
+    uint256 scaledBalanceToBefore
   ) external;
 
   /**
@@ -709,8 +709,9 @@ interface IPool {
    * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.
    * @param asset The address of the underlying asset to cover the deficit.
    * @param amount The amount to be covered, in aToken
+   * @return The amount of tokens burned
    */
-  function eliminateReserveDeficit(address asset, uint256 amount) external;
+  function eliminateReserveDeficit(address asset, uint256 amount) external returns (uint256);
 
   /**
    * @notice Approves or disapproves a position manager. This position manager will be able
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/IncentivizedERC20.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/IncentivizedERC20.sol
index 4e18e31..478cefc 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/IncentivizedERC20.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/IncentivizedERC20.sol
@@ -22,6 +22,14 @@ abstract contract IncentivizedERC20 is Context, IERC20Detailed {
   using WadRayMath for uint256;
   using SafeCast for uint256;
 
+  /**
+   * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
+   * @param spender Address that may be allowed to operate on tokens without being their owner.
+   * @param allowance Amount of tokens a `spender` is allowed to operate with.
+   * @param needed Minimum amount required to perform a transfer.
+   */
+  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
+
   /**
    * @dev Only pool admin can call functions marked by this modifier.
    */
@@ -168,6 +176,26 @@ abstract contract IncentivizedERC20 is Context, IERC20Detailed {
     return true;
   }
 
+  /**
+   * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
+   *
+   * Revert if not enough allowance is available.
+   *
+   * @param owner The owner of the tokens
+   * @param spender The user allowed to spend on behalf of owner
+   * @param amount The minimum amount being consumed from the allowance
+   * @param correctedAmount The maximum amount being consumed from the allowance
+   */
+  function _spendAllowance(address owner, address spender, uint256 amount, uint256 correctedAmount) internal virtual {
+    uint256 currentAllowance = _allowances[owner][spender];
+    if (currentAllowance < amount) {
+      revert ERC20InsufficientAllowance(spender, currentAllowance, amount);
+    }
+
+    uint256 consumption = currentAllowance >= correctedAmount ? correctedAmount : currentAllowance;
+    _approve(owner, spender, currentAllowance - consumption);
+  }
+
   /**
    * @notice Transfers tokens between two users and apply incentives if defined.
    * @param sender The source address
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/ScaledBalanceTokenBase.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/ScaledBalanceTokenBase.sol
index 4d22caf..e5f2d8f 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/ScaledBalanceTokenBase.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/ScaledBalanceTokenBase.sol
@@ -55,22 +55,30 @@ abstract contract ScaledBalanceTokenBase is MintableIncentivizedERC20, IScaledBa
    * @notice Implements the basic logic to mint a scaled balance token.
    * @param caller The address performing the mint
    * @param onBehalfOf The address of the user that will receive the scaled tokens
-   * @param amount The amount of tokens getting minted
+   * @param amountScaled The amountScaled of tokens getting minted
    * @param index The next liquidity index of the reserve
+   * @param getTokenBalance The function to get the balance of the token
    * @return `true` if the the previous balance of the user was 0
    */
-  function _mintScaled(address caller, address onBehalfOf, uint256 amount, uint256 index) internal returns (bool) {
-    uint256 amountScaled = amount.rayDiv(index);
+  function _mintScaled(
+    address caller,
+    address onBehalfOf,
+    uint256 amountScaled,
+    uint256 index,
+    function(uint256, uint256) internal pure returns (uint256) getTokenBalance
+  ) internal returns (bool) {
     require(amountScaled != 0, Errors.InvalidMintAmount());
 
     uint256 scaledBalance = super.balanceOf(onBehalfOf);
-    uint256 balanceIncrease = scaledBalance.rayMul(index) - scaledBalance.rayMul(_userState[onBehalfOf].additionalData);
+    uint256 nextBalance = getTokenBalance(amountScaled + scaledBalance, index);
+    uint256 previousBalance = getTokenBalance(scaledBalance, _userState[onBehalfOf].additionalData);
+    uint256 balanceIncrease = getTokenBalance(scaledBalance, index) - previousBalance;
 
     _userState[onBehalfOf].additionalData = index.toUint128();
 
     _mint(onBehalfOf, amountScaled.toUint120());
 
-    uint256 amountToMint = amount + balanceIncrease;
+    uint256 amountToMint = nextBalance - previousBalance;
     emit Transfer(address(0), onBehalfOf, amountToMint);
     emit Mint(caller, onBehalfOf, amountToMint, balanceIncrease, index);
 
@@ -83,30 +91,39 @@ abstract contract ScaledBalanceTokenBase is MintableIncentivizedERC20, IScaledBa
    * if the amount to burn is less than the interest that the user accrued
    * @param user The user which debt is burnt
    * @param target The address that will receive the underlying, if any
-   * @param amount The amount getting burned
+   * @param amountScaled The scaled amount getting burned
    * @param index The variable debt index of the reserve
+   * @param getTokenBalance The function to get the balance of the token
    * @return `true` if the the new balance of the user is 0
    */
-  function _burnScaled(address user, address target, uint256 amount, uint256 index) internal returns (bool) {
-    uint256 amountScaled = amount.rayDiv(index);
+  function _burnScaled(
+    address user,
+    address target,
+    uint256 amountScaled,
+    uint256 index,
+    function(uint256, uint256) internal pure returns (uint256) getTokenBalance
+  ) internal returns (bool) {
     require(amountScaled != 0, Errors.InvalidBurnAmount());
 
     uint256 scaledBalance = super.balanceOf(user);
-    uint256 balanceIncrease = scaledBalance.rayMul(index) - scaledBalance.rayMul(_userState[user].additionalData);
+    uint256 nextBalance = getTokenBalance(scaledBalance - amountScaled, index);
+    uint256 previousBalance = getTokenBalance(scaledBalance, _userState[user].additionalData);
+    uint256 balanceIncrease = getTokenBalance(scaledBalance, index) - previousBalance;
 
     _userState[user].additionalData = index.toUint128();
 
     _burn(user, amountScaled.toUint120());
 
-    if (balanceIncrease > amount) {
-      uint256 amountToMint = balanceIncrease - amount;
+    if (nextBalance > previousBalance) {
+      uint256 amountToMint = nextBalance - previousBalance;
       emit Transfer(address(0), user, amountToMint);
       emit Mint(user, user, amountToMint, balanceIncrease, index);
     } else {
-      uint256 amountToBurn = amount - balanceIncrease;
+      uint256 amountToBurn = previousBalance - nextBalance;
       emit Transfer(user, address(0), amountToBurn);
       emit Burn(user, target, amountToBurn, balanceIncrease, index);
     }
+
     return scaledBalance - amountScaled == 0;
   }
 }
diff --git a/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/TokenMath.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/TokenMath.sol
new file mode 100644
index 0000000..f7d63fc
--- /dev/null
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/TokenMath.sol
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {WadRayMath} from "../../libraries/math/WadRayMath.sol";
+
+/**
+ * @title TokenMath
+ * @author BGD Labs
+ * @notice Provides utility functions for calculating scaled amounts and balances for aTokens and vTokens,
+ *         applying specific rounding rules (floor/ceil) as per Aave v3.5's rounding improvements.
+ *         The rounding behavior of the operations is in line with the ERC-4626 token standard.
+ *         In practice, this means rounding in favor of the protocol.
+ */
+library TokenMath {
+  using WadRayMath for uint256;
+
+  /**
+   * @notice Calculates the scaled amount of aTokens to mint when supplying underlying assets.
+   *         The amount is rounded down to ensure the minted aTokens are less than or equal to the supplied amount.
+   * @param amount The amount of underlying asset supplied.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The scaled amount of aTokens to mint.
+   */
+  function getATokenMintScaledAmount(uint256 amount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return amount.rayDivFloor(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of aTokens to burn when withdrawing underlying assets.
+   *         The scaled amount is rounded up to ensure the user's aToken balance is sufficiently reduced.
+   * @param amount The amount of underlying asset to withdraw.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The scaled amount of aTokens to burn.
+   */
+  function getATokenBurnScaledAmount(uint256 amount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return amount.rayDivCeil(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of aTokens to transfer.
+   *         The scaled amount is rounded up to ensure the recipient receives at least the requested amount.
+   * @param amount The amount of aTokens to transfer.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The scaled amount of aTokens for transfer.
+   */
+  function getATokenTransferScaledAmount(uint256 amount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return amount.rayDivCeil(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the actual aToken balance from a scaled balance and the current liquidityIndex.
+   *         The balance is rounded down to prevent overaccounting.
+   * @param scaledAmount The scaled aToken balance.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The actual aToken balance.
+   */
+  function getATokenBalance(uint256 scaledAmount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return scaledAmount.rayMulFloor(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of vTokens to mint when borrowing.
+   *         The amount is rounded up to ensure the protocol never underaccounts the user's debt.
+   * @param amount The amount of underlying asset borrowed.
+   * @param variableBorrowIndex The current vToken variableBorrowIndex.
+   * @return The scaled amount of vTokens to mint.
+   */
+  function getVTokenMintScaledAmount(uint256 amount, uint256 variableBorrowIndex) internal pure returns (uint256) {
+    return amount.rayDivCeil(variableBorrowIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of vTokens to burn.
+   *         The scaled amount is rounded down to prevent over-burning of vTokens.
+   * @param amount The amount of underlying asset corresponding to the vTokens to burn.
+   * @param variableBorrowIndex The current vToken variableBorrowIndex.
+   * @return The scaled amount of vTokens to burn.
+   */
+  function getVTokenBurnScaledAmount(uint256 amount, uint256 variableBorrowIndex) internal pure returns (uint256) {
+    return amount.rayDivFloor(variableBorrowIndex);
+  }
+
+  /**
+   * @notice Calculates the actual vToken balance (debt) from a scaled balance and the current variableBorrowIndex.
+   *         The balance is rounded up to prevent underaccounting the user's debt.
+   * @param scaledAmount The scaled vToken balance.
+   * @param variableBorrowIndex The current vToken variableBorrowIndex.
+   * @return The actual vToken balance (debt).
+   */
+  function getVTokenBalance(uint256 scaledAmount, uint256 variableBorrowIndex) internal pure returns (uint256) {
+    return scaledAmount.rayMulCeil(variableBorrowIndex);
+  }
+}
diff --git a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/WadRayMath.sol b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/WadRayMath.sol
index 433dd94..88e3b00 100644
--- a/tmp/42161_0x1865Dfd7e94233BC3807ACE5fFE6BcF2a66A0C83_flat/WadRayMath.sol
+++ b/tmp/42161_0x23f2818E62A48E1C19921Bd7ecA4D278C5Ce5a12_flat/WadRayMath.sol
@@ -6,10 +6,16 @@ pragma solidity ^0.8.0;
  * @author Aave
  * @notice Provides functions to perform calculations with Wad and Ray units
  * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers
- * with 27 digits of precision)
- * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.
+ * with 27 digits of precision).
+ * @dev Default operations round half up (if a value is >= .5, it will be rounded up, otherwise rounded down).
+ * @dev For specific rounding behaviors, functions with `Floor` and `Ceil` suffixes or a `Rounding` parameter are available.
  */
 library WadRayMath {
+  enum Rounding {
+    Floor,
+    Ceil
+  }
+
   // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly
   uint256 internal constant WAD = 1e18;
   uint256 internal constant HALF_WAD = 0.5e18;
@@ -51,22 +57,38 @@ library WadRayMath {
     }
   }
 
-  /**
-   * @notice Multiplies two ray, rounding half up to the nearest ray
-   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-   * @param a Ray
-   * @param b Ray
-   * @return c = a raymul b
-   */
   function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
-    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
     assembly {
+      // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
       if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) { revert(0, 0) }
-
       c := div(add(mul(a, b), HALF_RAY), RAY)
     }
   }
 
+  function rayMul(uint256 a, uint256 b, Rounding rounding) internal pure returns (uint256 c) {
+    if (rounding == Rounding.Floor) return rayMulFloor(a, b);
+    return rayMulCeil(a, b);
+  }
+
+  function rayMulFloor(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * b does not exceed uint256 max
+      if iszero(or(iszero(b), iszero(gt(a, div(not(0), b))))) { revert(0, 0) }
+
+      c := div(mul(a, b), RAY)
+    }
+  }
+
+  function rayMulCeil(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * b does not exceed uint256 max
+      if iszero(or(iszero(b), iszero(gt(a, div(not(0), b))))) { revert(0, 0) }
+
+      let product := mul(a, b)
+      c := add(div(product, RAY), iszero(iszero(mod(product, RAY))))
+    }
+  }
+
   /**
    * @notice Divides two ray, rounding half up to the nearest ray
    * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
@@ -75,14 +97,35 @@ library WadRayMath {
    * @return c = a raydiv b
    */
   function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
-    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY
     assembly {
+      // to avoid overflow, a <= (type(uint256).max - b / 2) / RAY
       if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) { revert(0, 0) }
-
       c := div(add(mul(a, RAY), div(b, 2)), b)
     }
   }
 
+  function rayDiv(uint256 a, uint256 b, Rounding rounding) internal pure returns (uint256 c) {
+    if (rounding == Rounding.Floor) return rayDivFloor(a, b);
+    return rayDivCeil(a, b);
+  }
+
+  function rayDivCeil(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * RAY does not exceed uint256 max
+      if or(iszero(b), iszero(iszero(gt(a, div(not(0), RAY))))) { revert(0, 0) }
+      let scaled := mul(a, RAY)
+      c := add(div(scaled, b), iszero(iszero(mod(scaled, b))))
+    }
+  }
+
+  function rayDivFloor(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * RAY does not exceed uint256 max
+      if or(iszero(b), iszero(iszero(gt(a, div(not(0), RAY))))) { revert(0, 0) }
+      c := div(mul(a, RAY), b)
+    }
+  }
+
   /**
    * @dev Casts ray down to wad
    * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
