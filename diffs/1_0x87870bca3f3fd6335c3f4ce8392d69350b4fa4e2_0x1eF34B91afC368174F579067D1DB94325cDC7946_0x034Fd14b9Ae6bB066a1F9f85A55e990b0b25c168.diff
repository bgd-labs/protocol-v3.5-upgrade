diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/DataTypes.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/DataTypes.sol
index 3debcd4..06e6aa3 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/DataTypes.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/DataTypes.sol
@@ -212,6 +212,8 @@ library DataTypes {
     InterestRateMode interestRateMode;
     address onBehalfOf;
     bool useATokens;
+    address oracle;
+    uint8 userEModeCategory;
   }
 
   struct ExecuteWithdrawParams {
@@ -235,9 +237,9 @@ library DataTypes {
     address asset;
     address from;
     address to;
-    uint256 amount;
-    uint256 balanceFromBefore;
-    uint256 balanceToBefore;
+    uint256 scaledAmount;
+    uint256 scaledBalanceFromBefore;
+    uint256 scaledBalanceToBefore;
     address oracle;
     uint8 fromEModeCategory;
   }
@@ -292,7 +294,7 @@ library DataTypes {
     UserConfigurationMap userConfig;
     address asset;
     address userAddress;
-    uint256 amount;
+    uint256 amountScaled;
     InterestRateMode interestRateMode;
     address oracle;
     uint8 userEModeCategory;
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/EModeLogic.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/EModeLogic.sol
index 55a5dd1..77e0560 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/EModeLogic.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/EModeLogic.sol
@@ -1,15 +1,9 @@
 // SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.10;
 
-import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
-import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
 import {IPool} from "../../../interfaces/IPool.sol";
-import {UserConfiguration} from "../configuration/UserConfiguration.sol";
-import {WadRayMath} from "../math/WadRayMath.sol";
-import {PercentageMath} from "../math/PercentageMath.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {ValidationLogic} from "./ValidationLogic.sol";
-import {ReserveLogic} from "./ReserveLogic.sol";
 
 /**
  * @title EModeLogic library
@@ -17,13 +11,6 @@ import {ReserveLogic} from "./ReserveLogic.sol";
  * @notice Implements the base logic for all the actions related to the eMode
  */
 library EModeLogic {
-  using ReserveLogic for DataTypes.ReserveCache;
-  using ReserveLogic for DataTypes.ReserveData;
-  using GPv2SafeERC20 for IERC20;
-  using UserConfiguration for DataTypes.UserConfigurationMap;
-  using WadRayMath for uint256;
-  using PercentageMath for uint256;
-
   /**
    * @notice Updates the user efficiency mode category
    * @dev Will revert if user is borrowing non-compatible asset or change will drop HF < HEALTH_FACTOR_LIQUIDATION_THRESHOLD
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/Errors.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/Errors.sol
index 6c493d8..c8ba3d0 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/Errors.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/Errors.sol
@@ -35,7 +35,6 @@ library Errors {
   error BorrowingNotEnabled(); // 'Borrowing is not enabled'
   error NotEnoughAvailableUserBalance(); // 'User cannot withdraw more than the available balance'
   error InvalidInterestRateModeSelected(); // 'Invalid interest rate mode selected'
-  error CollateralBalanceIsZero(); // 'The collateral balance is 0'
   error HealthFactorLowerThanLiquidationThreshold(); // 'Health factor is below the liquidation threshold'
   error CollateralCannotCoverNewBorrow(); // 'There is not enough collateral to cover a new borrow'
   error NoDebtOfSelectedType(); // 'For repayment of a specific type of debt, the user needs to have debt that type'
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/GenericLogic.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/GenericLogic.sol
index 809ce96..c554325 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/GenericLogic.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/GenericLogic.sol
@@ -9,6 +9,8 @@ import {UserConfiguration} from "../configuration/UserConfiguration.sol";
 import {EModeConfiguration} from "../configuration/EModeConfiguration.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
 import {WadRayMath} from "../math/WadRayMath.sol";
+import {TokenMath} from "../helpers/TokenMath.sol";
+import {MathUtils} from "../math/MathUtils.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {ReserveLogic} from "./ReserveLogic.sol";
 import {EModeLogic} from "./EModeLogic.sol";
@@ -20,6 +22,7 @@ import {EModeLogic} from "./EModeLogic.sol";
  */
 library GenericLogic {
   using ReserveLogic for DataTypes.ReserveData;
+  using TokenMath for uint256;
   using WadRayMath for uint256;
   using PercentageMath for uint256;
   using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
@@ -130,15 +133,22 @@ library GenericLogic {
       }
     }
 
+    // @note At this point, `avgLiquidationThreshold` represents
+    // `SUM(collateral_base_value_i * liquidation_threshold_i)` for all collateral assets.
+    // It has 8 decimals (base currency) + 2 decimals (percentage) = 10 decimals.
+    // healthFactor has 18 decimals
+    // healthFactor = (avgLiquidationThreshold * WAD / totalDebtInBaseCurrency) / 100_00
+    // 18 decimals = (10 decimals * 18 decimals / 8 decimals) / 2 decimals = 18 decimals
+    vars.healthFactor = (vars.totalDebtInBaseCurrency == 0)
+      ? type(uint256).max
+      : vars.avgLiquidationThreshold.wadDiv(vars.totalDebtInBaseCurrency) / 100_00;
+
     unchecked {
       vars.avgLtv = vars.totalCollateralInBaseCurrency != 0 ? vars.avgLtv / vars.totalCollateralInBaseCurrency : 0;
       vars.avgLiquidationThreshold =
         vars.totalCollateralInBaseCurrency != 0 ? vars.avgLiquidationThreshold / vars.totalCollateralInBaseCurrency : 0;
     }
 
-    vars.healthFactor = (vars.totalDebtInBaseCurrency == 0)
-      ? type(uint256).max
-      : (vars.totalCollateralInBaseCurrency.percentMul(vars.avgLiquidationThreshold)).wadDiv(vars.totalDebtInBaseCurrency);
     return (
       vars.totalCollateralInBaseCurrency,
       vars.totalDebtInBaseCurrency,
@@ -162,7 +172,7 @@ library GenericLogic {
     uint256 totalDebtInBaseCurrency,
     uint256 ltv
   ) internal pure returns (uint256) {
-    uint256 availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency.percentMul(ltv);
+    uint256 availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency.percentMulFloor(ltv);
 
     if (availableBorrowsInBaseCurrency <= totalDebtInBaseCurrency) {
       return 0;
@@ -189,16 +199,11 @@ library GenericLogic {
     uint256 assetPrice,
     uint256 assetUnit
   ) private view returns (uint256) {
-    // fetching variable debt
-    uint256 userTotalDebt = IScaledBalanceToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);
-    if (userTotalDebt == 0) {
-      return 0;
-    }
+    uint256 userTotalDebt = IScaledBalanceToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user).getVTokenBalance(
+      reserve.getNormalizedDebt()
+    );
 
-    userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt()) * assetPrice;
-    unchecked {
-      return userTotalDebt / assetUnit;
-    }
+    return MathUtils.mulDivCeil(userTotalDebt, assetPrice, assetUnit);
   }
 
   /**
@@ -217,9 +222,9 @@ library GenericLogic {
     uint256 assetPrice,
     uint256 assetUnit
   ) private view returns (uint256) {
-    uint256 normalizedIncome = reserve.getNormalizedIncome();
-    uint256 balance =
-      (IScaledBalanceToken(reserve.aTokenAddress).scaledBalanceOf(user).rayMul(normalizedIncome)) * assetPrice;
+    uint256 balance = (
+      IScaledBalanceToken(reserve.aTokenAddress).scaledBalanceOf(user).getATokenBalance(reserve.getNormalizedIncome())
+    ) * assetPrice;
 
     unchecked {
       return balance / assetUnit;
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IAToken.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IAToken.sol
index e42351f..436c809 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IAToken.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IAToken.sol
@@ -24,38 +24,47 @@ interface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {
    * @notice Mints `amount` aTokens to `user`
    * @param caller The address performing the mint
    * @param onBehalfOf The address of the user that will receive the minted aTokens
-   * @param amount The amount of tokens getting minted
+   * @param scaledAmount The scaled amount of tokens getting minted
    * @param index The next liquidity index of the reserve
    * @return `true` if the the previous balance of the user was 0
    */
-  function mint(address caller, address onBehalfOf, uint256 amount, uint256 index) external returns (bool);
+  function mint(address caller, address onBehalfOf, uint256 scaledAmount, uint256 index) external returns (bool);
 
   /**
-   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`
-   * @dev In some instances, the mint event could be emitted from a burn transaction
-   * if the amount to burn is less than the interest that the user accrued
+   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`.
+   * @dev Passing both the unscaled and scaled amounts enhances precision. The `scaledAmount` is used for precise balance updates,
+   * while the `amount` is used for the underlying asset transfer, preventing cumulative rounding errors.
+   * @dev In some instances, a mint event may be emitted from a burn transaction if the amount to burn is less than the interest that the user accrued.
    * @param from The address from which the aTokens will be burned
    * @param receiverOfUnderlying The address that will receive the underlying
-   * @param amount The amount being burned
+   * @param amount The amount of underlying to be burned (non scaled)
+   * @param scaledAmount The scaled amount of aTokens to be burned (scaled)
    * @param index The next liquidity index of the reserve
+   * @return `true` if the the new balance of the user is 0
    */
-  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external;
+  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 scaledAmount, uint256 index)
+    external
+    returns (bool);
 
   /**
    * @notice Mints aTokens to the reserve treasury
-   * @param amount The amount of tokens getting minted
+   * @param scaledAmount The scaled amount of tokens getting minted
    * @param index The next liquidity index of the reserve
    */
-  function mintToTreasury(uint256 amount, uint256 index) external;
+  function mintToTreasury(uint256 scaledAmount, uint256 index) external;
 
   /**
-   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken
+   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidator reclaims the aToken.
+   * @dev Passing both the unscaled and scaled amounts enhances precision. The `scaledAmount` is used for precise balance updates,
+   * while the `amount` is used for logging and consistency, preventing cumulative rounding errors.
    * @param from The address getting liquidated, current owner of the aTokens
    * @param to The recipient
-   * @param value The amount of tokens getting transferred
+   * @param amount The amount of tokens getting transferred (non-scaled)
+   * @param scaledAmount The scaled amount of tokens getting transferred (scaled)
    * @param index The next liquidity index of the reserve
    */
-  function transferOnLiquidation(address from, address to, uint256 value, uint256 index) external;
+  function transferOnLiquidation(address from, address to, uint256 amount, uint256 scaledAmount, uint256 index)
+    external;
 
   /**
    * @notice Transfers the underlying asset to `target`.
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IPool.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IPool.sol
index 38aad59..2320fbc 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IPool.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IPool.sol
@@ -504,17 +504,17 @@ interface IPool {
    * @param asset The address of the underlying asset of the aToken
    * @param from The user from which the aTokens are transferred
    * @param to The user receiving the aTokens
-   * @param amount The amount being transferred/withdrawn
-   * @param balanceFromBefore The aToken balance of the `from` user before the transfer
-   * @param balanceToBefore The aToken balance of the `to` user before the transfer
+   * @param scaledAmount The scaled amount being transferred/withdrawn
+   * @param scaledBalanceFromBefore The aToken scaled balance of the `from` user before the transfer
+   * @param scaledBalanceToBefore The aToken scaled balance of the `to` user before the transfer
    */
   function finalizeTransfer(
     address asset,
     address from,
     address to,
-    uint256 amount,
-    uint256 balanceFromBefore,
-    uint256 balanceToBefore
+    uint256 scaledAmount,
+    uint256 scaledBalanceFromBefore,
+    uint256 scaledBalanceToBefore
   ) external;
 
   /**
@@ -709,8 +709,9 @@ interface IPool {
    * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.
    * @param asset The address of the underlying asset to cover the deficit.
    * @param amount The amount to be covered, in aToken
+   * @return The amount of tokens burned
    */
-  function eliminateReserveDeficit(address asset, uint256 amount) external;
+  function eliminateReserveDeficit(address asset, uint256 amount) external returns (uint256);
 
   /**
    * @notice Approves or disapproves a position manager. This position manager will be able
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IVariableDebtToken.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IVariableDebtToken.sol
index d567d1f..66a8c5d 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IVariableDebtToken.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IVariableDebtToken.sol
@@ -11,27 +11,32 @@ import {IInitializableDebtToken} from "./IInitializableDebtToken.sol";
  */
 interface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {
   /**
-   * @notice Mints debt token to the `onBehalfOf` address
+   * @notice Mints debt token to the `onBehalfOf` address.
+   * @dev Passing both the unscaled and scaled amounts enhances precision. The `scaledAmount` is used for precise balance updates,
+   * while the `amount` is used for allowance checks, preventing cumulative rounding errors.
    * @param user The address receiving the borrowed underlying, being the delegatee in case
    * of credit delegate, or same as `onBehalfOf` otherwise
    * @param onBehalfOf The address receiving the debt tokens
-   * @param amount The amount of debt being minted
+   * @param amount The unscaled amount of debt to be accounted for allowance
+   * @param scaledAmount The scaled amount of debt tokens to mint
    * @param index The variable debt index of the reserve
    * @return The scaled total debt of the reserve
    */
-  function mint(address user, address onBehalfOf, uint256 amount, uint256 index) external returns (uint256);
+  function mint(address user, address onBehalfOf, uint256 amount, uint256 scaledAmount, uint256 index)
+    external
+    returns (uint256);
 
   /**
-   * @notice Burns user variable debt
-   * @dev In some instances, a burn transaction will emit a mint event
-   * if the amount to burn is less than the interest that the user accrued
+   * @notice Burns user variable debt.
+   * @dev Passing the scaled amount allows for more precise calculations and avoids cumulative errors from repeated conversions.
+   * @dev In some instances, a burn transaction will emit a mint event if the amount to burn is less than the interest that the user accrued.
    * @param from The address from which the debt will be burned
-   * @param amount The amount getting burned
+   * @param scaledAmount The scaled amount of debt getting burned
    * @param index The variable debt index of the reserve
    * @return True if the new balance is zero
    * @return The scaled total debt of the reserve
    */
-  function burn(address from, uint256 amount, uint256 index) external returns (bool, uint256);
+  function burn(address from, uint256 scaledAmount, uint256 index) external returns (bool, uint256);
 
   /**
    * @notice Returns the address of the underlying asset of this debtToken (E.g. WETH for variableDebtWETH)
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IncentivizedERC20.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IncentivizedERC20.sol
index 4e18e31..478cefc 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/IncentivizedERC20.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/IncentivizedERC20.sol
@@ -22,6 +22,14 @@ abstract contract IncentivizedERC20 is Context, IERC20Detailed {
   using WadRayMath for uint256;
   using SafeCast for uint256;
 
+  /**
+   * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
+   * @param spender Address that may be allowed to operate on tokens without being their owner.
+   * @param allowance Amount of tokens a `spender` is allowed to operate with.
+   * @param needed Minimum amount required to perform a transfer.
+   */
+  error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
+
   /**
    * @dev Only pool admin can call functions marked by this modifier.
    */
@@ -168,6 +176,26 @@ abstract contract IncentivizedERC20 is Context, IERC20Detailed {
     return true;
   }
 
+  /**
+   * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
+   *
+   * Revert if not enough allowance is available.
+   *
+   * @param owner The owner of the tokens
+   * @param spender The user allowed to spend on behalf of owner
+   * @param amount The minimum amount being consumed from the allowance
+   * @param correctedAmount The maximum amount being consumed from the allowance
+   */
+  function _spendAllowance(address owner, address spender, uint256 amount, uint256 correctedAmount) internal virtual {
+    uint256 currentAllowance = _allowances[owner][spender];
+    if (currentAllowance < amount) {
+      revert ERC20InsufficientAllowance(spender, currentAllowance, amount);
+    }
+
+    uint256 consumption = currentAllowance >= correctedAmount ? correctedAmount : currentAllowance;
+    _approve(owner, spender, currentAllowance - consumption);
+  }
+
   /**
    * @notice Transfers tokens between two users and apply incentives if defined.
    * @param sender The source address
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/MathUtils.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/MathUtils.sol
index 701ce53..20613ea 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/MathUtils.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/MathUtils.sol
@@ -90,4 +90,17 @@ library MathUtils {
   function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {
     return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);
   }
+
+  function mulDivCeil(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 d) {
+    assembly {
+      // Revert if c == 0 to avoid division by zero
+      if iszero(c) { revert(0, 0) }
+
+      // Overflow check: Ensure a * b does not exceed uint256 max
+      if iszero(or(iszero(b), iszero(gt(a, div(not(0), b))))) { revert(0, 0) }
+
+      let product := mul(a, b)
+      d := add(div(product, c), iszero(iszero(mod(product, c))))
+    }
+  }
 }
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/PercentageMath.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/PercentageMath.sol
index 914d38a..a99a2b3 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/PercentageMath.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/PercentageMath.sol
@@ -33,6 +33,25 @@ library PercentageMath {
     }
   }
 
+  function percentMulCeil(uint256 value, uint256 percentage) internal pure returns (uint256 result) {
+    // to avoid overflow, value <= type(uint256).max / percentage
+    assembly {
+      if iszero(or(iszero(percentage), iszero(gt(value, div(not(0), percentage))))) { revert(0, 0) }
+
+      let product := mul(value, percentage)
+      result := add(div(product, PERCENTAGE_FACTOR), iszero(iszero(mod(product, PERCENTAGE_FACTOR))))
+    }
+  }
+
+  function percentMulFloor(uint256 value, uint256 percentage) internal pure returns (uint256 result) {
+    // to avoid overflow, value <= type(uint256).max / percentage
+    assembly {
+      if iszero(or(iszero(percentage), iszero(gt(value, div(not(0), percentage))))) { revert(0, 0) }
+
+      result := div(mul(value, percentage), PERCENTAGE_FACTOR)
+    }
+  }
+
   /**
    * @notice Executes a percentage division
    * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
@@ -50,4 +69,13 @@ library PercentageMath {
       result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)
     }
   }
+
+  function percentDivCeil(uint256 value, uint256 percentage) internal pure returns (uint256 result) {
+    // to avoid overflow, value <= type(uint256).max / PERCENTAGE_FACTOR
+    assembly {
+      if or(iszero(percentage), iszero(iszero(gt(value, div(not(0), PERCENTAGE_FACTOR))))) { revert(0, 0) }
+      let val := mul(value, PERCENTAGE_FACTOR)
+      result := add(div(val, percentage), iszero(iszero(mod(val, percentage))))
+    }
+  }
 }
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/ReserveLogic.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/ReserveLogic.sol
index 0714e2f..057859a 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/ReserveLogic.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/ReserveLogic.sol
@@ -11,6 +11,7 @@ import {MathUtils} from "../math/MathUtils.sol";
 import {WadRayMath} from "../math/WadRayMath.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
 import {Errors} from "../helpers/Errors.sol";
+import {TokenMath} from "../helpers/TokenMath.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {SafeCast} from "openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
 
@@ -21,6 +22,7 @@ import {SafeCast} from "openzeppelin-contracts/contracts/utils/math/SafeCast.sol
  */
 library ReserveLogic {
   using WadRayMath for uint256;
+  using TokenMath for uint256;
   using PercentageMath for uint256;
   using SafeCast for uint256;
   using GPv2SafeERC20 for IERC20;
@@ -120,7 +122,8 @@ library ReserveLogic {
     uint256 liquidityTaken,
     address interestRateStrategyAddress
   ) internal {
-    uint256 totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex);
+    uint256 totalVariableDebt =
+      reserveCache.nextScaledVariableDebt.getVTokenBalance(reserveCache.nextVariableBorrowIndex);
 
     (uint256 nextLiquidityRate, uint256 nextVariableRate) = IReserveInterestRateStrategy(interestRateStrategyAddress)
       .calculateInterestRates(
@@ -169,19 +172,16 @@ library ReserveLogic {
       return;
     }
 
-    //calculate the total variable debt at moment of the last interaction
-    uint256 prevTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.currVariableBorrowIndex);
-
-    //calculate the new total variable debt after accumulation of the interest on the index
-    uint256 currTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex);
-
-    //debt accrued is the sum of the current debt minus the sum of the debt at the last update
-    uint256 totalDebtAccrued = currTotalVariableDebt - prevTotalVariableDebt;
+    // debt accrued is the sum of the current debt minus the sum of the debt at the last update
+    // Rounding down to undermint to the treasury and keep the invariant healthy.
+    uint256 totalDebtAccrued = reserveCache.currScaledVariableDebt.rayMulFloor(
+      reserveCache.nextVariableBorrowIndex - reserveCache.currVariableBorrowIndex
+    );
 
     uint256 amountToMint = totalDebtAccrued.percentMul(reserveCache.reserveFactor);
 
     if (amountToMint != 0) {
-      reserve.accruedToTreasury += amountToMint.rayDiv(reserveCache.nextLiquidityIndex).toUint128();
+      reserve.accruedToTreasury += amountToMint.getATokenMintScaledAmount(reserveCache.nextLiquidityIndex).toUint128();
     }
   }
 
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/SupplyLogic.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/SupplyLogic.sol
index d1d1ee3..78c845b 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/SupplyLogic.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/SupplyLogic.sol
@@ -8,11 +8,11 @@ import {IPool} from "../../../interfaces/IPool.sol";
 import {Errors} from "../helpers/Errors.sol";
 import {UserConfiguration} from "../configuration/UserConfiguration.sol";
 import {DataTypes} from "../types/DataTypes.sol";
-import {WadRayMath} from "../math/WadRayMath.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
 import {ValidationLogic} from "./ValidationLogic.sol";
 import {ReserveLogic} from "./ReserveLogic.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
+import {TokenMath} from "../helpers/TokenMath.sol";
 
 /**
  * @title SupplyLogic library
@@ -25,7 +25,7 @@ library SupplyLogic {
   using GPv2SafeERC20 for IERC20;
   using UserConfiguration for DataTypes.UserConfigurationMap;
   using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
-  using WadRayMath for uint256;
+  using TokenMath for uint256;
   using PercentageMath for uint256;
 
   /**
@@ -48,8 +48,9 @@ library SupplyLogic {
     DataTypes.ReserveCache memory reserveCache = reserve.cache();
 
     reserve.updateState(reserveCache);
+    uint256 scaledAmount = params.amount.getATokenMintScaledAmount(reserveCache.nextLiquidityIndex);
 
-    ValidationLogic.validateSupply(reserveCache, reserve, params.amount, params.onBehalfOf);
+    ValidationLogic.validateSupply(reserveCache, reserve, scaledAmount, params.onBehalfOf);
 
     reserve.updateInterestRatesAndVirtualBalance(
       reserveCache, params.asset, params.amount, 0, params.interestRateStrategyAddress
@@ -57,8 +58,9 @@ library SupplyLogic {
 
     IERC20(params.asset).safeTransferFrom(params.user, reserveCache.aTokenAddress, params.amount);
 
+    // As aToken.mint rounds down the minted shares, we ensure an equivalent of <= params.amount shares is minted.
     bool isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(
-      params.user, params.onBehalfOf, params.amount, reserveCache.nextLiquidityIndex
+      params.user, params.onBehalfOf, scaledAmount, reserveCache.nextLiquidityIndex
     );
 
     if (isFirstSupply) {
@@ -105,40 +107,51 @@ library SupplyLogic {
 
     reserve.updateState(reserveCache);
 
-    uint256 userBalance =
-      IAToken(reserveCache.aTokenAddress).scaledBalanceOf(params.user).rayMul(reserveCache.nextLiquidityIndex);
-
-    uint256 amountToWithdraw = params.amount;
+    uint256 scaledUserBalance = IAToken(reserveCache.aTokenAddress).scaledBalanceOf(params.user);
 
+    uint256 amountToWithdraw;
+    uint256 scaledAmountToWithdraw;
     if (params.amount == type(uint256).max) {
-      amountToWithdraw = userBalance;
+      scaledAmountToWithdraw = scaledUserBalance;
+
+      amountToWithdraw = scaledUserBalance.getATokenBalance(reserveCache.nextLiquidityIndex);
+    } else {
+      scaledAmountToWithdraw = params.amount.getATokenBurnScaledAmount(reserveCache.nextLiquidityIndex);
+
+      amountToWithdraw = params.amount;
     }
 
-    ValidationLogic.validateWithdraw(reserveCache, amountToWithdraw, userBalance);
+    ValidationLogic.validateWithdraw(reserveCache, scaledAmountToWithdraw, scaledUserBalance);
 
     reserve.updateInterestRatesAndVirtualBalance(
       reserveCache, params.asset, 0, amountToWithdraw, params.interestRateStrategyAddress
     );
 
-    bool isCollateral = userConfig.isUsingAsCollateral(reserve.id);
-
-    if (isCollateral && amountToWithdraw == userBalance) {
-      userConfig.setUsingAsCollateral(reserve.id, params.asset, params.user, false);
-    }
-
-    IAToken(reserveCache.aTokenAddress).burn(params.user, params.to, amountToWithdraw, reserveCache.nextLiquidityIndex);
-
-    if (isCollateral && userConfig.isBorrowingAny()) {
-      ValidationLogic.validateHFAndLtv(
-        reservesData,
-        reservesList,
-        eModeCategories,
-        userConfig,
-        params.asset,
-        params.user,
-        params.oracle,
-        params.userEModeCategory
-      );
+    // As aToken.burn rounds up the burned shares, we ensure at least an equivalent of >= amountToWithdraw is burned.
+    bool zeroBalanceAfterBurn = IAToken(reserveCache.aTokenAddress).burn({
+      from: params.user,
+      receiverOfUnderlying: params.to,
+      amount: amountToWithdraw,
+      scaledAmount: scaledAmountToWithdraw,
+      index: reserveCache.nextLiquidityIndex
+    });
+
+    if (userConfig.isUsingAsCollateral(reserve.id)) {
+      if (zeroBalanceAfterBurn) {
+        userConfig.setUsingAsCollateral(reserve.id, params.asset, params.user, false);
+      }
+      if (userConfig.isBorrowingAny()) {
+        ValidationLogic.validateHFAndLtvzero(
+          reservesData,
+          reservesList,
+          eModeCategories,
+          userConfig,
+          params.asset,
+          params.user,
+          params.oracle,
+          params.userEModeCategory
+        );
+      }
     }
 
     emit IPool.Withdraw(params.asset, params.user, params.to, amountToWithdraw);
@@ -170,14 +183,16 @@ library SupplyLogic {
     ValidationLogic.validateTransfer(reserve);
 
     uint256 reserveId = reserve.id;
-    uint256 scaledAmount = params.amount.rayDiv(reserve.getNormalizedIncome());
 
-    if (params.from != params.to && scaledAmount != 0) {
+    if (params.from != params.to && params.scaledAmount != 0) {
       DataTypes.UserConfigurationMap storage fromConfig = usersConfig[params.from];
 
       if (fromConfig.isUsingAsCollateral(reserveId)) {
+        if (params.scaledBalanceFromBefore == params.scaledAmount) {
+          fromConfig.setUsingAsCollateral(reserveId, params.asset, params.from, false);
+        }
         if (fromConfig.isBorrowingAny()) {
-          ValidationLogic.validateHFAndLtv(
+          ValidationLogic.validateHFAndLtvzero(
             reservesData,
             reservesList,
             eModeCategories,
@@ -188,12 +203,9 @@ library SupplyLogic {
             params.fromEModeCategory
           );
         }
-        if (params.balanceFromBefore == params.amount) {
-          fromConfig.setUsingAsCollateral(reserveId, params.asset, params.from, false);
-        }
       }
 
-      if (params.balanceToBefore == 0) {
+      if (params.scaledBalanceToBefore == 0) {
         DataTypes.UserConfigurationMap storage toConfig = usersConfig[params.to];
         if (
           ValidationLogic.validateAutomaticUseAsCollateral(
@@ -252,7 +264,7 @@ library SupplyLogic {
       userConfig.setUsingAsCollateral(reserve.id, asset, user, true);
     } else {
       userConfig.setUsingAsCollateral(reserve.id, asset, user, false);
-      ValidationLogic.validateHFAndLtv(
+      ValidationLogic.validateHFAndLtvzero(
         reservesData, reservesList, eModeCategories, userConfig, asset, user, priceOracle, userEModeCategory
       );
     }
diff --git a/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/TokenMath.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/TokenMath.sol
new file mode 100644
index 0000000..f7d63fc
--- /dev/null
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/TokenMath.sol
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {WadRayMath} from "../../libraries/math/WadRayMath.sol";
+
+/**
+ * @title TokenMath
+ * @author BGD Labs
+ * @notice Provides utility functions for calculating scaled amounts and balances for aTokens and vTokens,
+ *         applying specific rounding rules (floor/ceil) as per Aave v3.5's rounding improvements.
+ *         The rounding behavior of the operations is in line with the ERC-4626 token standard.
+ *         In practice, this means rounding in favor of the protocol.
+ */
+library TokenMath {
+  using WadRayMath for uint256;
+
+  /**
+   * @notice Calculates the scaled amount of aTokens to mint when supplying underlying assets.
+   *         The amount is rounded down to ensure the minted aTokens are less than or equal to the supplied amount.
+   * @param amount The amount of underlying asset supplied.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The scaled amount of aTokens to mint.
+   */
+  function getATokenMintScaledAmount(uint256 amount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return amount.rayDivFloor(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of aTokens to burn when withdrawing underlying assets.
+   *         The scaled amount is rounded up to ensure the user's aToken balance is sufficiently reduced.
+   * @param amount The amount of underlying asset to withdraw.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The scaled amount of aTokens to burn.
+   */
+  function getATokenBurnScaledAmount(uint256 amount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return amount.rayDivCeil(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of aTokens to transfer.
+   *         The scaled amount is rounded up to ensure the recipient receives at least the requested amount.
+   * @param amount The amount of aTokens to transfer.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The scaled amount of aTokens for transfer.
+   */
+  function getATokenTransferScaledAmount(uint256 amount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return amount.rayDivCeil(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the actual aToken balance from a scaled balance and the current liquidityIndex.
+   *         The balance is rounded down to prevent overaccounting.
+   * @param scaledAmount The scaled aToken balance.
+   * @param liquidityIndex The current aToken liquidityIndex.
+   * @return The actual aToken balance.
+   */
+  function getATokenBalance(uint256 scaledAmount, uint256 liquidityIndex) internal pure returns (uint256) {
+    return scaledAmount.rayMulFloor(liquidityIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of vTokens to mint when borrowing.
+   *         The amount is rounded up to ensure the protocol never underaccounts the user's debt.
+   * @param amount The amount of underlying asset borrowed.
+   * @param variableBorrowIndex The current vToken variableBorrowIndex.
+   * @return The scaled amount of vTokens to mint.
+   */
+  function getVTokenMintScaledAmount(uint256 amount, uint256 variableBorrowIndex) internal pure returns (uint256) {
+    return amount.rayDivCeil(variableBorrowIndex);
+  }
+
+  /**
+   * @notice Calculates the scaled amount of vTokens to burn.
+   *         The scaled amount is rounded down to prevent over-burning of vTokens.
+   * @param amount The amount of underlying asset corresponding to the vTokens to burn.
+   * @param variableBorrowIndex The current vToken variableBorrowIndex.
+   * @return The scaled amount of vTokens to burn.
+   */
+  function getVTokenBurnScaledAmount(uint256 amount, uint256 variableBorrowIndex) internal pure returns (uint256) {
+    return amount.rayDivFloor(variableBorrowIndex);
+  }
+
+  /**
+   * @notice Calculates the actual vToken balance (debt) from a scaled balance and the current variableBorrowIndex.
+   *         The balance is rounded up to prevent underaccounting the user's debt.
+   * @param scaledAmount The scaled vToken balance.
+   * @param variableBorrowIndex The current vToken variableBorrowIndex.
+   * @return The actual vToken balance (debt).
+   */
+  function getVTokenBalance(uint256 scaledAmount, uint256 variableBorrowIndex) internal pure returns (uint256) {
+    return scaledAmount.rayMulCeil(variableBorrowIndex);
+  }
+}
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/ValidationLogic.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/ValidationLogic.sol
index a894189..9484e9c 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/ValidationLogic.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/ValidationLogic.sol
@@ -13,13 +13,14 @@ import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
 import {UserConfiguration} from "../configuration/UserConfiguration.sol";
 import {EModeConfiguration} from "../configuration/EModeConfiguration.sol";
 import {Errors} from "../helpers/Errors.sol";
-import {WadRayMath} from "../math/WadRayMath.sol";
+import {TokenMath} from "../helpers/TokenMath.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {ReserveLogic} from "./ReserveLogic.sol";
 import {GenericLogic} from "./GenericLogic.sol";
 import {SafeCast} from "openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
 import {IncentivizedERC20} from "../../tokenization/base/IncentivizedERC20.sol";
+import {MathUtils} from "../math/MathUtils.sol";
 
 /**
  * @title ValidationLogic library
@@ -28,7 +29,7 @@ import {IncentivizedERC20} from "../../tokenization/base/IncentivizedERC20.sol";
  */
 library ValidationLogic {
   using ReserveLogic for DataTypes.ReserveData;
-  using WadRayMath for uint256;
+  using TokenMath for uint256;
   using PercentageMath for uint256;
   using SafeCast for uint256;
   using GPv2SafeERC20 for IERC20;
@@ -58,15 +59,15 @@ library ValidationLogic {
   /**
    * @notice Validates a supply action.
    * @param reserveCache The cached data of the reserve
-   * @param amount The amount to be supplied
+   * @param scaledAmount The scaledAmount to be supplied
    */
   function validateSupply(
     DataTypes.ReserveCache memory reserveCache,
     DataTypes.ReserveData storage reserve,
-    uint256 amount,
+    uint256 scaledAmount,
     address onBehalfOf
   ) internal view {
-    require(amount != 0, Errors.InvalidAmount());
+    require(scaledAmount != 0, Errors.InvalidAmount());
 
     (bool isActive, bool isFrozen,, bool isPaused) = reserveCache.reserveConfiguration.getFlags();
     require(isActive, Errors.ReserveInactive());
@@ -78,9 +79,8 @@ library ValidationLogic {
     require(
       supplyCap == 0
         || (
-          (IAToken(reserveCache.aTokenAddress).scaledTotalSupply() + uint256(reserve.accruedToTreasury)).rayMul(
-            reserveCache.nextLiquidityIndex
-          ) + amount
+          (IAToken(reserveCache.aTokenAddress).scaledTotalSupply() + scaledAmount + uint256(reserve.accruedToTreasury))
+            .getATokenBalance(reserveCache.nextLiquidityIndex)
         ) <= supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),
       Errors.SupplyCapExceeded()
     );
@@ -89,15 +89,15 @@ library ValidationLogic {
   /**
    * @notice Validates a withdraw action.
    * @param reserveCache The cached data of the reserve
-   * @param amount The amount to be withdrawn
-   * @param userBalance The balance of the user
+   * @param scaledAmount The scaled amount to be withdrawn
+   * @param scaledUserBalance The scaled balance of the user
    */
-  function validateWithdraw(DataTypes.ReserveCache memory reserveCache, uint256 amount, uint256 userBalance)
+  function validateWithdraw(DataTypes.ReserveCache memory reserveCache, uint256 scaledAmount, uint256 scaledUserBalance)
     internal
     pure
   {
-    require(amount != 0, Errors.InvalidAmount());
-    require(amount <= userBalance, Errors.NotEnoughAvailableUserBalance());
+    require(scaledAmount != 0, Errors.InvalidAmount());
+    require(scaledAmount <= scaledUserBalance, Errors.NotEnoughAvailableUserBalance());
 
     (bool isActive,,, bool isPaused) = reserveCache.reserveConfiguration.getFlags();
     require(isActive, Errors.ReserveInactive());
@@ -105,14 +105,10 @@ library ValidationLogic {
   }
 
   struct ValidateBorrowLocalVars {
-    uint256 currentLtv;
-    uint256 collateralNeededInBaseCurrency;
-    uint256 userCollateralInBaseCurrency;
+    uint256 amount;
     uint256 userDebtInBaseCurrency;
     uint256 availableLiquidity;
-    uint256 healthFactor;
     uint256 totalDebt;
-    uint256 totalSupplyVariableDebt;
     uint256 reserveDecimals;
     uint256 borrowCap;
     uint256 amountInBaseCurrency;
@@ -138,9 +134,10 @@ library ValidationLogic {
     mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
     DataTypes.ValidateBorrowParams memory params
   ) internal view {
-    require(params.amount != 0, Errors.InvalidAmount());
+    require(params.amountScaled != 0, Errors.InvalidAmount());
 
     ValidateBorrowLocalVars memory vars;
+    vars.amount = params.amountScaled.getVTokenBalance(params.reserveCache.nextVariableBorrowIndex);
 
     (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.isPaused) =
       params.reserveCache.reserveConfiguration.getFlags();
@@ -149,7 +146,7 @@ library ValidationLogic {
     require(!vars.isPaused, Errors.ReservePaused());
     require(!vars.isFrozen, Errors.ReserveFrozen());
     require(vars.borrowingEnabled, Errors.BorrowingNotEnabled());
-    require(IERC20(params.reserveCache.aTokenAddress).totalSupply() >= params.amount, Errors.InvalidAmount());
+    require(IERC20(params.reserveCache.aTokenAddress).totalSupply() >= vars.amount, Errors.InvalidAmount());
 
     require(
       params.priceOracleSentinel == address(0) || IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),
@@ -166,10 +163,9 @@ library ValidationLogic {
     }
 
     if (vars.borrowCap != 0) {
-      vars.totalSupplyVariableDebt =
-        params.reserveCache.currScaledVariableDebt.rayMul(params.reserveCache.nextVariableBorrowIndex);
-
-      vars.totalDebt = vars.totalSupplyVariableDebt + params.amount;
+      vars.totalDebt = (params.reserveCache.currScaledVariableDebt + params.amountScaled).getVTokenBalance(
+        params.reserveCache.nextVariableBorrowIndex
+      );
 
       unchecked {
         require(vars.totalDebt <= vars.borrowCap * vars.assetUnit, Errors.BorrowCapExceeded());
@@ -185,37 +181,6 @@ library ValidationLogic {
       );
     }
 
-    (vars.userCollateralInBaseCurrency, vars.userDebtInBaseCurrency, vars.currentLtv,, vars.healthFactor,) =
-    GenericLogic.calculateUserAccountData(
-      reservesData,
-      reservesList,
-      eModeCategories,
-      DataTypes.CalculateUserAccountDataParams({
-        userConfig: params.userConfig,
-        user: params.userAddress,
-        oracle: params.oracle,
-        userEModeCategory: params.userEModeCategory
-      })
-    );
-
-    require(vars.userCollateralInBaseCurrency != 0, Errors.CollateralBalanceIsZero());
-    require(vars.currentLtv != 0, Errors.LtvValidationFailed());
-
-    require(vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.HealthFactorLowerThanLiquidationThreshold());
-
-    vars.amountInBaseCurrency = IPriceOracleGetter(params.oracle).getAssetPrice(params.asset) * params.amount;
-    unchecked {
-      vars.amountInBaseCurrency /= vars.assetUnit;
-    }
-
-    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.
-    vars.collateralNeededInBaseCurrency =
-      (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency).percentDiv(vars.currentLtv); //LTV is calculated in percentage
-
-    require(
-      vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency, Errors.CollateralCannotCoverNewBorrow()
-    );
-
     if (params.userConfig.isBorrowingAny()) {
       (vars.siloedBorrowingEnabled, vars.siloedBorrowingAddress) =
         params.userConfig.getSiloedBorrowingState(reservesData, reservesList);
@@ -234,7 +199,7 @@ library ValidationLogic {
    * @param reserveCache The cached data of the reserve
    * @param amountSent The amount sent for the repayment. Can be an actual value or type(uint256).max
    * @param onBehalfOf The address of the user sender is repaying for
-   * @param debt The borrow balance of the user
+   * @param debtScaled The borrow scaled balance of the user
    */
   function validateRepay(
     address user,
@@ -242,7 +207,7 @@ library ValidationLogic {
     uint256 amountSent,
     DataTypes.InterestRateMode interestRateMode,
     address onBehalfOf,
-    uint256 debt
+    uint256 debtScaled
   ) internal pure {
     require(amountSent != 0, Errors.InvalidAmount());
     require(interestRateMode == DataTypes.InterestRateMode.VARIABLE, Errors.InvalidInterestRateModeSelected());
@@ -252,7 +217,7 @@ library ValidationLogic {
     require(isActive, Errors.ReserveInactive());
     require(!isPaused, Errors.ReservePaused());
 
-    require(debt != 0, Errors.NoDebtOfSelectedType());
+    require(debtScaled != 0, Errors.NoDebtOfSelectedType());
   }
 
   /**
@@ -389,7 +354,51 @@ library ValidationLogic {
   }
 
   /**
-   * @notice Validates the health factor of a user and the ltv of the asset being withdrawn.
+   * @notice Validates the health factor of a user and the ltv of the asset being borrowed.
+   *         The ltv validation is a measure to prevent accidental borrowing close to liquidations.
+   *         Sophisticated users can work around this validation in various ways.
+   * @param reservesData The state of all the reserves
+   * @param reservesList The addresses of all the active reserves
+   * @param eModeCategories The configuration of all the efficiency mode categories
+   * @param userConfig The state of the user for the specific reserve
+   * @param user The user from which the aTokens are being transferred
+   * @param userEModeCategory The users active efficiency mode category
+   * @param oracle The price oracle
+   */
+  function validateHFAndLtv(
+    mapping(address => DataTypes.ReserveData) storage reservesData,
+    mapping(uint256 => address) storage reservesList,
+    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
+    DataTypes.UserConfigurationMap memory userConfig,
+    address user,
+    uint8 userEModeCategory,
+    address oracle
+  ) internal view {
+    (uint256 userCollateralInBaseCurrency, uint256 userDebtInBaseCurrency, uint256 currentLtv,, uint256 healthFactor,) =
+    GenericLogic.calculateUserAccountData(
+      reservesData,
+      reservesList,
+      eModeCategories,
+      DataTypes.CalculateUserAccountDataParams({
+        userConfig: userConfig,
+        user: user,
+        oracle: oracle,
+        userEModeCategory: userEModeCategory
+      })
+    );
+
+    require(currentLtv != 0, Errors.LtvValidationFailed());
+
+    require(healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.HealthFactorLowerThanLiquidationThreshold());
+
+    require(
+      userCollateralInBaseCurrency >= userDebtInBaseCurrency.percentDivCeil(currentLtv),
+      Errors.CollateralCannotCoverNewBorrow()
+    );
+  }
+
+  /**
+   * @notice Validates the health factor of a user and the ltvzero configuration for the asset being withdrawn/transferred or disabled as collateral.
    * @param reservesData The state of all the reserves
    * @param reservesList The addresses of all the active reserves
    * @param eModeCategories The configuration of all the efficiency mode categories
@@ -399,7 +408,7 @@ library ValidationLogic {
    * @param oracle The price oracle
    * @param userEModeCategory The users active efficiency mode category
    */
-  function validateHFAndLtv(
+  function validateHFAndLtvzero(
     mapping(address => DataTypes.ReserveData) storage reservesData,
     mapping(uint256 => address) storage reservesList,
     mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
diff --git a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/WadRayMath.sol b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/WadRayMath.sol
index 433dd94..88e3b00 100644
--- a/tmp/1_0x1eF34B91afC368174F579067D1DB94325cDC7946_flat/WadRayMath.sol
+++ b/tmp/1_0x034Fd14b9Ae6bB066a1F9f85A55e990b0b25c168_flat/WadRayMath.sol
@@ -6,10 +6,16 @@ pragma solidity ^0.8.0;
  * @author Aave
  * @notice Provides functions to perform calculations with Wad and Ray units
  * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers
- * with 27 digits of precision)
- * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.
+ * with 27 digits of precision).
+ * @dev Default operations round half up (if a value is >= .5, it will be rounded up, otherwise rounded down).
+ * @dev For specific rounding behaviors, functions with `Floor` and `Ceil` suffixes or a `Rounding` parameter are available.
  */
 library WadRayMath {
+  enum Rounding {
+    Floor,
+    Ceil
+  }
+
   // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly
   uint256 internal constant WAD = 1e18;
   uint256 internal constant HALF_WAD = 0.5e18;
@@ -51,22 +57,38 @@ library WadRayMath {
     }
   }
 
-  /**
-   * @notice Multiplies two ray, rounding half up to the nearest ray
-   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-   * @param a Ray
-   * @param b Ray
-   * @return c = a raymul b
-   */
   function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
-    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
     assembly {
+      // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
       if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) { revert(0, 0) }
-
       c := div(add(mul(a, b), HALF_RAY), RAY)
     }
   }
 
+  function rayMul(uint256 a, uint256 b, Rounding rounding) internal pure returns (uint256 c) {
+    if (rounding == Rounding.Floor) return rayMulFloor(a, b);
+    return rayMulCeil(a, b);
+  }
+
+  function rayMulFloor(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * b does not exceed uint256 max
+      if iszero(or(iszero(b), iszero(gt(a, div(not(0), b))))) { revert(0, 0) }
+
+      c := div(mul(a, b), RAY)
+    }
+  }
+
+  function rayMulCeil(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * b does not exceed uint256 max
+      if iszero(or(iszero(b), iszero(gt(a, div(not(0), b))))) { revert(0, 0) }
+
+      let product := mul(a, b)
+      c := add(div(product, RAY), iszero(iszero(mod(product, RAY))))
+    }
+  }
+
   /**
    * @notice Divides two ray, rounding half up to the nearest ray
    * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
@@ -75,14 +97,35 @@ library WadRayMath {
    * @return c = a raydiv b
    */
   function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
-    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY
     assembly {
+      // to avoid overflow, a <= (type(uint256).max - b / 2) / RAY
       if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) { revert(0, 0) }
-
       c := div(add(mul(a, RAY), div(b, 2)), b)
     }
   }
 
+  function rayDiv(uint256 a, uint256 b, Rounding rounding) internal pure returns (uint256 c) {
+    if (rounding == Rounding.Floor) return rayDivFloor(a, b);
+    return rayDivCeil(a, b);
+  }
+
+  function rayDivCeil(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * RAY does not exceed uint256 max
+      if or(iszero(b), iszero(iszero(gt(a, div(not(0), RAY))))) { revert(0, 0) }
+      let scaled := mul(a, RAY)
+      c := add(div(scaled, b), iszero(iszero(mod(scaled, b))))
+    }
+  }
+
+  function rayDivFloor(uint256 a, uint256 b) internal pure returns (uint256 c) {
+    assembly {
+      // Overflow check: Ensure a * RAY does not exceed uint256 max
+      if or(iszero(b), iszero(iszero(gt(a, div(not(0), RAY))))) { revert(0, 0) }
+      c := div(mul(a, RAY), b)
+    }
+  }
+
   /**
    * @dev Casts ray down to wad
    * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
