"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/viem/_esm/errors/version.js
  var version;
  var init_version = __esm({
    "node_modules/viem/_esm/errors/version.js"() {
      "use strict";
      version = "2.7.15";
    }
  });

  // node_modules/viem/_esm/errors/utils.js
  var getUrl, getVersion;
  var init_utils = __esm({
    "node_modules/viem/_esm/errors/utils.js"() {
      "use strict";
      init_version();
      getUrl = (url) => url;
      getVersion = () => `viem@${version}`;
    }
  });

  // node_modules/viem/_esm/errors/base.js
  function walk(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err)
      return walk(err.cause, fn);
    return fn ? null : err;
  }
  var BaseError;
  var init_base = __esm({
    "node_modules/viem/_esm/errors/base.js"() {
      "use strict";
      init_utils();
      BaseError = class _BaseError extends Error {
        constructor(shortMessage, args = {}) {
          super();
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ViemError"
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: getVersion()
          });
          const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
          const docsPath3 = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
          this.message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsPath3 ? [
              `Docs: https://viem.sh${docsPath3}${args.docsSlug ? `#${args.docsSlug}` : ""}`
            ] : [],
            ...details ? [`Details: ${details}`] : [],
            `Version: ${this.version}`
          ].join("\n");
          if (args.cause)
            this.cause = args.cause;
          this.details = details;
          this.docsPath = docsPath3;
          this.metaMessages = args.metaMessages;
          this.shortMessage = shortMessage;
        }
        walk(fn) {
          return walk(this, fn);
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/encoding.js
  var IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, SizeOverflowError;
  var init_encoding = __esm({
    "node_modules/viem/_esm/errors/encoding.js"() {
      "use strict";
      init_base();
      IntegerOutOfRangeError = class extends BaseError {
        constructor({ max, min, signed, size: size3, value }) {
          super(`Number "${value}" is not in safe ${size3 ? `${size3 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntegerOutOfRangeError"
          });
        }
      };
      InvalidBytesBooleanError = class extends BaseError {
        constructor(bytes2) {
          super(`Bytes value "${bytes2}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidBytesBooleanError"
          });
        }
      };
      InvalidHexBooleanError = class extends BaseError {
        constructor(hex) {
          super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidHexBooleanError"
          });
        }
      };
      SizeOverflowError = class extends BaseError {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeOverflowError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/data/isHex.js
  function isHex(value, { strict = true } = {}) {
    if (!value)
      return false;
    if (typeof value !== "string")
      return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
  }
  var init_isHex = __esm({
    "node_modules/viem/_esm/utils/data/isHex.js"() {
      "use strict";
    }
  });

  // node_modules/viem/_esm/utils/data/size.js
  function size(value) {
    if (isHex(value, { strict: false }))
      return Math.ceil((value.length - 2) / 2);
    return value.length;
  }
  var init_size = __esm({
    "node_modules/viem/_esm/utils/data/size.js"() {
      "use strict";
      init_isHex();
    }
  });

  // node_modules/viem/_esm/utils/data/trim.js
  function trim(hexOrBytes, { dir = "left" } = {}) {
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
      if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
      if (data.length === 1 && dir === "right")
        data = `${data}0`;
      return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
  }
  var init_trim = __esm({
    "node_modules/viem/_esm/utils/data/trim.js"() {
      "use strict";
    }
  });

  // node_modules/viem/_esm/errors/data.js
  var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;
  var init_data = __esm({
    "node_modules/viem/_esm/errors/data.js"() {
      "use strict";
      init_base();
      SliceOffsetOutOfBoundsError = class extends BaseError {
        constructor({ offset, position, size: size3 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size3}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SliceOffsetOutOfBoundsError"
          });
        }
      };
      SizeExceedsPaddingSizeError = class extends BaseError {
        constructor({ size: size3, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size3}) exceeds padding size (${targetSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/data/pad.js
  function pad(hexOrBytes, { dir, size: size3 = 32 } = {}) {
    if (typeof hexOrBytes === "string")
      return padHex(hexOrBytes, { dir, size: size3 });
    return padBytes(hexOrBytes, { dir, size: size3 });
  }
  function padHex(hex_, { dir, size: size3 = 32 } = {}) {
    if (size3 === null)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size3 * 2)
      throw new SizeExceedsPaddingSizeError({
        size: Math.ceil(hex.length / 2),
        targetSize: size3,
        type: "hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
  }
  function padBytes(bytes2, { dir, size: size3 = 32 } = {}) {
    if (size3 === null)
      return bytes2;
    if (bytes2.length > size3)
      throw new SizeExceedsPaddingSizeError({
        size: bytes2.length,
        targetSize: size3,
        type: "bytes"
      });
    const paddedBytes = new Uint8Array(size3);
    for (let i = 0; i < size3; i++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i : size3 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
    }
    return paddedBytes;
  }
  var init_pad = __esm({
    "node_modules/viem/_esm/utils/data/pad.js"() {
      "use strict";
      init_data();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toHex.js
  function toHex(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex(value, opts);
    if (typeof value === "string") {
      return stringToHex(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex(value, opts);
    return bytesToHex(value, opts);
  }
  function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { size: opts.size });
    }
    return hex;
  }
  function bytesToHex(value, opts = {}) {
    let string = "";
    for (let i = 0; i < value.length; i++) {
      string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { dir: "right", size: opts.size });
    }
    return hex;
  }
  function numberToHex(value_, opts = {}) {
    const { signed, size: size3 } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size3) {
      if (signed)
        maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed,
        size: size3,
        value: `${value_}${suffix}`
      });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size3)
      return pad(hex, { size: size3 });
    return hex;
  }
  function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
  }
  var hexes, encoder;
  var init_toHex = __esm({
    "node_modules/viem/_esm/utils/encoding/toHex.js"() {
      "use strict";
      init_encoding();
      init_pad();
      init_fromHex();
      hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
      encoder = /* @__PURE__ */ new TextEncoder();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toBytes.js
  function toBytes(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes(value, opts);
    if (typeof value === "boolean")
      return boolToBytes(value, opts);
    if (isHex(value))
      return hexToBytes(value, opts);
    return stringToBytes(value, opts);
  }
  function boolToBytes(value, opts = {}) {
    const bytes2 = new Uint8Array(1);
    bytes2[0] = Number(value);
    if (typeof opts.size === "number") {
      assertSize(bytes2, { size: opts.size });
      return pad(bytes2, { size: opts.size });
    }
    return bytes2;
  }
  function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
      return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
      return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
      return char - (charCodeMap.a - 10);
    return void 0;
  }
  function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = pad(hex, { dir: "right", size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes2 = new Uint8Array(length);
    for (let index2 = 0, j = 0; index2 < length; index2++) {
      const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
      const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
      }
      bytes2[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes2;
  }
  function numberToBytes(value, opts) {
    const hex = numberToHex(value, opts);
    return hexToBytes(hex);
  }
  function stringToBytes(value, opts = {}) {
    const bytes2 = encoder2.encode(value);
    if (typeof opts.size === "number") {
      assertSize(bytes2, { size: opts.size });
      return pad(bytes2, { dir: "right", size: opts.size });
    }
    return bytes2;
  }
  var encoder2, charCodeMap;
  var init_toBytes = __esm({
    "node_modules/viem/_esm/utils/encoding/toBytes.js"() {
      "use strict";
      init_base();
      init_isHex();
      init_pad();
      init_fromHex();
      init_toHex();
      encoder2 = /* @__PURE__ */ new TextEncoder();
      charCodeMap = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
      };
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromHex.js
  function assertSize(hexOrBytes, { size: size3 }) {
    if (size(hexOrBytes) > size3)
      throw new SizeOverflowError({
        givenSize: size(hexOrBytes),
        maxSize: size3
      });
  }
  function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === "number")
      return hexToNumber(hex, opts);
    if (to === "bigint")
      return hexToBigInt(hex, opts);
    if (to === "string")
      return hexToString(hex, opts);
    if (to === "boolean")
      return hexToBool(hex, opts);
    return hexToBytes(hex, opts);
  }
  function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size)
      assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed)
      return value;
    const size3 = (hex.length - 2) / 2;
    const max = (1n << BigInt(size3) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size3 * 2, "f")}`) - 1n;
  }
  function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = trim(hex);
    }
    if (trim(hex) === "0x00")
      return false;
    if (trim(hex) === "0x01")
      return true;
    throw new InvalidHexBooleanError(hex);
  }
  function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
  }
  function hexToString(hex, opts = {}) {
    let bytes2 = hexToBytes(hex);
    if (opts.size) {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  var init_fromHex = __esm({
    "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
      "use strict";
      init_encoding();
      init_size();
      init_trim();
      init_toBytes();
    }
  });

  // node_modules/viem/_esm/utils/formatters/formatter.js
  function defineFormatter(type, format) {
    return ({ exclude, format: overrides }) => {
      return {
        exclude,
        format: (args) => {
          const formatted = format(args);
          if (exclude) {
            for (const key of exclude) {
              delete formatted[key];
            }
          }
          return {
            ...formatted,
            ...overrides(args)
          };
        },
        type
      };
    };
  }
  var init_formatter = __esm({
    "node_modules/viem/_esm/utils/formatters/formatter.js"() {
      "use strict";
    }
  });

  // node_modules/viem/_esm/errors/address.js
  var InvalidAddressError;
  var init_address = __esm({
    "node_modules/viem/_esm/errors/address.js"() {
      "use strict";
      init_base();
      InvalidAddressError = class extends BaseError {
        constructor({ address }) {
          super(`Address "${address}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAddressError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/lru.js
  var LruMap;
  var init_lru = __esm({
    "node_modules/viem/_esm/utils/lru.js"() {
      "use strict";
      LruMap = class extends Map {
        constructor(size3) {
          super();
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.maxSize = size3;
        }
        set(key, value) {
          super.set(key, value);
          if (this.maxSize && this.size > this.maxSize)
            this.delete(this.keys().next().value);
          return this;
        }
      };
    }
  });

  // node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var init_assert = __esm({
    "node_modules/@noble/hashes/esm/_assert.js"() {
      "use strict";
    }
  });

  // node_modules/@noble/hashes/esm/_u64.js
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var U32_MASK64, _32n, rotlSH, rotlSL, rotlBH, rotlBL;
  var init_u64 = __esm({
    "node_modules/@noble/hashes/esm/_u64.js"() {
      "use strict";
      U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      _32n = /* @__PURE__ */ BigInt(32);
      rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    }
  });

  // node_modules/@noble/hashes/esm/utils.js
  function utf8ToBytes(str2) {
    if (typeof str2 !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
    return new Uint8Array(new TextEncoder().encode(str2));
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  var u8a, u32, isLE, Hash, toStr;
  var init_utils2 = __esm({
    "node_modules/@noble/hashes/esm/utils.js"() {
      "use strict";
      u8a = (a) => a instanceof Uint8Array;
      u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!isLE)
        throw new Error("Non little-endian hardware is not supported");
      Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      toStr = {}.toString;
    }
  });

  // node_modules/@noble/hashes/esm/sha3.js
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
  var init_sha3 = __esm({
    "node_modules/@noble/hashes/esm/sha3.js"() {
      "use strict";
      init_assert();
      init_u64();
      init_utils2();
      [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      _0n = /* @__PURE__ */ BigInt(0);
      _1n = /* @__PURE__ */ BigInt(1);
      _2n = /* @__PURE__ */ BigInt(2);
      _7n = /* @__PURE__ */ BigInt(7);
      _256n = /* @__PURE__ */ BigInt(256);
      _0x71n = /* @__PURE__ */ BigInt(113);
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
      rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
      rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
      Keccak = class _Keccak extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = u32(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          exists(this);
          const { blockLen, state } = this;
          data = toBytes2(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          exists(this, false);
          bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes2) {
          number(bytes2);
          return this.xofInto(new Uint8Array(bytes2));
        }
        digestInto(out) {
          output(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
      sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
      sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
      sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
      sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
      keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
      keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
      keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
      keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
      genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
      shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
    }
  });

  // node_modules/viem/_esm/utils/hash/keccak256.js
  function keccak256(value, to_) {
    const to = to_ || "hex";
    const bytes2 = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
    if (to === "bytes")
      return bytes2;
    return toHex(bytes2);
  }
  var init_keccak256 = __esm({
    "node_modules/viem/_esm/utils/hash/keccak256.js"() {
      "use strict";
      init_sha3();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/address/getAddress.js
  function checksumAddress(address_, chainId) {
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for (let i = 0; i < 40; i += 2) {
      if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
        address[i] = address[i].toUpperCase();
      }
      if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
        address[i + 1] = address[i + 1].toUpperCase();
      }
    }
    return `0x${address.join("")}`;
  }
  var init_getAddress = __esm({
    "node_modules/viem/_esm/utils/address/getAddress.js"() {
      "use strict";
      init_toBytes();
      init_keccak256();
    }
  });

  // node_modules/viem/_esm/utils/address/isAddress.js
  function isAddress(address, { strict = true } = {}) {
    if (isAddressCache.has(address))
      return isAddressCache.get(address);
    const result = (() => {
      if (!addressRegex.test(address))
        return false;
      if (address.toLowerCase() === address)
        return true;
      if (strict)
        return checksumAddress(address) === address;
      return true;
    })();
    isAddressCache.set(address, result);
    return result;
  }
  var addressRegex, isAddressCache;
  var init_isAddress = __esm({
    "node_modules/viem/_esm/utils/address/isAddress.js"() {
      "use strict";
      init_lru();
      init_getAddress();
      addressRegex = /^0x[a-fA-F0-9]{40}$/;
      isAddressCache = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/data/concat.js
  function concat(values) {
    if (typeof values[0] === "string")
      return concatHex(values);
    return concatBytes(values);
  }
  function concatBytes(values) {
    let length = 0;
    for (const arr of values) {
      length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  function concatHex(values) {
    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
  }
  var init_concat = __esm({
    "node_modules/viem/_esm/utils/data/concat.js"() {
      "use strict";
    }
  });

  // node_modules/abitype/dist/esm/version.js
  var version2;
  var init_version2 = __esm({
    "node_modules/abitype/dist/esm/version.js"() {
      "use strict";
      version2 = "1.0.0";
    }
  });

  // node_modules/abitype/dist/esm/errors.js
  var BaseError2;
  var init_errors = __esm({
    "node_modules/abitype/dist/esm/errors.js"() {
      "use strict";
      init_version2();
      BaseError2 = class _BaseError extends Error {
        constructor(shortMessage, args = {}) {
          const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
          const docsPath3 = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
          const message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsPath3 ? [`Docs: https://abitype.dev${docsPath3}`] : [],
            ...details ? [`Details: ${details}`] : [],
            `Version: abitype@${version2}`
          ].join("\n");
          super(message);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiTypeError"
          });
          if (args.cause)
            this.cause = args.cause;
          this.details = details;
          this.docsPath = docsPath3;
          this.metaMessages = args.metaMessages;
          this.shortMessage = shortMessage;
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/regex.js
  function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
  }
  var bytesRegex, integerRegex, isTupleRegex;
  var init_regex = __esm({
    "node_modules/abitype/dist/esm/regex.js"() {
      "use strict";
      bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
      isTupleRegex = /^\(.+?\).*?$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
  function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
      type = "(";
      const length = abiParameter.components.length;
      for (let i = 0; i < length; i++) {
        const component = abiParameter.components[i];
        type += formatAbiParameter(component);
        if (i < length - 1)
          type += ", ";
      }
      const result = execTyped(tupleRegex, abiParameter.type);
      type += `)${result?.array ?? ""}`;
      return formatAbiParameter({
        ...abiParameter,
        type
      });
    }
    if ("indexed" in abiParameter && abiParameter.indexed)
      type = `${type} indexed`;
    if (abiParameter.name)
      return `${type} ${abiParameter.name}`;
    return type;
  }
  var tupleRegex;
  var init_formatAbiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"() {
      "use strict";
      init_regex();
      tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
  function formatAbiParameters(abiParameters) {
    let params = "";
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
      const abiParameter = abiParameters[i];
      params += formatAbiParameter(abiParameter);
      if (i !== length - 1)
        params += ", ";
    }
    return params;
  }
  var init_formatAbiParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"() {
      "use strict";
      init_formatAbiParameter();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
  function formatAbiItem(abiItem) {
    if (abiItem.type === "function")
      return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
    else if (abiItem.type === "event")
      return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
    else if (abiItem.type === "error")
      return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
    else if (abiItem.type === "constructor")
      return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
    else if (abiItem.type === "fallback")
      return "fallback()";
    return "receive() external payable";
  }
  var init_formatAbiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"() {
      "use strict";
      init_formatAbiParameters();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
  function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
  }
  function execStructSignature(signature) {
    return execTyped(structSignatureRegex, signature);
  }
  var structSignatureRegex, modifiers, functionModifiers;
  var init_signatures = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"() {
      "use strict";
      init_regex();
      structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
      modifiers = /* @__PURE__ */ new Set([
        "memory",
        "indexed",
        "storage",
        "calldata"
      ]);
      functionModifiers = /* @__PURE__ */ new Set([
        "calldata",
        "memory",
        "storage"
      ]);
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
  var UnknownTypeError, UnknownSolidityTypeError;
  var init_abiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"() {
      "use strict";
      init_errors();
      UnknownTypeError = class extends BaseError2 {
        constructor({ type }) {
          super("Unknown type.", {
            metaMessages: [
              `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownTypeError"
          });
        }
      };
      UnknownSolidityTypeError = class extends BaseError2 {
        constructor({ type }) {
          super("Unknown type.", {
            metaMessages: [`Type "${type}" is not a valid ABI type.`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownSolidityTypeError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
  var InvalidAbiParametersError, InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;
  var init_abiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"() {
      "use strict";
      init_errors();
      InvalidAbiParametersError = class extends BaseError2 {
        constructor({ params }) {
          super("Failed to parse ABI parameters.", {
            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
            docsPath: "/api/human#parseabiparameters-1"
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiParametersError"
          });
        }
      };
      InvalidParameterError = class extends BaseError2 {
        constructor({ param }) {
          super("Invalid ABI parameter.", {
            details: param
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParameterError"
          });
        }
      };
      SolidityProtectedKeywordError = class extends BaseError2 {
        constructor({ param, name }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SolidityProtectedKeywordError"
          });
        }
      };
      InvalidModifierError = class extends BaseError2 {
        constructor({ param, type, modifier }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidModifierError"
          });
        }
      };
      InvalidFunctionModifierError = class extends BaseError2 {
        constructor({ param, type, modifier }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
              `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidFunctionModifierError"
          });
        }
      };
      InvalidAbiTypeParameterError = class extends BaseError2 {
        constructor({ abiParameter }) {
          super("Invalid ABI parameter.", {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiTypeParameterError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/signature.js
  var InvalidSignatureError, InvalidStructSignatureError;
  var init_signature = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/signature.js"() {
      "use strict";
      init_errors();
      InvalidSignatureError = class extends BaseError2 {
        constructor({ signature, type }) {
          super(`Invalid ${type} signature.`, {
            details: signature
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSignatureError"
          });
        }
      };
      InvalidStructSignatureError = class extends BaseError2 {
        constructor({ signature }) {
          super("Invalid struct signature.", {
            details: signature,
            metaMessages: ["No properties exist."]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidStructSignatureError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/struct.js
  var CircularReferenceError;
  var init_struct = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/struct.js"() {
      "use strict";
      init_errors();
      CircularReferenceError = class extends BaseError2 {
        constructor({ type }) {
          super("Circular reference detected.", {
            metaMessages: [`Struct "${type}" is a circular reference.`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "CircularReferenceError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
  var InvalidParenthesisError;
  var init_splitParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"() {
      "use strict";
      init_errors();
      InvalidParenthesisError = class extends BaseError2 {
        constructor({ current, depth }) {
          super("Unbalanced parentheses.", {
            metaMessages: [
              `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
            ],
            details: `Depth "${depth}"`
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParenthesisError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/cache.js
  function getParameterCacheKey(param, type) {
    if (type)
      return `${type}:${param}`;
    return param;
  }
  var parameterCache;
  var init_cache = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/cache.js"() {
      "use strict";
      parameterCache = /* @__PURE__ */ new Map([
        // Unnamed
        ["address", { type: "address" }],
        ["bool", { type: "bool" }],
        ["bytes", { type: "bytes" }],
        ["bytes32", { type: "bytes32" }],
        ["int", { type: "int256" }],
        ["int256", { type: "int256" }],
        ["string", { type: "string" }],
        ["uint", { type: "uint256" }],
        ["uint8", { type: "uint8" }],
        ["uint16", { type: "uint16" }],
        ["uint24", { type: "uint24" }],
        ["uint32", { type: "uint32" }],
        ["uint64", { type: "uint64" }],
        ["uint96", { type: "uint96" }],
        ["uint112", { type: "uint112" }],
        ["uint160", { type: "uint160" }],
        ["uint192", { type: "uint192" }],
        ["uint256", { type: "uint256" }],
        // Named
        ["address owner", { type: "address", name: "owner" }],
        ["address to", { type: "address", name: "to" }],
        ["bool approved", { type: "bool", name: "approved" }],
        ["bytes _data", { type: "bytes", name: "_data" }],
        ["bytes data", { type: "bytes", name: "data" }],
        ["bytes signature", { type: "bytes", name: "signature" }],
        ["bytes32 hash", { type: "bytes32", name: "hash" }],
        ["bytes32 r", { type: "bytes32", name: "r" }],
        ["bytes32 root", { type: "bytes32", name: "root" }],
        ["bytes32 s", { type: "bytes32", name: "s" }],
        ["string name", { type: "string", name: "name" }],
        ["string symbol", { type: "string", name: "symbol" }],
        ["string tokenURI", { type: "string", name: "tokenURI" }],
        ["uint tokenId", { type: "uint256", name: "tokenId" }],
        ["uint8 v", { type: "uint8", name: "v" }],
        ["uint256 balance", { type: "uint256", name: "balance" }],
        ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
        ["uint256 value", { type: "uint256", name: "value" }],
        // Indexed
        [
          "event:address indexed from",
          { type: "address", name: "from", indexed: true }
        ],
        ["event:address indexed to", { type: "address", name: "to", indexed: true }],
        [
          "event:uint indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: true }
        ],
        [
          "event:uint256 indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: true }
        ]
      ]);
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/utils.js
  function parseAbiParameter(param, options2) {
    const parameterCacheKey = getParameterCacheKey(param, options2?.type);
    if (parameterCache.has(parameterCacheKey))
      return parameterCache.get(parameterCacheKey);
    const isTuple = isTupleRegex.test(param);
    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
      throw new SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = options2?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i = 0; i < length; i++) {
        components_.push(parseAbiParameter(params[i], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(options2?.type === "struct") && !isSolidityType(type))
        throw new UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
      if (!options2?.modifiers?.has?.(match.modifier))
        throw new InvalidModifierError({
          param,
          type: options2?.type,
          modifier: match.modifier
        });
      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new InvalidFunctionModifierError({
          param,
          type: options2?.type,
          modifier: match.modifier
        });
    }
    const abiParameter = {
      type: `${type}${match.array ?? ""}`,
      ...name,
      ...indexed,
      ...components
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  }
  function splitParameters(params, result = [], current = "", depth = 0) {
    const length = params.trim().length;
    for (let i = 0; i < length; i++) {
      const char = params[i];
      const tail = params.slice(i + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    if (current === "")
      return result;
    if (depth !== 0)
      throw new InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
  }
  function isSolidityType(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
  }
  function isSolidityKeyword(name) {
    return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
  }
  function isValidDataLocation(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  }
  var abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;
  var init_utils3 = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/utils.js"() {
      "use strict";
      init_regex();
      init_abiItem();
      init_abiParameter();
      init_splitParameters();
      init_cache();
      init_signatures();
      abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
      abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
      dynamicIntegerRegex = /^u?int$/;
      protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/structs.js
  function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0; i < signaturesLength; i++) {
      const signature = signatures[i];
      if (!isStructSignature(signature))
        continue;
      const match = execStructSignature(signature);
      if (!match)
        throw new InvalidSignatureError({ signature, type: "struct" });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0; k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = parseAbiParameter(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new InvalidStructSignatureError({ signature });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0; i < entriesLength; i++) {
      const [name, parameters] = entries[i];
      resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  }
  function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
      const abiParameter = abiParameters[i];
      const isTuple = isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
        if (!match?.type)
          throw new InvalidAbiTypeParameterError({ abiParameter });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new CircularReferenceError({ type });
          components.push({
            ...abiParameter,
            type: `tuple${array ?? ""}`,
            components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
          });
        } else {
          if (isSolidityType(type))
            components.push(abiParameter);
          else
            throw new UnknownTypeError({ type });
        }
      }
    }
    return components;
  }
  var typeWithoutTupleRegex;
  var init_structs = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/structs.js"() {
      "use strict";
      init_regex();
      init_abiItem();
      init_abiParameter();
      init_signature();
      init_struct();
      init_signatures();
      init_utils3();
      typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js
  function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = splitParameters(params);
      const length = parameters.length;
      for (let i = 0; i < length; i++) {
        abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));
      }
    } else {
      const structs = parseStructs(params);
      const length = params.length;
      for (let i = 0; i < length; i++) {
        const signature = params[i];
        if (isStructSignature(signature))
          continue;
        const parameters = splitParameters(signature);
        const length2 = parameters.length;
        for (let k = 0; k < length2; k++) {
          abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new InvalidAbiParametersError({ params });
    return abiParameters;
  }
  var init_parseAbiParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"() {
      "use strict";
      init_abiParameter();
      init_signatures();
      init_structs();
      init_utils3();
      init_utils3();
    }
  });

  // node_modules/abitype/dist/esm/exports/index.js
  var init_exports = __esm({
    "node_modules/abitype/dist/esm/exports/index.js"() {
      "use strict";
      init_formatAbiItem();
      init_parseAbiParameters();
    }
  });

  // node_modules/viem/_esm/utils/abi/formatAbiItem.js
  function formatAbiItem2(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
      throw new InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
  }
  function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
  }
  function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  var init_formatAbiItem2 = __esm({
    "node_modules/viem/_esm/utils/abi/formatAbiItem.js"() {
      "use strict";
      init_abi();
    }
  });

  // node_modules/viem/_esm/errors/abi.js
  var AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiItemAmbiguityError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
  var init_abi = __esm({
    "node_modules/viem/_esm/errors/abi.js"() {
      "use strict";
      init_formatAbiItem2();
      init_size();
      init_base();
      AbiDecodingDataSizeTooSmallError = class extends BaseError {
        constructor({ data, params, size: size3 }) {
          super([`Data size of ${size3} bytes is too small for given parameters.`].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size3} bytes)`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingDataSizeTooSmallError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
          this.params = params;
          this.size = size3;
        }
      };
      AbiDecodingZeroDataError = class extends BaseError {
        constructor() {
          super('Cannot decode zero data ("0x") with ABI parameters.');
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingZeroDataError"
          });
        }
      };
      AbiEncodingArrayLengthMismatchError = class extends BaseError {
        constructor({ expectedLength, givenLength, type }) {
          super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingArrayLengthMismatchError"
          });
        }
      };
      AbiEncodingBytesSizeMismatchError = class extends BaseError {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingBytesSizeMismatchError"
          });
        }
      };
      AbiEncodingLengthMismatchError = class extends BaseError {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding params/values length mismatch.",
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingLengthMismatchError"
          });
        }
      };
      AbiEventSignatureEmptyTopicsError = class extends BaseError {
        constructor({ docsPath: docsPath3 }) {
          super("Cannot extract event signature from empty topics.", {
            docsPath: docsPath3
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureEmptyTopicsError"
          });
        }
      };
      AbiEventSignatureNotFoundError = class extends BaseError {
        constructor(signature, { docsPath: docsPath3 }) {
          super([
            `Encoded event signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath3
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureNotFoundError"
          });
        }
      };
      AbiEventNotFoundError = class extends BaseError {
        constructor(eventName, { docsPath: docsPath3 } = {}) {
          super([
            `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it."
          ].join("\n"), {
            docsPath: docsPath3
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventNotFoundError"
          });
        }
      };
      AbiItemAmbiguityError = class extends BaseError {
        constructor(x, y) {
          super("Found ambiguous types in overloaded ABI items.", {
            metaMessages: [
              `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
              `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
              "",
              "These types encode differently and cannot be distinguished at runtime.",
              "Remove one of the ambiguous items in the ABI."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiItemAmbiguityError"
          });
        }
      };
      DecodeLogDataMismatch = class extends BaseError {
        constructor({ abiItem, data, params, size: size3 }) {
          super([
            `Data size of ${size3} bytes is too small for non-indexed event parameters.`
          ].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size3} bytes)`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogDataMismatch"
          });
          Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abiItem = abiItem;
          this.data = data;
          this.params = params;
          this.size = size3;
        }
      };
      DecodeLogTopicsMismatch = class extends BaseError {
        constructor({ abiItem, param }) {
          super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogTopicsMismatch"
          });
          Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abiItem = abiItem;
        }
      };
      InvalidAbiEncodingTypeError = class extends BaseError {
        constructor(type, { docsPath: docsPath3 }) {
          super([
            `Type "${type}" is not a valid encoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath3 });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiEncodingType"
          });
        }
      };
      InvalidAbiDecodingTypeError = class extends BaseError {
        constructor(type, { docsPath: docsPath3 }) {
          super([
            `Type "${type}" is not a valid decoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath3 });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiDecodingType"
          });
        }
      };
      InvalidArrayError = class extends BaseError {
        constructor(value) {
          super([`Value "${value}" is not a valid array.`].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidArrayError"
          });
        }
      };
      InvalidDefinitionTypeError = class extends BaseError {
        constructor(type) {
          super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidDefinitionTypeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/hash/hashSignature.js
  function hashSignature(sig) {
    return hash(sig);
  }
  var hash;
  var init_hashSignature = __esm({
    "node_modules/viem/_esm/utils/hash/hashSignature.js"() {
      "use strict";
      init_toBytes();
      init_keccak256();
      hash = (value) => keccak256(toBytes(value));
    }
  });

  // node_modules/viem/_esm/utils/hash/normalizeSignature.js
  function normalizeSignature(signature) {
    let active = true;
    let current = "";
    let level = 0;
    let result = "";
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
      const char = signature[i];
      if (["(", ")", ","].includes(char))
        active = true;
      if (char === "(")
        level++;
      if (char === ")")
        level--;
      if (!active)
        continue;
      if (level === 0) {
        if (char === " " && ["event", "function", ""].includes(result))
          result = "";
        else {
          result += char;
          if (char === ")") {
            valid = true;
            break;
          }
        }
        continue;
      }
      if (char === " ") {
        if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
          current = "";
          active = false;
        }
        continue;
      }
      result += char;
      current += char;
    }
    if (!valid)
      throw new BaseError("Unable to normalize signature.");
    return result;
  }
  var init_normalizeSignature = __esm({
    "node_modules/viem/_esm/utils/hash/normalizeSignature.js"() {
      "use strict";
      init_base();
    }
  });

  // node_modules/viem/_esm/utils/hash/toSignature.js
  var toSignature;
  var init_toSignature = __esm({
    "node_modules/viem/_esm/utils/hash/toSignature.js"() {
      "use strict";
      init_exports();
      init_normalizeSignature();
      toSignature = (def) => {
        const def_ = (() => {
          if (typeof def === "string")
            return def;
          return formatAbiItem(def);
        })();
        return normalizeSignature(def_);
      };
    }
  });

  // node_modules/viem/_esm/utils/hash/toSignatureHash.js
  function toSignatureHash(fn) {
    return hashSignature(toSignature(fn));
  }
  var init_toSignatureHash = __esm({
    "node_modules/viem/_esm/utils/hash/toSignatureHash.js"() {
      "use strict";
      init_hashSignature();
      init_toSignature();
    }
  });

  // node_modules/viem/_esm/utils/hash/toEventSelector.js
  var toEventSelector;
  var init_toEventSelector = __esm({
    "node_modules/viem/_esm/utils/hash/toEventSelector.js"() {
      "use strict";
      init_toSignatureHash();
      toEventSelector = toSignatureHash;
    }
  });

  // node_modules/viem/_esm/utils/data/slice.js
  function slice(value, start, end, { strict } = {}) {
    if (isHex(value, { strict: false }))
      return sliceHex(value, start, end, {
        strict
      });
    return sliceBytes(value, start, end, {
      strict
    });
  }
  function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  }
  function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  }
  function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  var init_slice = __esm({
    "node_modules/viem/_esm/utils/data/slice.js"() {
      "use strict";
      init_data();
      init_isHex();
      init_size();
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
  function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
      throw new AbiEncodingLengthMismatchError({
        expectedLength: params.length,
        givenLength: values.length
      });
    const preparedParams = prepareParams({
      params,
      values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function prepareParams({ params, values }) {
    const preparedParams = [];
    for (let i = 0; i < params.length; i++) {
      preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
    }
    return preparedParams;
  }
  function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress(value);
    }
    if (param.type === "bool") {
      return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed = param.type.startsWith("int");
      return encodeNumber(value, { signed });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes(value, { param });
    }
    if (param.type === "string") {
      return encodeString(value);
    }
    throw new InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  }
  function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic) {
        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += size(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return concat([...staticParams, ...dynamicParams]);
  }
  function encodeAddress(value) {
    if (!isAddress(value))
      throw new InvalidAddressError({ address: value });
    return { dynamic: false, encoded: padHex(value.toLowerCase()) };
  }
  function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new AbiEncodingArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0; i < value.length; i++) {
      const preparedParam = prepareParam({ param, value: value[i] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encodeParams(preparedParams);
      if (dynamic) {
        const length2 = numberToHex(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes(value, { param }) {
    const [, paramSize] = param.type.split("bytes");
    const bytesSize = size(value);
    if (!paramSize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padHex(value_, {
          dir: "right",
          size: Math.ceil((value.length - 2) / 2 / 32) * 32
        });
      return {
        dynamic: true,
        encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
      };
    }
    if (bytesSize !== parseInt(paramSize))
      throw new AbiEncodingBytesSizeMismatchError({
        expectedSize: parseInt(paramSize),
        value
      });
    return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
  }
  function encodeBool(value) {
    return { dynamic: false, encoded: padHex(boolToHex(value)) };
  }
  function encodeNumber(value, { signed }) {
    return {
      dynamic: false,
      encoded: numberToHex(value, {
        size: 32,
        signed
      })
    };
  }
  function encodeString(value) {
    const hexValue = stringToHex(value);
    const partsLength = Math.ceil(size(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
      parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: concat([
        padHex(numberToHex(size(hexValue), { size: 32 })),
        ...parts
      ])
    };
  }
  function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0; i < param.components.length; i++) {
      const param_ = param.components[i];
      const index2 = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParam({
        param: param_,
        value: value[index2]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? (
      // Return `null` if the array is dynamic.
      [matches[2] ? Number(matches[2]) : null, matches[1]]
    ) : void 0;
  }
  var init_encodeAbiParameters = __esm({
    "node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"() {
      "use strict";
      init_abi();
      init_address();
      init_isAddress();
      init_concat();
      init_pad();
      init_size();
      init_slice();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/hash/toFunctionSelector.js
  var toFunctionSelector;
  var init_toFunctionSelector = __esm({
    "node_modules/viem/_esm/utils/hash/toFunctionSelector.js"() {
      "use strict";
      init_slice();
      init_toSignatureHash();
      toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
    }
  });

  // node_modules/viem/_esm/utils/abi/getAbiItem.js
  function getAbiItem(parameters) {
    const { abi, args = [], name } = parameters;
    const isSelector = isHex(name, { strict: false });
    const abiItems = abi.filter((abiItem) => {
      if (isSelector) {
        if (abiItem.type === "function")
          return toFunctionSelector(abiItem) === name;
        if (abiItem.type === "event")
          return toEventSelector(abiItem) === name;
        return false;
      }
      return "name" in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
      return void 0;
    if (abiItems.length === 1)
      return abiItems[0];
    let matchedAbiItem = void 0;
    for (const abiItem of abiItems) {
      if (!("inputs" in abiItem))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem.inputs || abiItem.inputs.length === 0)
          return abiItem;
        continue;
      }
      if (!abiItem.inputs)
        continue;
      if (abiItem.inputs.length === 0)
        continue;
      if (abiItem.inputs.length !== args.length)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType(arg, abiParameter);
      });
      if (matched) {
        if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
          const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
          if (ambiguousTypes)
            throw new AbiItemAmbiguityError({
              abiItem,
              type: ambiguousTypes[0]
            }, {
              abiItem: matchedAbiItem,
              type: ambiguousTypes[1]
            });
        }
        matchedAbiItem = abiItem;
      }
    }
    if (matchedAbiItem)
      return matchedAbiItem;
    return abiItems[0];
  }
  function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return isAddress(arg, { strict: false });
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
            ...abiParameter,
            // Pop off `[]` or `[M]` from end of type
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
      const sourceParameter = sourceParameters[parameterIndex];
      const targetParameter = targetParameters[parameterIndex];
      if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
        return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
      const types = [sourceParameter.type, targetParameter.type];
      const ambiguous = (() => {
        if (types.includes("address") && types.includes("bytes20"))
          return true;
        if (types.includes("address") && types.includes("string"))
          return isAddress(args[parameterIndex], { strict: false });
        if (types.includes("address") && types.includes("bytes"))
          return isAddress(args[parameterIndex], { strict: false });
        return false;
      })();
      if (ambiguous)
        return types;
    }
    return;
  }
  var init_getAbiItem = __esm({
    "node_modules/viem/_esm/utils/abi/getAbiItem.js"() {
      "use strict";
      init_abi();
      init_isHex();
      init_isAddress();
      init_toEventSelector();
      init_toFunctionSelector();
    }
  });

  // node_modules/viem/_esm/accounts/utils/parseAccount.js
  function parseAccount(account) {
    if (typeof account === "string")
      return { address: account, type: "json-rpc" };
    return account;
  }
  var init_parseAccount = __esm({
    "node_modules/viem/_esm/accounts/utils/parseAccount.js"() {
      "use strict";
    }
  });

  // node_modules/viem/_esm/errors/cursor.js
  var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
  var init_cursor = __esm({
    "node_modules/viem/_esm/errors/cursor.js"() {
      "use strict";
      init_base();
      NegativeOffsetError = class extends BaseError {
        constructor({ offset }) {
          super(`Offset \`${offset}\` cannot be negative.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NegativeOffsetError"
          });
        }
      };
      PositionOutOfBoundsError = class extends BaseError {
        constructor({ length, position }) {
          super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "PositionOutOfBoundsError"
          });
        }
      };
      RecursiveReadLimitExceededError = class extends BaseError {
        constructor({ count, limit }) {
          super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RecursiveReadLimitExceededError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/cursor.js
  function createCursor(bytes2, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes2;
    cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    cursor.positionReadCount = /* @__PURE__ */ new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
  }
  var staticCursor;
  var init_cursor2 = __esm({
    "node_modules/viem/_esm/utils/cursor.js"() {
      "use strict";
      init_cursor();
      staticCursor = {
        bytes: new Uint8Array(),
        dataView: new DataView(new ArrayBuffer(0)),
        position: 0,
        positionReadCount: /* @__PURE__ */ new Map(),
        recursiveReadCount: 0,
        recursiveReadLimit: Infinity,
        assertReadLimit() {
          if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new RecursiveReadLimitExceededError({
              count: this.recursiveReadCount + 1,
              limit: this.recursiveReadLimit
            });
        },
        assertPosition(position) {
          if (position < 0 || position > this.bytes.length - 1)
            throw new PositionOutOfBoundsError({
              length: this.bytes.length,
              position
            });
        },
        decrementPosition(offset) {
          if (offset < 0)
            throw new NegativeOffsetError({ offset });
          const position = this.position - offset;
          this.assertPosition(position);
          this.position = position;
        },
        getReadCount(position) {
          return this.positionReadCount.get(position || this.position) || 0;
        },
        incrementPosition(offset) {
          if (offset < 0)
            throw new NegativeOffsetError({ offset });
          const position = this.position + offset;
          this.assertPosition(position);
          this.position = position;
        },
        inspectByte(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position);
          return this.bytes[position];
        },
        inspectBytes(length, position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + length - 1);
          return this.bytes.subarray(position, position + length);
        },
        inspectUint8(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position);
          return this.bytes[position];
        },
        inspectUint16(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 1);
          return this.dataView.getUint16(position);
        },
        inspectUint24(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 2);
          return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
        },
        inspectUint32(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 3);
          return this.dataView.getUint32(position);
        },
        pushByte(byte) {
          this.assertPosition(this.position);
          this.bytes[this.position] = byte;
          this.position++;
        },
        pushBytes(bytes2) {
          this.assertPosition(this.position + bytes2.length - 1);
          this.bytes.set(bytes2, this.position);
          this.position += bytes2.length;
        },
        pushUint8(value) {
          this.assertPosition(this.position);
          this.bytes[this.position] = value;
          this.position++;
        },
        pushUint16(value) {
          this.assertPosition(this.position + 1);
          this.dataView.setUint16(this.position, value);
          this.position += 2;
        },
        pushUint24(value) {
          this.assertPosition(this.position + 2);
          this.dataView.setUint16(this.position, value >> 8);
          this.dataView.setUint8(this.position + 2, value & ~4294967040);
          this.position += 3;
        },
        pushUint32(value) {
          this.assertPosition(this.position + 3);
          this.dataView.setUint32(this.position, value);
          this.position += 4;
        },
        readByte() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectByte();
          this.position++;
          return value;
        },
        readBytes(length, size3) {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectBytes(length);
          this.position += size3 ?? length;
          return value;
        },
        readUint8() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint8();
          this.position += 1;
          return value;
        },
        readUint16() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint16();
          this.position += 2;
          return value;
        },
        readUint24() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint24();
          this.position += 3;
          return value;
        },
        readUint32() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint32();
          this.position += 4;
          return value;
        },
        setPosition(position) {
          const oldPosition = this.position;
          this.assertPosition(position);
          this.position = position;
          return () => this.position = oldPosition;
        },
        _touch() {
          if (this.recursiveReadLimit === Infinity)
            return;
          const count = this.getReadCount();
          this.positionReadCount.set(this.position, count + 1);
          if (count > 0)
            this.recursiveReadCount++;
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromBytes.js
  function bytesToBigInt(bytes2, opts = {}) {
    if (typeof opts.size !== "undefined")
      assertSize(bytes2, { size: opts.size });
    const hex = bytesToHex(bytes2, opts);
    return hexToBigInt(hex, opts);
  }
  function bytesToBool(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2);
    }
    if (bytes2.length > 1 || bytes2[0] > 1)
      throw new InvalidBytesBooleanError(bytes2);
    return Boolean(bytes2[0]);
  }
  function bytesToNumber(bytes2, opts = {}) {
    if (typeof opts.size !== "undefined")
      assertSize(bytes2, { size: opts.size });
    const hex = bytesToHex(bytes2, opts);
    return hexToNumber(hex, opts);
  }
  function bytesToString(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  var init_fromBytes = __esm({
    "node_modules/viem/_esm/utils/encoding/fromBytes.js"() {
      "use strict";
      init_encoding();
      init_trim();
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
  function decodeAbiParameters(params, data) {
    const bytes2 = typeof data === "string" ? hexToBytes(data) : data;
    const cursor = createCursor(bytes2);
    if (size(bytes2) === 0 && params.length > 0)
      throw new AbiDecodingZeroDataError();
    if (size(data) && size(data) < 32)
      throw new AbiDecodingDataSizeTooSmallError({
        data: typeof data === "string" ? data : bytesToHex(data),
        params,
        size: size(data)
      });
    let consumed = 0;
    const values = [];
    for (let i = 0; i < params.length; ++i) {
      const param = params[i];
      cursor.setPosition(consumed);
      const [data2, consumed_] = decodeParameter(cursor, param, {
        staticPosition: 0
      });
      consumed += consumed_;
      values.push(data2);
    }
    return values;
  }
  function decodeParameter(cursor, param, { staticPosition }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray(cursor, { ...param, type }, { length, staticPosition });
    }
    if (param.type === "tuple")
      return decodeTuple(cursor, param, { staticPosition });
    if (param.type === "address")
      return decodeAddress(cursor);
    if (param.type === "bool")
      return decodeBool(cursor);
    if (param.type.startsWith("bytes"))
      return decodeBytes(cursor, param, { staticPosition });
    if (param.type.startsWith("uint") || param.type.startsWith("int"))
      return decodeNumber(cursor, param);
    if (param.type === "string")
      return decodeString(cursor, { staticPosition });
    throw new InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  }
  function decodeAddress(cursor) {
    const value = cursor.readBytes(32);
    return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];
  }
  function decodeArray(cursor, param, { length, staticPosition }) {
    if (!length) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const startOfData = start + sizeOfLength;
      cursor.setPosition(start);
      const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
      const dynamicChild = hasDynamicChild(param);
      let consumed2 = 0;
      const value2 = [];
      for (let i = 0; i < length2; ++i) {
        cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
        const [data, consumed_] = decodeParameter(cursor, param, {
          staticPosition: startOfData
        });
        consumed2 += consumed_;
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    if (hasDynamicChild(param)) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const value2 = [];
      for (let i = 0; i < length; ++i) {
        cursor.setPosition(start + i * 32);
        const [data] = decodeParameter(cursor, param, {
          staticPosition: start
        });
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: staticPosition + consumed
      });
      consumed += consumed_;
      value.push(data);
    }
    return [value, consumed];
  }
  function decodeBool(cursor) {
    return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
  }
  function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size3] = param.type.split("bytes");
    if (!size3) {
      const offset = bytesToNumber(cursor.readBytes(32));
      cursor.setPosition(staticPosition + offset);
      const length = bytesToNumber(cursor.readBytes(32));
      if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ["0x", 32];
      }
      const data = cursor.readBytes(length);
      cursor.setPosition(staticPosition + 32);
      return [bytesToHex(data), 32];
    }
    const value = bytesToHex(cursor.readBytes(parseInt(size3), 32));
    return [value, 32];
  }
  function decodeNumber(cursor, param) {
    const signed = param.type.startsWith("int");
    const size3 = parseInt(param.type.split("int")[1] || "256");
    const value = cursor.readBytes(32);
    return [
      size3 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),
      32
    ];
  }
  function decodeTuple(cursor, param, { staticPosition }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        cursor.setPosition(start + consumed);
        const [data, consumed_] = decodeParameter(cursor, component, {
          staticPosition: start
        });
        consumed += consumed_;
        value[hasUnnamedChild ? i : component?.name] = data;
      }
      cursor.setPosition(staticPosition + 32);
      return [value, 32];
    }
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition
      });
      value[hasUnnamedChild ? i : component?.name] = data;
      consumed += consumed_;
    }
    return [value, consumed];
  }
  function decodeString(cursor, { staticPosition }) {
    const offset = bytesToNumber(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["", 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = bytesToString(trim(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  }
  var sizeOfLength, sizeOfOffset;
  var init_decodeAbiParameters = __esm({
    "node_modules/viem/_esm/utils/abi/decodeAbiParameters.js"() {
      "use strict";
      init_abi();
      init_getAddress();
      init_cursor2();
      init_size();
      init_slice();
      init_trim();
      init_fromBytes();
      init_toBytes();
      init_toHex();
      init_encodeAbiParameters();
      sizeOfLength = 32;
      sizeOfOffset = 32;
    }
  });

  // node_modules/viem/_esm/utils/stringify.js
  var stringify;
  var init_stringify = __esm({
    "node_modules/viem/_esm/utils/stringify.js"() {
      "use strict";
      stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
        const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key, value2) : value2;
      }, space);
    }
  });

  // node_modules/viem/_esm/constants/unit.js
  var gweiUnits;
  var init_unit = __esm({
    "node_modules/viem/_esm/constants/unit.js"() {
      "use strict";
      gweiUnits = {
        ether: -9,
        wei: 9
      };
    }
  });

  // node_modules/viem/_esm/utils/unit/formatUnits.js
  function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative)
      display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
      display.slice(0, display.length - decimals),
      display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
  }
  var init_formatUnits = __esm({
    "node_modules/viem/_esm/utils/unit/formatUnits.js"() {
      "use strict";
    }
  });

  // node_modules/viem/_esm/utils/unit/formatGwei.js
  function formatGwei(wei, unit = "wei") {
    return formatUnits(wei, gweiUnits[unit]);
  }
  var init_formatGwei = __esm({
    "node_modules/viem/_esm/utils/unit/formatGwei.js"() {
      "use strict";
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/_esm/errors/transaction.js
  function prettyPrint(args) {
    const entries = Object.entries(args).map(([key, value]) => {
      if (value === void 0 || value === false)
        return null;
      return [key, value];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
  }
  var InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError;
  var init_transaction = __esm({
    "node_modules/viem/_esm/errors/transaction.js"() {
      "use strict";
      init_base();
      InvalidLegacyVError = class extends BaseError {
        constructor({ v }) {
          super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidLegacyVError"
          });
        }
      };
      InvalidSerializableTransactionError = class extends BaseError {
        constructor({ transaction }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              prettyPrint(transaction),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- a Legacy Transaction with `gasPrice`"
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSerializableTransactionError"
          });
        }
      };
      InvalidStorageKeySizeError = class extends BaseError {
        constructor({ storageKey }) {
          super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidStorageKeySizeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/request.js
  var HttpRequestError, RpcRequestError, TimeoutError;
  var init_request = __esm({
    "node_modules/viem/_esm/errors/request.js"() {
      "use strict";
      init_stringify();
      init_base();
      init_utils();
      HttpRequestError = class extends BaseError {
        constructor({ body, details, headers, status, url }) {
          super("HTTP request failed.", {
            details,
            metaMessages: [
              status && `Status: ${status}`,
              `URL: ${getUrl(url)}`,
              body && `Request body: ${stringify(body)}`
            ].filter(Boolean)
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "HttpRequestError"
          });
          Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.body = body;
          this.headers = headers;
          this.status = status;
          this.url = url;
        }
      };
      RpcRequestError = class extends BaseError {
        constructor({ body, error, url }) {
          super("RPC Request failed.", {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcRequestError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.code = error.code;
        }
      };
      TimeoutError = class extends BaseError {
        constructor({ body, url }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/rpc.js
  var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnknownRpcError;
  var init_rpc = __esm({
    "node_modules/viem/_esm/errors/rpc.js"() {
      "use strict";
      init_base();
      init_request();
      unknownErrorCode = -1;
      RpcError = class extends BaseError {
        constructor(cause, { code, docsPath: docsPath3, metaMessages, shortMessage }) {
          super(shortMessage, {
            cause,
            docsPath: docsPath3,
            metaMessages: metaMessages || cause?.metaMessages
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.name = cause.name;
          this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
        }
      };
      ProviderRpcError = class extends RpcError {
        constructor(cause, options2) {
          super(cause, options2);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderRpcError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = options2.data;
        }
      };
      ParseRpcError = class _ParseRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ParseRpcError.code,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ParseRpcError"
          });
        }
      };
      Object.defineProperty(ParseRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32700
      });
      InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidRequestRpcError.code,
            shortMessage: "JSON is not a valid request object."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidRequestRpcError"
          });
        }
      };
      Object.defineProperty(InvalidRequestRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32600
      });
      MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _MethodNotFoundRpcError.code,
            shortMessage: "The method does not exist / is not available."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotFoundRpcError"
          });
        }
      };
      Object.defineProperty(MethodNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32601
      });
      InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidParamsRpcError.code,
            shortMessage: [
              "Invalid parameters were provided to the RPC method.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParamsRpcError"
          });
        }
      };
      Object.defineProperty(InvalidParamsRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32602
      });
      InternalRpcError = class _InternalRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InternalRpcError.code,
            shortMessage: "An internal error was received."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InternalRpcError"
          });
        }
      };
      Object.defineProperty(InternalRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32603
      });
      InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidInputRpcError.code,
            shortMessage: [
              "Missing or invalid parameters.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidInputRpcError"
          });
        }
      };
      Object.defineProperty(InvalidInputRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32e3
      });
      ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ResourceNotFoundRpcError.code,
            shortMessage: "Requested resource not found."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceNotFoundRpcError"
          });
        }
      };
      Object.defineProperty(ResourceNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32001
      });
      ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ResourceUnavailableRpcError.code,
            shortMessage: "Requested resource not available."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceUnavailableRpcError"
          });
        }
      };
      Object.defineProperty(ResourceUnavailableRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32002
      });
      TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _TransactionRejectedRpcError.code,
            shortMessage: "Transaction creation failed."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionRejectedRpcError"
          });
        }
      };
      Object.defineProperty(TransactionRejectedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32003
      });
      MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _MethodNotSupportedRpcError.code,
            shortMessage: "Method is not implemented."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotSupportedRpcError"
          });
        }
      };
      Object.defineProperty(MethodNotSupportedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32004
      });
      LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _LimitExceededRpcError.code,
            shortMessage: "Request exceeds defined limit."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "LimitExceededRpcError"
          });
        }
      };
      Object.defineProperty(LimitExceededRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32005
      });
      JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _JsonRpcVersionUnsupportedError.code,
            shortMessage: "Version of JSON-RPC protocol is not supported."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "JsonRpcVersionUnsupportedError"
          });
        }
      };
      Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32006
      });
      UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UserRejectedRequestError.code,
            shortMessage: "User rejected the request."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UserRejectedRequestError"
          });
        }
      };
      Object.defineProperty(UserRejectedRequestError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4001
      });
      UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnauthorizedProviderError.code,
            shortMessage: "The requested method and/or account has not been authorized by the user."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnauthorizedProviderError"
          });
        }
      };
      Object.defineProperty(UnauthorizedProviderError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4100
      });
      UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnsupportedProviderMethodError.code,
            shortMessage: "The Provider does not support the requested method."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnsupportedProviderMethodError"
          });
        }
      };
      Object.defineProperty(UnsupportedProviderMethodError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4200
      });
      ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _ProviderDisconnectedError.code,
            shortMessage: "The Provider is disconnected from all chains."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderDisconnectedError"
          });
        }
      };
      Object.defineProperty(ProviderDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4900
      });
      ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _ChainDisconnectedError.code,
            shortMessage: "The Provider is not connected to the requested chain."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDisconnectedError"
          });
        }
      };
      Object.defineProperty(ChainDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4901
      });
      SwitchChainError = class _SwitchChainError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _SwitchChainError.code,
            shortMessage: "An error occurred when attempting to switch chain."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SwitchChainError"
          });
        }
      };
      Object.defineProperty(SwitchChainError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4902
      });
      UnknownRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            shortMessage: "An unknown RPC error occurred."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownRpcError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/node.js
  var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError;
  var init_node = __esm({
    "node_modules/viem/_esm/errors/node.js"() {
      "use strict";
      init_formatGwei();
      init_base();
      ExecutionRevertedError = class extends BaseError {
        constructor({ cause, message } = {}) {
          const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
          super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ExecutionRevertedError"
          });
        }
      };
      Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
      });
      FeeCapTooHighError = class extends BaseError {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooHigh"
          });
        }
      };
      Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
      });
      FeeCapTooLowError = class extends BaseError {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooLow"
          });
        }
      };
      Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
      });
      NonceTooHighError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooHighError"
          });
        }
      };
      Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
      });
      NonceTooLowError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
            "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
          ].join("\n"), { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooLowError"
          });
        }
      };
      Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported|already known/
      });
      NonceMaxValueError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceMaxValueError"
          });
        }
      };
      Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
      });
      InsufficientFundsError = class extends BaseError {
        constructor({ cause } = {}) {
          super([
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
          ].join("\n"), {
            cause,
            metaMessages: [
              "This error could arise when the account does not have enough funds to:",
              " - pay for the total gas fee,",
              " - pay for the value to send.",
              " ",
              "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
              " - `gas` is the amount of gas needed for transaction to execute,",
              " - `gas fee` is the gas fee,",
              " - `value` is the amount of ether to send to the recipient."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InsufficientFundsError"
          });
        }
      };
      Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds/
      });
      IntrinsicGasTooHighError = class extends BaseError {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooHighError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
      });
      IntrinsicGasTooLowError = class extends BaseError {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooLowError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
      });
      TransactionTypeNotSupportedError = class extends BaseError {
        constructor({ cause }) {
          super("The transaction type is not supported for this chain.", {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionTypeNotSupportedError"
          });
        }
      };
      Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
      });
      TipAboveFeeCapError = class extends BaseError {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
          super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
          ].join("\n"), {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TipAboveFeeCapError"
          });
        }
      };
      Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
      });
    }
  });

  // node_modules/viem/_esm/utils/formatters/transactionRequest.js
  function formatTransactionRequest(transactionRequest) {
    return {
      ...transactionRequest,
      gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : void 0,
      gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : void 0,
      maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : void 0,
      nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : void 0,
      type: typeof transactionRequest.type !== "undefined" ? rpcTransactionType[transactionRequest.type] : void 0,
      value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : void 0
    };
  }
  var rpcTransactionType, defineTransactionRequest;
  var init_transactionRequest = __esm({
    "node_modules/viem/_esm/utils/formatters/transactionRequest.js"() {
      "use strict";
      init_toHex();
      init_formatter();
      rpcTransactionType = {
        legacy: "0x0",
        eip2930: "0x1",
        eip1559: "0x2",
        eip4844: "0x3"
      };
      defineTransactionRequest = /* @__PURE__ */ defineFormatter("transactionRequest", formatTransactionRequest);
    }
  });

  // node_modules/viem/_esm/errors/chain.js
  var InvalidChainIdError;
  var init_chain = __esm({
    "node_modules/viem/_esm/errors/chain.js"() {
      "use strict";
      init_base();
      InvalidChainIdError = class extends BaseError {
        constructor({ chainId }) {
          super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidChainIdError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/promise/createBatchScheduler.js
  function createBatchScheduler({ fn, id, shouldSplitBatch, wait: wait2 = 0, sort }) {
    const exec = async () => {
      const scheduler = getScheduler();
      flush();
      const args = scheduler.map(({ args: args2 }) => args2);
      if (args.length === 0)
        return;
      fn(args).then((data) => {
        if (sort && Array.isArray(data))
          data.sort(sort);
        for (let i = 0; i < scheduler.length; i++) {
          const { pendingPromise } = scheduler[i];
          pendingPromise.resolve?.([data[i], data]);
        }
      }).catch((err) => {
        for (let i = 0; i < scheduler.length; i++) {
          const { pendingPromise } = scheduler[i];
          pendingPromise.reject?.(err);
        }
      });
    };
    const flush = () => schedulerCache.delete(id);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id) || [];
    const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
    return {
      flush,
      async schedule(args) {
        const pendingPromise = {};
        const promise = new Promise((resolve, reject) => {
          pendingPromise.resolve = resolve;
          pendingPromise.reject = reject;
        });
        const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
        if (split2)
          exec();
        const hasActiveScheduler = getScheduler().length > 0;
        if (hasActiveScheduler) {
          setScheduler({ args, pendingPromise });
          return promise;
        }
        setScheduler({ args, pendingPromise });
        setTimeout(exec, wait2);
        return promise;
      }
    };
  }
  var schedulerCache;
  var init_createBatchScheduler = __esm({
    "node_modules/viem/_esm/utils/promise/createBatchScheduler.js"() {
      "use strict";
      schedulerCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/@supercharge/promise-pool/dist/promise-pool-error.js
  var require_promise_pool_error = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/promise-pool-error.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PromisePoolError = void 0;
      var PromisePoolError = class extends Error {
        /**
         * Create a new instance for the given `message` and `item`.
         *
         * @param error  The original error
         * @param item   The item causing the error
         */
        constructor(error, item) {
          super();
          this.raw = error;
          this.item = item;
          this.name = this.constructor.name;
          this.message = this.messageFrom(error);
          if (Error.captureStackTrace && typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        /**
         * Returns a new promise pool error instance wrapping the `error` and `item`.
         *
         * @param {*} error
         * @param {*} item
         *
         * @returns {PromisePoolError}
         */
        static createFrom(error, item) {
          return new this(error, item);
        }
        /**
         * Returns the error message from the given `error`.
         *
         * @param {*} error
         *
         * @returns {String}
         */
        messageFrom(error) {
          if (error instanceof Error) {
            return error.message;
          }
          if (typeof error === "object") {
            return error.message;
          }
          if (typeof error === "string" || typeof error === "number") {
            return error.toString();
          }
          return "";
        }
      };
      exports2.PromisePoolError = PromisePoolError;
    }
  });

  // node_modules/@supercharge/promise-pool/dist/stop-the-promise-pool-error.js
  var require_stop_the_promise_pool_error = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/stop-the-promise-pool-error.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.StopThePromisePoolError = void 0;
      var StopThePromisePoolError = class extends Error {
      };
      exports2.StopThePromisePoolError = StopThePromisePoolError;
    }
  });

  // node_modules/@supercharge/promise-pool/dist/validation-error.js
  var require_validation_error = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/validation-error.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ValidationError = void 0;
      var ValidationError = class extends Error {
        /**
         * Create a new instance for the given `message`.
         *
         * @param message  The error message
         */
        constructor(message) {
          super(message);
          if (Error.captureStackTrace && typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        /**
         * Returns a validation error with the given `message`.
         */
        static createFrom(message) {
          return new this(message);
        }
      };
      exports2.ValidationError = ValidationError;
    }
  });

  // node_modules/@supercharge/promise-pool/dist/promise-pool-executor.js
  var require_promise_pool_executor = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/promise-pool-executor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PromisePoolExecutor = void 0;
      var promise_pool_1 = require_promise_pool();
      var promise_pool_error_1 = require_promise_pool_error();
      var stop_the_promise_pool_error_1 = require_stop_the_promise_pool_error();
      var validation_error_1 = require_validation_error();
      var PromisePoolExecutor = class {
        /**
         * Creates a new promise pool executer instance with a default concurrency of 10.
         */
        constructor() {
          this.meta = {
            tasks: [],
            items: [],
            errors: [],
            results: [],
            stopped: false,
            concurrency: 10,
            shouldResultsCorrespond: false,
            processedItems: [],
            taskTimeout: 0
          };
          this.handler = () => {
          };
          this.errorHandler = void 0;
          this.onTaskStartedHandlers = [];
          this.onTaskFinishedHandlers = [];
        }
        /**
         * Set the number of tasks to process concurrently the promise pool.
         *
         * @param {Integer} concurrency
         *
         * @returns {PromisePoolExecutor}
         */
        useConcurrency(concurrency) {
          if (!this.isValidConcurrency(concurrency)) {
            throw validation_error_1.ValidationError.createFrom(`"concurrency" must be a number, 1 or up. Received "${concurrency}" (${typeof concurrency})`);
          }
          this.meta.concurrency = concurrency;
          return this;
        }
        /**
         * Determine whether the given `concurrency` value is valid.
         *
         * @param {Number} concurrency
         *
         * @returns {Boolean}
         */
        isValidConcurrency(concurrency) {
          return typeof concurrency === "number" && concurrency >= 1;
        }
        /**
         * Set the timeout in ms for the pool handler
         *
         * @param {Number} timeout
         *
         * @returns {PromisePool}
         */
        withTaskTimeout(timeout) {
          this.meta.taskTimeout = timeout;
          return this;
        }
        /**
         * Returns the number of concurrently processed tasks.
         *
         * @returns {Number}
         */
        concurrency() {
          return this.meta.concurrency;
        }
        /**
         * Assign whether to keep corresponding results between source items and resulting tasks.
         */
        useCorrespondingResults(shouldResultsCorrespond) {
          this.meta.shouldResultsCorrespond = shouldResultsCorrespond;
          return this;
        }
        /**
         * Determine whether to keep corresponding results between source items and resulting tasks.
         */
        shouldUseCorrespondingResults() {
          return this.meta.shouldResultsCorrespond;
        }
        /**
         * Returns the task timeout in milliseconds.
         */
        taskTimeout() {
          return this.meta.taskTimeout;
        }
        /**
         * Set the items to be processed in the promise pool.
         *
         * @param {Array} items
         *
         * @returns {PromisePoolExecutor}
         */
        for(items) {
          this.meta.items = items;
          return this;
        }
        /**
         * Returns the list of items to process.
         *
         * @returns {T[] | Iterable<T> | AsyncIterable<T>}
         */
        items() {
          return this.meta.items;
        }
        /**
         * Returns the number of items to process, or `NaN` if items are not an array.
         *
         * @returns {Number}
         */
        itemsCount() {
          const items = this.items();
          return Array.isArray(items) ? items.length : NaN;
        }
        /**
         * Returns the list of active tasks.
         *
         * @returns {Array}
         */
        tasks() {
          return this.meta.tasks;
        }
        /**
         * Returns the number of currently active tasks.
         *
         * @returns {Number}
         *
         * @deprecated use the `activeTasksCount()` method (plural naming) instead
         */
        activeTaskCount() {
          return this.activeTasksCount();
        }
        /**
         * Returns the number of currently active tasks.
         *
         * @returns {Number}
         */
        activeTasksCount() {
          return this.tasks().length;
        }
        /**
         * Returns the list of processed items.
         *
         * @returns {T[]}
         */
        processedItems() {
          return this.meta.processedItems;
        }
        /**
         * Returns the number of processed items.
         *
         * @returns {Number}
         */
        processedCount() {
          return this.processedItems().length;
        }
        /**
         * Returns the percentage progress of items that have been processed, or `NaN` if items is not an array.
         */
        processedPercentage() {
          return this.processedCount() / this.itemsCount() * 100;
        }
        /**
         * Returns the list of results.
         *
         * @returns {R[]}
         */
        results() {
          return this.meta.results;
        }
        /**
         * Returns the list of errors.
         *
         * @returns {Array<PromisePoolError<T>>}
         */
        errors() {
          return this.meta.errors;
        }
        /**
         * Set the handler that is applied to each item.
         *
         * @param {Function} action
         *
         * @returns {PromisePoolExecutor}
         */
        withHandler(action) {
          this.handler = action;
          return this;
        }
        /**
         * Determine whether a custom error handle is available.
         *
         * @returns {Boolean}
         */
        hasErrorHandler() {
          return !!this.errorHandler;
        }
        /**
         * Set the error handler function to execute when an error occurs.
         *
         * @param {Function} errorHandler
         *
         * @returns {PromisePoolExecutor}
         */
        handleError(handler) {
          this.errorHandler = handler;
          return this;
        }
        /**
         * Set the handler function to execute when started a task.
         *
         * @param {Function} handler
         *
         * @returns {this}
         */
        onTaskStarted(handlers) {
          this.onTaskStartedHandlers = handlers;
          return this;
        }
        /**
          * Assign the given callback `handler` function to run when a task finished.
         *
         * @param {OnProgressCallback<T>} handlers
         *
         * @returns {this}
         */
        onTaskFinished(handlers) {
          this.onTaskFinishedHandlers = handlers;
          return this;
        }
        /**
         * Determines whether the number of active tasks is greater or equal to the concurrency limit.
         *
         * @returns {Boolean}
         */
        hasReachedConcurrencyLimit() {
          return this.activeTasksCount() >= this.concurrency();
        }
        /**
         * Stop a promise pool processing.
         */
        stop() {
          this.markAsStopped();
          throw new stop_the_promise_pool_error_1.StopThePromisePoolError();
        }
        /**
         * Mark the promise pool as stopped.
         *
         * @returns {PromisePoolExecutor}
         */
        markAsStopped() {
          this.meta.stopped = true;
          return this;
        }
        /**
         * Determine whether the pool is stopped.
         *
         * @returns {Boolean}
         */
        isStopped() {
          return this.meta.stopped;
        }
        /**
         * Start processing the promise pool.
         *
         * @returns {ReturnValue}
         */
        async start() {
          return await this.validateInputs().prepareResultsArray().process();
        }
        /**
         * Determine whether the pool should stop.
         *
         * @returns {PromisePoolExecutor}
         *
         * @throws
         */
        validateInputs() {
          if (typeof this.handler !== "function") {
            throw validation_error_1.ValidationError.createFrom("The first parameter for the .process(fn) method must be a function");
          }
          const timeout = this.taskTimeout();
          if (!(timeout == null || typeof timeout === "number" && timeout >= 0)) {
            throw validation_error_1.ValidationError.createFrom(`"timeout" must be undefined or a number. A number must be 0 or up. Received "${String(timeout)}" (${typeof timeout})`);
          }
          if (!this.areItemsValid()) {
            throw validation_error_1.ValidationError.createFrom(`"items" must be an array, an iterable or an async iterable. Received "${typeof this.items()}"`);
          }
          if (this.errorHandler && typeof this.errorHandler !== "function") {
            throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received "${typeof this.errorHandler}"`);
          }
          this.onTaskStartedHandlers.forEach((handler) => {
            if (handler && typeof handler !== "function") {
              throw validation_error_1.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received "${typeof handler}"`);
            }
          });
          this.onTaskFinishedHandlers.forEach((handler) => {
            if (handler && typeof handler !== "function") {
              throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received "${typeof handler}"`);
            }
          });
          return this;
        }
        areItemsValid() {
          const items = this.items();
          if (Array.isArray(items))
            return true;
          if (typeof items[Symbol.iterator] === "function")
            return true;
          if (typeof items[Symbol.asyncIterator] === "function")
            return true;
          return false;
        }
        /**
         * Prefill the results array with `notRun` symbol values if results should correspond.
         */
        prepareResultsArray() {
          const items = this.items();
          if (!Array.isArray(items))
            return this;
          if (!this.shouldUseCorrespondingResults())
            return this;
          this.meta.results = Array(items.length).fill(promise_pool_1.PromisePool.notRun);
          return this;
        }
        /**
         * Starts processing the promise pool by iterating over the items
         * and running each item through the async `callback` function.
         *
         * @param {Function} callback
         *
         * @returns {Promise}
         */
        async process() {
          let index2 = 0;
          for await (const item of this.items()) {
            if (this.isStopped()) {
              break;
            }
            if (this.shouldUseCorrespondingResults()) {
              this.results()[index2] = promise_pool_1.PromisePool.notRun;
            }
            this.startProcessing(item, index2);
            index2 += 1;
            await this.waitForProcessingSlot();
          }
          return await this.drained();
        }
        /**
         * Wait for one of the active tasks to finish processing.
         */
        async waitForProcessingSlot() {
          while (this.hasReachedConcurrencyLimit()) {
            await this.waitForActiveTaskToFinish();
          }
        }
        /**
         * Wait for the next, currently active task to finish processing.
         */
        async waitForActiveTaskToFinish() {
          await Promise.race(this.tasks());
        }
        /**
         * Create a processing function for the given `item`.
         *
         * @param {T} item
         * @param {number} index
         */
        startProcessing(item, index2) {
          const task = this.createTaskFor(item, index2).then((result) => {
            this.save(result, index2).removeActive(task);
          }).catch(async (error) => {
            await this.handleErrorFor(error, item, index2);
            this.removeActive(task);
          }).finally(() => {
            this.processedItems().push(item);
            this.runOnTaskFinishedHandlers(item);
          });
          this.tasks().push(task);
          this.runOnTaskStartedHandlers(item);
        }
        /**
         * Ensures a returned promise for the processing of the given `item`.
         *
         * @param {T} item
         * @param {number} index
         *
         * @returns {*}
         */
        async createTaskFor(item, index2) {
          if (this.taskTimeout() === void 0) {
            return this.handler(item, index2, this);
          }
          const [timer, canceller] = this.createTaskTimeout(item);
          return Promise.race([
            this.handler(item, index2, this),
            timer()
          ]).finally(canceller);
        }
        /**
         * Returns a tuple of a timer function and a canceller function that
         * times-out after the configured task timeout.
         */
        createTaskTimeout(item) {
          let timerId;
          const timer = async () => new Promise((_resolve, reject) => {
            timerId = setTimeout(() => {
              reject(new promise_pool_error_1.PromisePoolError(`Task in promise pool timed out after ${this.taskTimeout()}ms`, item));
            }, this.taskTimeout());
          });
          const canceller = () => clearTimeout(timerId);
          return [timer, canceller];
        }
        /**
         * Save the given calculation `result`, possibly at the provided `position`.
         *
         * @param {*} result
         * @param {number} position
         *
         * @returns {PromisePoolExecutor}
         */
        save(result, position) {
          this.shouldUseCorrespondingResults() ? this.results()[position] = result : this.results().push(result);
          return this;
        }
        /**
         * Remove the given `task` from the list of active tasks.
         *
         * @param {Promise} task
         */
        removeActive(task) {
          this.tasks().splice(this.tasks().indexOf(task), 1);
          return this;
        }
        /**
         * Create and save an error for the the given `item`.
         *
         * @param {Error} error
         * @param {T} item
         * @param {number} index
         */
        async handleErrorFor(error, item, index2) {
          if (this.shouldUseCorrespondingResults()) {
            this.results()[index2] = promise_pool_1.PromisePool.failed;
          }
          if (this.isStoppingThePoolError(error)) {
            return;
          }
          if (this.isValidationError(error)) {
            this.markAsStopped();
            throw error;
          }
          this.hasErrorHandler() ? await this.runErrorHandlerFor(error, item) : this.saveErrorFor(error, item);
        }
        /**
         * Determine whether the given `error` is a `StopThePromisePoolError` instance.
         *
         * @param {Error} error
         *
         * @returns {Boolean}
         */
        isStoppingThePoolError(error) {
          return error instanceof stop_the_promise_pool_error_1.StopThePromisePoolError;
        }
        /**
         * Determine whether the given `error` is a `ValidationError` instance.
         *
         * @param {Error} error
         *
         * @returns {Boolean}
         */
        isValidationError(error) {
          return error instanceof validation_error_1.ValidationError;
        }
        /**
         * Run the users error handler, if available.
         *
         * @param {Error} processingError
         * @param {T} item
         */
        async runErrorHandlerFor(processingError, item) {
          try {
            await this.errorHandler?.(processingError, item, this);
          } catch (error) {
            this.rethrowIfNotStoppingThePool(error);
          }
        }
        /**
         * Run the onTaskStarted handlers.
         */
        runOnTaskStartedHandlers(item) {
          this.onTaskStartedHandlers.forEach((handler) => {
            handler(item, this);
          });
        }
        /**
         * Run the onTaskFinished handlers.
         */
        runOnTaskFinishedHandlers(item) {
          this.onTaskFinishedHandlers.forEach((handler) => {
            handler(item, this);
          });
        }
        /**
         * Rethrow the given `error` if its not an instance of `StopThePromisePoolError`.
         *
         * @param {Error} error
         */
        rethrowIfNotStoppingThePool(error) {
          if (this.isStoppingThePoolError(error)) {
            return;
          }
          throw error;
        }
        /**
         * Create and save an error for the the given `item`.
         *
         * @param {T} item
         */
        saveErrorFor(error, item) {
          this.errors().push(promise_pool_error_1.PromisePoolError.createFrom(error, item));
        }
        /**
         * Wait for all active tasks to finish. Once all the tasks finished
         * processing, returns an object containing the results and errors.
         *
         * @returns {Object}
         */
        async drained() {
          await this.drainActiveTasks();
          return {
            errors: this.errors(),
            results: this.results()
          };
        }
        /**
         * Wait for all of the active tasks to finish processing.
         */
        async drainActiveTasks() {
          await Promise.all(this.tasks());
        }
      };
      exports2.PromisePoolExecutor = PromisePoolExecutor;
    }
  });

  // node_modules/@supercharge/promise-pool/dist/promise-pool.js
  var require_promise_pool = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/promise-pool.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PromisePool = void 0;
      var promise_pool_executor_1 = require_promise_pool_executor();
      var PromisePool2 = class _PromisePool {
        /**
         * Instantiates a new promise pool with a default `concurrency: 10` and `items: []`.
         *
         * @param {Object} options
         */
        constructor(items) {
          this.timeout = void 0;
          this.concurrency = 10;
          this.items = items ?? [];
          this.errorHandler = void 0;
          this.onTaskStartedHandlers = [];
          this.onTaskFinishedHandlers = [];
          this.shouldResultsCorrespond = false;
        }
        /**
         * Set the number of tasks to process concurrently in the promise pool.
         *
         * @param {Integer} concurrency
         *
         * @returns {PromisePool}
         */
        withConcurrency(concurrency) {
          this.concurrency = concurrency;
          return this;
        }
        /**
         * Set the number of tasks to process concurrently in the promise pool.
         *
         * @param {Number} concurrency
         *
         * @returns {PromisePool}
         */
        static withConcurrency(concurrency) {
          return new this().withConcurrency(concurrency);
        }
        /**
         * Set the timeout in milliseconds for the pool handler.
         *
         * @param {Number} timeout
         *
         * @returns {PromisePool}
         */
        withTaskTimeout(timeout) {
          this.timeout = timeout;
          return this;
        }
        /**
         * Set the timeout in milliseconds for the pool handler.
         *
         * @param {Number} timeout
         *
         * @returns {PromisePool}
         */
        static withTaskTimeout(timeout) {
          return new this().withTaskTimeout(timeout);
        }
        /**
         * Set the items to be processed in the promise pool.
         *
         * @param {SomeIterable<ItemType>} items
         *
         * @returns {PromisePool}
         */
        for(items) {
          const pool = new _PromisePool(items).withConcurrency(this.concurrency);
          if (typeof this.errorHandler === "function") {
            pool.handleError(this.errorHandler);
          }
          return typeof this.timeout === "number" ? pool.withTaskTimeout(this.timeout) : pool;
        }
        /**
         * Set the items to be processed in the promise pool.
         *
         * @param {T[] | Iterable<T> | AsyncIterable<T>} items
         *
         * @returns {PromisePool}
         */
        static for(items) {
          return new this().for(items);
        }
        /**
         * Set the error handler function to execute when an error occurs.
         *
         * @param {ErrorHandler<T>} handler
         *
         * @returns {PromisePool}
         */
        handleError(handler) {
          this.errorHandler = handler;
          return this;
        }
        /**
         * Assign the given callback `handler` function to run when a task starts.
         *
         * @param {OnProgressCallback<T>} handler
         *
         * @returns {PromisePool}
         */
        onTaskStarted(handler) {
          this.onTaskStartedHandlers.push(handler);
          return this;
        }
        /**
         * Assign the given callback `handler` function to run when a task finished.
         *
         * @param {OnProgressCallback<T>} handler
         *
         * @returns {PromisePool}
         */
        onTaskFinished(handler) {
          this.onTaskFinishedHandlers.push(handler);
          return this;
        }
        /**
         * Assign whether to keep corresponding results between source items and resulting tasks.
         */
        useCorrespondingResults() {
          this.shouldResultsCorrespond = true;
          return this;
        }
        /**
         * Starts processing the promise pool by iterating over the items
         * and running each item through the async `callback` function.
         *
         * @param {ProcessHandler} The async processing function receiving each item from the `items` array.
         *
         * @returns Promise<{ results, errors }>
         */
        async process(callback) {
          return new promise_pool_executor_1.PromisePoolExecutor().useConcurrency(this.concurrency).useCorrespondingResults(this.shouldResultsCorrespond).withTaskTimeout(this.timeout).withHandler(callback).handleError(this.errorHandler).onTaskStarted(this.onTaskStartedHandlers).onTaskFinished(this.onTaskFinishedHandlers).for(this.items).start();
        }
      };
      exports2.PromisePool = PromisePool2;
      PromisePool2.notRun = Symbol("notRun");
      PromisePool2.failed = Symbol("failed");
    }
  });

  // node_modules/@supercharge/promise-pool/dist/contracts.js
  var require_contracts = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/contracts.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@supercharge/promise-pool/dist/return-value.js
  var require_return_value = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/return-value.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/@supercharge/promise-pool/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@supercharge/promise-pool/dist/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var promise_pool_1 = require_promise_pool();
      exports2.default = promise_pool_1.PromisePool;
      __exportStar(require_contracts(), exports2);
      __exportStar(require_promise_pool(), exports2);
      __exportStar(require_promise_pool_error(), exports2);
      __exportStar(require_return_value(), exports2);
      __exportStar(require_stop_the_promise_pool_error(), exports2);
      __exportStar(require_validation_error(), exports2);
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports2, module2) {
      "use strict";
      function base2(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode(source) {
          if (source instanceof Uint8Array) {
          } else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
          } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
          }
          if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size3 = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size3);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size3 - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size3 - length;
          while (it2 !== size3 && b58[it2] === 0) {
            it2++;
          }
          var str2 = LEADER.repeat(zeroes);
          for (; it2 < size3; ++it2) {
            str2 += ALPHABET.charAt(b58[it2]);
          }
          return str2;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return new Uint8Array();
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size3 = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size3);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size3 - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size3 - length;
          while (it4 !== size3 && b256[it4] === 0) {
            it4++;
          }
          var vch = new Uint8Array(zeroes + (size3 - it4));
          var j2 = zeroes;
          while (it4 !== size3) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode(string) {
          var buffer2 = decodeUnsafe(string);
          if (buffer2) {
            return buffer2;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      }
      module2.exports = base2;
    }
  });

  // node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bs58/index.js"(exports2, module2) {
      "use strict";
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module2.exports = basex(ALPHABET);
    }
  });

  // node_modules/kind-of/index.js
  var require_kind_of = __commonJS({
    "node_modules/kind-of/index.js"(exports2, module2) {
      "use strict";
      var toString = Object.prototype.toString;
      module2.exports = function kindOf(val) {
        if (val === void 0)
          return "undefined";
        if (val === null)
          return "null";
        var type = typeof val;
        if (type === "boolean")
          return "boolean";
        if (type === "string")
          return "string";
        if (type === "number")
          return "number";
        if (type === "symbol")
          return "symbol";
        if (type === "function") {
          return isGeneratorFn(val) ? "generatorfunction" : "function";
        }
        if (isArray(val))
          return "array";
        if (isBuffer(val))
          return "buffer";
        if (isArguments(val))
          return "arguments";
        if (isDate(val))
          return "date";
        if (isError(val))
          return "error";
        if (isRegexp(val))
          return "regexp";
        switch (ctorName(val)) {
          case "Symbol":
            return "symbol";
          case "Promise":
            return "promise";
          case "WeakMap":
            return "weakmap";
          case "WeakSet":
            return "weakset";
          case "Map":
            return "map";
          case "Set":
            return "set";
          case "Int8Array":
            return "int8array";
          case "Uint8Array":
            return "uint8array";
          case "Uint8ClampedArray":
            return "uint8clampedarray";
          case "Int16Array":
            return "int16array";
          case "Uint16Array":
            return "uint16array";
          case "Int32Array":
            return "int32array";
          case "Uint32Array":
            return "uint32array";
          case "Float32Array":
            return "float32array";
          case "Float64Array":
            return "float64array";
        }
        if (isGeneratorObj(val)) {
          return "generator";
        }
        type = toString.call(val);
        switch (type) {
          case "[object Object]":
            return "object";
          case "[object Map Iterator]":
            return "mapiterator";
          case "[object Set Iterator]":
            return "setiterator";
          case "[object String Iterator]":
            return "stringiterator";
          case "[object Array Iterator]":
            return "arrayiterator";
        }
        return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
      };
      function ctorName(val) {
        return typeof val.constructor === "function" ? val.constructor.name : null;
      }
      function isArray(val) {
        if (Array.isArray)
          return Array.isArray(val);
        return val instanceof Array;
      }
      function isError(val) {
        return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
      }
      function isDate(val) {
        if (val instanceof Date)
          return true;
        return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
      }
      function isRegexp(val) {
        if (val instanceof RegExp)
          return true;
        return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
      }
      function isGeneratorFn(name, val) {
        return ctorName(name) === "GeneratorFunction";
      }
      function isGeneratorObj(val) {
        return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
      }
      function isArguments(val) {
        try {
          if (typeof val.length === "number" && typeof val.callee === "function") {
            return true;
          }
        } catch (err) {
          if (err.message.indexOf("callee") !== -1) {
            return true;
          }
        }
        return false;
      }
      function isBuffer(val) {
        if (val.constructor && typeof val.constructor.isBuffer === "function") {
          return val.constructor.isBuffer(val);
        }
        return false;
      }
    }
  });

  // node_modules/is-extendable/index.js
  var require_is_extendable = __commonJS({
    "node_modules/is-extendable/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function isExtendable(val) {
        return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
      };
    }
  });

  // node_modules/extend-shallow/index.js
  var require_extend_shallow = __commonJS({
    "node_modules/extend-shallow/index.js"(exports2, module2) {
      "use strict";
      var isObject = require_is_extendable();
      module2.exports = function extend(o) {
        if (!isObject(o)) {
          o = {};
        }
        var len = arguments.length;
        for (var i = 1; i < len; i++) {
          var obj = arguments[i];
          if (isObject(obj)) {
            assign(o, obj);
          }
        }
        return o;
      };
      function assign(a, b) {
        for (var key in b) {
          if (hasOwn(b, key)) {
            a[key] = b[key];
          }
        }
      }
      function hasOwn(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
    }
  });

  // node_modules/section-matter/index.js
  var require_section_matter = __commonJS({
    "node_modules/section-matter/index.js"(exports2, module2) {
      "use strict";
      var typeOf = require_kind_of();
      var extend = require_extend_shallow();
      module2.exports = function(input, options2) {
        if (typeof options2 === "function") {
          options2 = { parse: options2 };
        }
        var file = toObject(input);
        var defaults = { section_delimiter: "---", parse: identity };
        var opts = extend({}, defaults, options2);
        var delim = opts.section_delimiter;
        var lines = file.content.split(/\r?\n/);
        var sections = null;
        var section = createSection();
        var content = [];
        var stack = [];
        function initSections(val) {
          file.content = val;
          sections = [];
          content = [];
        }
        function closeSection(val) {
          if (stack.length) {
            section.key = getKey(stack[0], delim);
            section.content = val;
            opts.parse(section, sections);
            sections.push(section);
            section = createSection();
            content = [];
            stack = [];
          }
        }
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          var len = stack.length;
          var ln = line.trim();
          if (isDelimiter(ln, delim)) {
            if (ln.length === 3 && i !== 0) {
              if (len === 0 || len === 2) {
                content.push(line);
                continue;
              }
              stack.push(ln);
              section.data = content.join("\n");
              content = [];
              continue;
            }
            if (sections === null) {
              initSections(content.join("\n"));
            }
            if (len === 2) {
              closeSection(content.join("\n"));
            }
            stack.push(ln);
            continue;
          }
          content.push(line);
        }
        if (sections === null) {
          initSections(content.join("\n"));
        } else {
          closeSection(content.join("\n"));
        }
        file.sections = sections;
        return file;
      };
      function isDelimiter(line, delim) {
        if (line.slice(0, delim.length) !== delim) {
          return false;
        }
        if (line.charAt(delim.length + 1) === delim.slice(-1)) {
          return false;
        }
        return true;
      }
      function toObject(input) {
        if (typeOf(input) !== "object") {
          input = { content: input };
        }
        if (typeof input.content !== "string" && !isBuffer(input.content)) {
          throw new TypeError("expected a buffer or string");
        }
        input.content = input.content.toString();
        input.sections = [];
        return input;
      }
      function getKey(val, delim) {
        return val ? val.slice(delim.length).trim() : "";
      }
      function createSection() {
        return { key: "", data: "", content: "" };
      }
      function identity(val) {
        return val;
      }
      function isBuffer(val) {
        if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
          return val.constructor.isBuffer(val);
        }
        return false;
      }
    }
  });

  // node_modules/js-yaml/lib/js-yaml/common.js
  var require_common = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
      "use strict";
      function isNothing(subject) {
        return typeof subject === "undefined" || subject === null;
      }
      function isObject(subject) {
        return typeof subject === "object" && subject !== null;
      }
      function toArray(sequence) {
        if (Array.isArray(sequence))
          return sequence;
        else if (isNothing(sequence))
          return [];
        return [sequence];
      }
      function extend(target, source) {
        var index2, length, key, sourceKeys;
        if (source) {
          sourceKeys = Object.keys(source);
          for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
            key = sourceKeys[index2];
            target[key] = source[key];
          }
        }
        return target;
      }
      function repeat(string, count) {
        var result = "", cycle;
        for (cycle = 0; cycle < count; cycle += 1) {
          result += string;
        }
        return result;
      }
      function isNegativeZero(number2) {
        return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
      }
      module2.exports.isNothing = isNothing;
      module2.exports.isObject = isObject;
      module2.exports.toArray = toArray;
      module2.exports.repeat = repeat;
      module2.exports.isNegativeZero = isNegativeZero;
      module2.exports.extend = extend;
    }
  });

  // node_modules/js-yaml/lib/js-yaml/exception.js
  var require_exception = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
      "use strict";
      function YAMLException(reason, mark) {
        Error.call(this);
        this.name = "YAMLException";
        this.reason = reason;
        this.mark = mark;
        this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack || "";
        }
      }
      YAMLException.prototype = Object.create(Error.prototype);
      YAMLException.prototype.constructor = YAMLException;
      YAMLException.prototype.toString = function toString(compact) {
        var result = this.name + ": ";
        result += this.reason || "(unknown reason)";
        if (!compact && this.mark) {
          result += " " + this.mark.toString();
        }
        return result;
      };
      module2.exports = YAMLException;
    }
  });

  // node_modules/js-yaml/lib/js-yaml/mark.js
  var require_mark = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      function Mark(name, buffer2, position, line, column) {
        this.name = name;
        this.buffer = buffer2;
        this.position = position;
        this.line = line;
        this.column = column;
      }
      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
        var head, start, tail, end, snippet;
        if (!this.buffer)
          return null;
        indent = indent || 4;
        maxLength = maxLength || 75;
        head = "";
        start = this.position;
        while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
          start -= 1;
          if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
          }
        }
        tail = "";
        end = this.position;
        while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
          end += 1;
          if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
          }
        }
        snippet = this.buffer.slice(start, end);
        return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
      };
      Mark.prototype.toString = function toString(compact) {
        var snippet, where = "";
        if (this.name) {
          where += 'in "' + this.name + '" ';
        }
        where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
        if (!compact) {
          snippet = this.getSnippet();
          if (snippet) {
            where += ":\n" + snippet;
          }
        }
        return where;
      };
      module2.exports = Mark;
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type.js
  var require_type = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
      "use strict";
      var YAMLException = require_exception();
      var TYPE_CONSTRUCTOR_OPTIONS = [
        "kind",
        "resolve",
        "construct",
        "instanceOf",
        "predicate",
        "represent",
        "defaultStyle",
        "styleAliases"
      ];
      var YAML_NODE_KINDS = [
        "scalar",
        "sequence",
        "mapping"
      ];
      function compileStyleAliases(map) {
        var result = {};
        if (map !== null) {
          Object.keys(map).forEach(function(style) {
            map[style].forEach(function(alias) {
              result[String(alias)] = style;
            });
          });
        }
        return result;
      }
      function Type(tag, options2) {
        options2 = options2 || {};
        Object.keys(options2).forEach(function(name) {
          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
          }
        });
        this.tag = tag;
        this.kind = options2["kind"] || null;
        this.resolve = options2["resolve"] || function() {
          return true;
        };
        this.construct = options2["construct"] || function(data) {
          return data;
        };
        this.instanceOf = options2["instanceOf"] || null;
        this.predicate = options2["predicate"] || null;
        this.represent = options2["represent"] || null;
        this.defaultStyle = options2["defaultStyle"] || null;
        this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
          throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
        }
      }
      module2.exports = Type;
    }
  });

  // node_modules/js-yaml/lib/js-yaml/schema.js
  var require_schema = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var YAMLException = require_exception();
      var Type = require_type();
      function compileList(schema, name, result) {
        var exclude = [];
        schema.include.forEach(function(includedSchema) {
          result = compileList(includedSchema, name, result);
        });
        schema[name].forEach(function(currentType) {
          result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
              exclude.push(previousIndex);
            }
          });
          result.push(currentType);
        });
        return result.filter(function(type, index2) {
          return exclude.indexOf(index2) === -1;
        });
      }
      function compileMap() {
        var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {}
        }, index2, length;
        function collectType(type) {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
        for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
          arguments[index2].forEach(collectType);
        }
        return result;
      }
      function Schema(definition) {
        this.include = definition.include || [];
        this.implicit = definition.implicit || [];
        this.explicit = definition.explicit || [];
        this.implicit.forEach(function(type) {
          if (type.loadKind && type.loadKind !== "scalar") {
            throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
          }
        });
        this.compiledImplicit = compileList(this, "implicit", []);
        this.compiledExplicit = compileList(this, "explicit", []);
        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
      }
      Schema.DEFAULT = null;
      Schema.create = function createSchema() {
        var schemas, types;
        switch (arguments.length) {
          case 1:
            schemas = Schema.DEFAULT;
            types = arguments[0];
            break;
          case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
          default:
            throw new YAMLException("Wrong number of arguments for Schema.create function");
        }
        schemas = common.toArray(schemas);
        types = common.toArray(types);
        if (!schemas.every(function(schema) {
          return schema instanceof Schema;
        })) {
          throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
        }
        if (!types.every(function(type) {
          return type instanceof Type;
        })) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        return new Schema({
          include: schemas,
          explicit: types
        });
      };
      module2.exports = Schema;
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/str.js
  var require_str = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      module2.exports = new Type("tag:yaml.org,2002:str", {
        kind: "scalar",
        construct: function(data) {
          return data !== null ? data : "";
        }
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/seq.js
  var require_seq = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      module2.exports = new Type("tag:yaml.org,2002:seq", {
        kind: "sequence",
        construct: function(data) {
          return data !== null ? data : [];
        }
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/map.js
  var require_map = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      module2.exports = new Type("tag:yaml.org,2002:map", {
        kind: "mapping",
        construct: function(data) {
          return data !== null ? data : {};
        }
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
  var require_failsafe = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        explicit: [
          require_str(),
          require_seq(),
          require_map()
        ]
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/null.js
  var require_null = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveYamlNull(data) {
        if (data === null)
          return true;
        var max = data.length;
        return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
      }
      function constructYamlNull() {
        return null;
      }
      function isNull(object) {
        return object === null;
      }
      module2.exports = new Type("tag:yaml.org,2002:null", {
        kind: "scalar",
        resolve: resolveYamlNull,
        construct: constructYamlNull,
        predicate: isNull,
        represent: {
          canonical: function() {
            return "~";
          },
          lowercase: function() {
            return "null";
          },
          uppercase: function() {
            return "NULL";
          },
          camelcase: function() {
            return "Null";
          }
        },
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/bool.js
  var require_bool = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveYamlBoolean(data) {
        if (data === null)
          return false;
        var max = data.length;
        return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
      }
      function constructYamlBoolean(data) {
        return data === "true" || data === "True" || data === "TRUE";
      }
      function isBoolean(object) {
        return Object.prototype.toString.call(object) === "[object Boolean]";
      }
      module2.exports = new Type("tag:yaml.org,2002:bool", {
        kind: "scalar",
        resolve: resolveYamlBoolean,
        construct: constructYamlBoolean,
        predicate: isBoolean,
        represent: {
          lowercase: function(object) {
            return object ? "true" : "false";
          },
          uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
          },
          camelcase: function(object) {
            return object ? "True" : "False";
          }
        },
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/int.js
  var require_int = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var Type = require_type();
      function isHexCode(c) {
        return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
      }
      function isOctCode(c) {
        return 48 <= c && c <= 55;
      }
      function isDecCode(c) {
        return 48 <= c && c <= 57;
      }
      function resolveYamlInteger(data) {
        if (data === null)
          return false;
        var max = data.length, index2 = 0, hasDigits = false, ch;
        if (!max)
          return false;
        ch = data[index2];
        if (ch === "-" || ch === "+") {
          ch = data[++index2];
        }
        if (ch === "0") {
          if (index2 + 1 === max)
            return true;
          ch = data[++index2];
          if (ch === "b") {
            index2++;
            for (; index2 < max; index2++) {
              ch = data[index2];
              if (ch === "_")
                continue;
              if (ch !== "0" && ch !== "1")
                return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          if (ch === "x") {
            index2++;
            for (; index2 < max; index2++) {
              ch = data[index2];
              if (ch === "_")
                continue;
              if (!isHexCode(data.charCodeAt(index2)))
                return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          for (; index2 < max; index2++) {
            ch = data[index2];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "_")
          return false;
        for (; index2 < max; index2++) {
          ch = data[index2];
          if (ch === "_")
            continue;
          if (ch === ":")
            break;
          if (!isDecCode(data.charCodeAt(index2))) {
            return false;
          }
          hasDigits = true;
        }
        if (!hasDigits || ch === "_")
          return false;
        if (ch !== ":")
          return true;
        return /^(:[0-5]?[0-9])+$/.test(data.slice(index2));
      }
      function constructYamlInteger(data) {
        var value = data, sign = 1, ch, base2, digits = [];
        if (value.indexOf("_") !== -1) {
          value = value.replace(/_/g, "");
        }
        ch = value[0];
        if (ch === "-" || ch === "+") {
          if (ch === "-")
            sign = -1;
          value = value.slice(1);
          ch = value[0];
        }
        if (value === "0")
          return 0;
        if (ch === "0") {
          if (value[1] === "b")
            return sign * parseInt(value.slice(2), 2);
          if (value[1] === "x")
            return sign * parseInt(value, 16);
          return sign * parseInt(value, 8);
        }
        if (value.indexOf(":") !== -1) {
          value.split(":").forEach(function(v) {
            digits.unshift(parseInt(v, 10));
          });
          value = 0;
          base2 = 1;
          digits.forEach(function(d) {
            value += d * base2;
            base2 *= 60;
          });
          return sign * value;
        }
        return sign * parseInt(value, 10);
      }
      function isInteger(object) {
        return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
      }
      module2.exports = new Type("tag:yaml.org,2002:int", {
        kind: "scalar",
        resolve: resolveYamlInteger,
        construct: constructYamlInteger,
        predicate: isInteger,
        represent: {
          binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
          },
          octal: function(obj) {
            return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
          },
          decimal: function(obj) {
            return obj.toString(10);
          },
          /* eslint-disable max-len */
          hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
          }
        },
        defaultStyle: "decimal",
        styleAliases: {
          binary: [2, "bin"],
          octal: [8, "oct"],
          decimal: [10, "dec"],
          hexadecimal: [16, "hex"]
        }
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/float.js
  var require_float = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var Type = require_type();
      var YAML_FLOAT_PATTERN = new RegExp(
        // 2.5e4, 2.5 and integers
        "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
      );
      function resolveYamlFloat(data) {
        if (data === null)
          return false;
        if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === "_") {
          return false;
        }
        return true;
      }
      function constructYamlFloat(data) {
        var value, sign, base2, digits;
        value = data.replace(/_/g, "").toLowerCase();
        sign = value[0] === "-" ? -1 : 1;
        digits = [];
        if ("+-".indexOf(value[0]) >= 0) {
          value = value.slice(1);
        }
        if (value === ".inf") {
          return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
        } else if (value === ".nan") {
          return NaN;
        } else if (value.indexOf(":") >= 0) {
          value.split(":").forEach(function(v) {
            digits.unshift(parseFloat(v, 10));
          });
          value = 0;
          base2 = 1;
          digits.forEach(function(d) {
            value += d * base2;
            base2 *= 60;
          });
          return sign * value;
        }
        return sign * parseFloat(value, 10);
      }
      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
      function representYamlFloat(object, style) {
        var res;
        if (isNaN(object)) {
          switch (style) {
            case "lowercase":
              return ".nan";
            case "uppercase":
              return ".NAN";
            case "camelcase":
              return ".NaN";
          }
        } else if (Number.POSITIVE_INFINITY === object) {
          switch (style) {
            case "lowercase":
              return ".inf";
            case "uppercase":
              return ".INF";
            case "camelcase":
              return ".Inf";
          }
        } else if (Number.NEGATIVE_INFINITY === object) {
          switch (style) {
            case "lowercase":
              return "-.inf";
            case "uppercase":
              return "-.INF";
            case "camelcase":
              return "-.Inf";
          }
        } else if (common.isNegativeZero(object)) {
          return "-0.0";
        }
        res = object.toString(10);
        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
      }
      function isFloat(object) {
        return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
      }
      module2.exports = new Type("tag:yaml.org,2002:float", {
        kind: "scalar",
        resolve: resolveYamlFloat,
        construct: constructYamlFloat,
        predicate: isFloat,
        represent: representYamlFloat,
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/schema/json.js
  var require_json = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        include: [
          require_failsafe()
        ],
        implicit: [
          require_null(),
          require_bool(),
          require_int(),
          require_float()
        ]
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/schema/core.js
  var require_core = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        include: [
          require_json()
        ]
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/timestamp.js
  var require_timestamp = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var YAML_DATE_REGEXP = new RegExp(
        "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
      );
      var YAML_TIMESTAMP_REGEXP = new RegExp(
        "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
      );
      function resolveYamlTimestamp(data) {
        if (data === null)
          return false;
        if (YAML_DATE_REGEXP.exec(data) !== null)
          return true;
        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
          return true;
        return false;
      }
      function constructYamlTimestamp(data) {
        var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
        match = YAML_DATE_REGEXP.exec(data);
        if (match === null)
          match = YAML_TIMESTAMP_REGEXP.exec(data);
        if (match === null)
          throw new Error("Date resolve error");
        year = +match[1];
        month = +match[2] - 1;
        day = +match[3];
        if (!match[4]) {
          return new Date(Date.UTC(year, month, day));
        }
        hour = +match[4];
        minute = +match[5];
        second = +match[6];
        if (match[7]) {
          fraction = match[7].slice(0, 3);
          while (fraction.length < 3) {
            fraction += "0";
          }
          fraction = +fraction;
        }
        if (match[9]) {
          tz_hour = +match[10];
          tz_minute = +(match[11] || 0);
          delta = (tz_hour * 60 + tz_minute) * 6e4;
          if (match[9] === "-")
            delta = -delta;
        }
        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
        if (delta)
          date.setTime(date.getTime() - delta);
        return date;
      }
      function representYamlTimestamp(object) {
        return object.toISOString();
      }
      module2.exports = new Type("tag:yaml.org,2002:timestamp", {
        kind: "scalar",
        resolve: resolveYamlTimestamp,
        construct: constructYamlTimestamp,
        instanceOf: Date,
        represent: representYamlTimestamp
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/merge.js
  var require_merge = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveYamlMerge(data) {
        return data === "<<" || data === null;
      }
      module2.exports = new Type("tag:yaml.org,2002:merge", {
        kind: "scalar",
        resolve: resolveYamlMerge
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/binary.js
  var require_binary = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
      "use strict";
      var NodeBuffer;
      try {
        _require = __require;
        NodeBuffer = _require("buffer").Buffer;
      } catch (__) {
      }
      var _require;
      var Type = require_type();
      var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
      function resolveYamlBinary(data) {
        if (data === null)
          return false;
        var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
        for (idx = 0; idx < max; idx++) {
          code = map.indexOf(data.charAt(idx));
          if (code > 64)
            continue;
          if (code < 0)
            return false;
          bitlen += 6;
        }
        return bitlen % 8 === 0;
      }
      function constructYamlBinary(data) {
        var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
        for (idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 255);
            result.push(bits >> 8 & 255);
            result.push(bits & 255);
          }
          bits = bits << 6 | map.indexOf(input.charAt(idx));
        }
        tailbits = max % 4 * 6;
        if (tailbits === 0) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        } else if (tailbits === 18) {
          result.push(bits >> 10 & 255);
          result.push(bits >> 2 & 255);
        } else if (tailbits === 12) {
          result.push(bits >> 4 & 255);
        }
        if (NodeBuffer) {
          return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
        }
        return result;
      }
      function representYamlBinary(object) {
        var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
        for (idx = 0; idx < max; idx++) {
          if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 63];
            result += map[bits >> 12 & 63];
            result += map[bits >> 6 & 63];
            result += map[bits & 63];
          }
          bits = (bits << 8) + object[idx];
        }
        tail = max % 3;
        if (tail === 0) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        } else if (tail === 2) {
          result += map[bits >> 10 & 63];
          result += map[bits >> 4 & 63];
          result += map[bits << 2 & 63];
          result += map[64];
        } else if (tail === 1) {
          result += map[bits >> 2 & 63];
          result += map[bits << 4 & 63];
          result += map[64];
          result += map[64];
        }
        return result;
      }
      function isBinary(object) {
        return NodeBuffer && NodeBuffer.isBuffer(object);
      }
      module2.exports = new Type("tag:yaml.org,2002:binary", {
        kind: "scalar",
        resolve: resolveYamlBinary,
        construct: constructYamlBinary,
        predicate: isBinary,
        represent: representYamlBinary
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/omap.js
  var require_omap = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var _toString = Object.prototype.toString;
      function resolveYamlOmap(data) {
        if (data === null)
          return true;
        var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          pair = object[index2];
          pairHasKey = false;
          if (_toString.call(pair) !== "[object Object]")
            return false;
          for (pairKey in pair) {
            if (_hasOwnProperty.call(pair, pairKey)) {
              if (!pairHasKey)
                pairHasKey = true;
              else
                return false;
            }
          }
          if (!pairHasKey)
            return false;
          if (objectKeys.indexOf(pairKey) === -1)
            objectKeys.push(pairKey);
          else
            return false;
        }
        return true;
      }
      function constructYamlOmap(data) {
        return data !== null ? data : [];
      }
      module2.exports = new Type("tag:yaml.org,2002:omap", {
        kind: "sequence",
        resolve: resolveYamlOmap,
        construct: constructYamlOmap
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/pairs.js
  var require_pairs = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var _toString = Object.prototype.toString;
      function resolveYamlPairs(data) {
        if (data === null)
          return true;
        var index2, length, pair, keys, result, object = data;
        result = new Array(object.length);
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          pair = object[index2];
          if (_toString.call(pair) !== "[object Object]")
            return false;
          keys = Object.keys(pair);
          if (keys.length !== 1)
            return false;
          result[index2] = [keys[0], pair[keys[0]]];
        }
        return true;
      }
      function constructYamlPairs(data) {
        if (data === null)
          return [];
        var index2, length, pair, keys, result, object = data;
        result = new Array(object.length);
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          pair = object[index2];
          keys = Object.keys(pair);
          result[index2] = [keys[0], pair[keys[0]]];
        }
        return result;
      }
      module2.exports = new Type("tag:yaml.org,2002:pairs", {
        kind: "sequence",
        resolve: resolveYamlPairs,
        construct: constructYamlPairs
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/set.js
  var require_set = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      function resolveYamlSet(data) {
        if (data === null)
          return true;
        var key, object = data;
        for (key in object) {
          if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null)
              return false;
          }
        }
        return true;
      }
      function constructYamlSet(data) {
        return data !== null ? data : {};
      }
      module2.exports = new Type("tag:yaml.org,2002:set", {
        kind: "mapping",
        resolve: resolveYamlSet,
        construct: constructYamlSet
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
  var require_default_safe = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        include: [
          require_core()
        ],
        implicit: [
          require_timestamp(),
          require_merge()
        ],
        explicit: [
          require_binary(),
          require_omap(),
          require_pairs(),
          require_set()
        ]
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
  var require_undefined = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveJavascriptUndefined() {
        return true;
      }
      function constructJavascriptUndefined() {
        return void 0;
      }
      function representJavascriptUndefined() {
        return "";
      }
      function isUndefined(object) {
        return typeof object === "undefined";
      }
      module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
        kind: "scalar",
        resolve: resolveJavascriptUndefined,
        construct: constructJavascriptUndefined,
        predicate: isUndefined,
        represent: representJavascriptUndefined
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
  var require_regexp = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveJavascriptRegExp(data) {
        if (data === null)
          return false;
        if (data.length === 0)
          return false;
        var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers2 = "";
        if (regexp[0] === "/") {
          if (tail)
            modifiers2 = tail[1];
          if (modifiers2.length > 3)
            return false;
          if (regexp[regexp.length - modifiers2.length - 1] !== "/")
            return false;
        }
        return true;
      }
      function constructJavascriptRegExp(data) {
        var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers2 = "";
        if (regexp[0] === "/") {
          if (tail)
            modifiers2 = tail[1];
          regexp = regexp.slice(1, regexp.length - modifiers2.length - 1);
        }
        return new RegExp(regexp, modifiers2);
      }
      function representJavascriptRegExp(object) {
        var result = "/" + object.source + "/";
        if (object.global)
          result += "g";
        if (object.multiline)
          result += "m";
        if (object.ignoreCase)
          result += "i";
        return result;
      }
      function isRegExp(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]";
      }
      module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
        kind: "scalar",
        resolve: resolveJavascriptRegExp,
        construct: constructJavascriptRegExp,
        predicate: isRegExp,
        represent: representJavascriptRegExp
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/type/js/function.js
  var require_function = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
      "use strict";
      var esprima;
      try {
        _require = __require;
        esprima = _require("esprima");
      } catch (_) {
        if (typeof window !== "undefined")
          esprima = window.esprima;
      }
      var _require;
      var Type = require_type();
      function resolveJavascriptFunction(data) {
        if (data === null)
          return false;
        try {
          var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
          if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      function constructJavascriptFunction(data) {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          throw new Error("Failed to resolve function");
        }
        ast.body[0].expression.params.forEach(function(param) {
          params.push(param.name);
        });
        body = ast.body[0].expression.body.range;
        if (ast.body[0].expression.body.type === "BlockStatement") {
          return new Function(params, source.slice(body[0] + 1, body[1] - 1));
        }
        return new Function(params, "return " + source.slice(body[0], body[1]));
      }
      function representJavascriptFunction(object) {
        return object.toString();
      }
      function isFunction(object) {
        return Object.prototype.toString.call(object) === "[object Function]";
      }
      module2.exports = new Type("tag:yaml.org,2002:js/function", {
        kind: "scalar",
        resolve: resolveJavascriptFunction,
        construct: constructJavascriptFunction,
        predicate: isFunction,
        represent: representJavascriptFunction
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/schema/default_full.js
  var require_default_full = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = Schema.DEFAULT = new Schema({
        include: [
          require_default_safe()
        ],
        explicit: [
          require_undefined(),
          require_regexp(),
          require_function()
        ]
      });
    }
  });

  // node_modules/js-yaml/lib/js-yaml/loader.js
  var require_loader = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var YAMLException = require_exception();
      var Mark = require_mark();
      var DEFAULT_SAFE_SCHEMA = require_default_safe();
      var DEFAULT_FULL_SCHEMA = require_default_full();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var CONTEXT_FLOW_IN = 1;
      var CONTEXT_FLOW_OUT = 2;
      var CONTEXT_BLOCK_IN = 3;
      var CONTEXT_BLOCK_OUT = 4;
      var CHOMPING_CLIP = 1;
      var CHOMPING_STRIP = 2;
      var CHOMPING_KEEP = 3;
      var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
      var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
      var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
      function _class(obj) {
        return Object.prototype.toString.call(obj);
      }
      function is_EOL(c) {
        return c === 10 || c === 13;
      }
      function is_WHITE_SPACE(c) {
        return c === 9 || c === 32;
      }
      function is_WS_OR_EOL(c) {
        return c === 9 || c === 32 || c === 10 || c === 13;
      }
      function is_FLOW_INDICATOR(c) {
        return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
      }
      function fromHexCode(c) {
        var lc;
        if (48 <= c && c <= 57) {
          return c - 48;
        }
        lc = c | 32;
        if (97 <= lc && lc <= 102) {
          return lc - 97 + 10;
        }
        return -1;
      }
      function escapedHexLen(c) {
        if (c === 120) {
          return 2;
        }
        if (c === 117) {
          return 4;
        }
        if (c === 85) {
          return 8;
        }
        return 0;
      }
      function fromDecimalCode(c) {
        if (48 <= c && c <= 57) {
          return c - 48;
        }
        return -1;
      }
      function simpleEscapeSequence(c) {
        return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
      }
      function charFromCodepoint(c) {
        if (c <= 65535) {
          return String.fromCharCode(c);
        }
        return String.fromCharCode(
          (c - 65536 >> 10) + 55296,
          (c - 65536 & 1023) + 56320
        );
      }
      var simpleEscapeCheck = new Array(256);
      var simpleEscapeMap = new Array(256);
      for (i = 0; i < 256; i++) {
        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
        simpleEscapeMap[i] = simpleEscapeSequence(i);
      }
      var i;
      function State(input, options2) {
        this.input = input;
        this.filename = options2["filename"] || null;
        this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
        this.onWarning = options2["onWarning"] || null;
        this.legacy = options2["legacy"] || false;
        this.json = options2["json"] || false;
        this.listener = options2["listener"] || null;
        this.implicitTypes = this.schema.compiledImplicit;
        this.typeMap = this.schema.compiledTypeMap;
        this.length = input.length;
        this.position = 0;
        this.line = 0;
        this.lineStart = 0;
        this.lineIndent = 0;
        this.documents = [];
      }
      function generateError(state, message) {
        return new YAMLException(
          message,
          new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
        );
      }
      function throwError(state, message) {
        throw generateError(state, message);
      }
      function throwWarning(state, message) {
        if (state.onWarning) {
          state.onWarning.call(null, generateError(state, message));
        }
      }
      var directiveHandlers = {
        YAML: function handleYamlDirective(state, name, args) {
          var match, major, minor;
          if (state.version !== null) {
            throwError(state, "duplication of %YAML directive");
          }
          if (args.length !== 1) {
            throwError(state, "YAML directive accepts exactly one argument");
          }
          match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
          if (match === null) {
            throwError(state, "ill-formed argument of the YAML directive");
          }
          major = parseInt(match[1], 10);
          minor = parseInt(match[2], 10);
          if (major !== 1) {
            throwError(state, "unacceptable YAML version of the document");
          }
          state.version = args[0];
          state.checkLineBreaks = minor < 2;
          if (minor !== 1 && minor !== 2) {
            throwWarning(state, "unsupported YAML version of the document");
          }
        },
        TAG: function handleTagDirective(state, name, args) {
          var handle, prefix;
          if (args.length !== 2) {
            throwError(state, "TAG directive accepts exactly two arguments");
          }
          handle = args[0];
          prefix = args[1];
          if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
          }
          if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
          }
          if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
          }
          state.tagMap[handle] = prefix;
        }
      };
      function captureSegment(state, start, end, checkJson) {
        var _position, _length, _character, _result;
        if (start < end) {
          _result = state.input.slice(start, end);
          if (checkJson) {
            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
              _character = _result.charCodeAt(_position);
              if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                throwError(state, "expected valid JSON character");
              }
            }
          } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, "the stream contains non-printable characters");
          }
          state.result += _result;
        }
      }
      function mergeMappings(state, destination, source, overridableKeys) {
        var sourceKeys, key, index2, quantity;
        if (!common.isObject(source)) {
          throwError(state, "cannot merge mappings; the provided source object is unacceptable");
        }
        sourceKeys = Object.keys(source);
        for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
          key = sourceKeys[index2];
          if (!_hasOwnProperty.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
          }
        }
      }
      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
        var index2, quantity;
        if (Array.isArray(keyNode)) {
          keyNode = Array.prototype.slice.call(keyNode);
          for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
            if (Array.isArray(keyNode[index2])) {
              throwError(state, "nested arrays are not supported inside keys");
            }
            if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
              keyNode[index2] = "[object Object]";
            }
          }
        }
        if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
          keyNode = "[object Object]";
        }
        keyNode = String(keyNode);
        if (_result === null) {
          _result = {};
        }
        if (keyTag === "tag:yaml.org,2002:merge") {
          if (Array.isArray(valueNode)) {
            for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
              mergeMappings(state, _result, valueNode[index2], overridableKeys);
            }
          } else {
            mergeMappings(state, _result, valueNode, overridableKeys);
          }
        } else {
          if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.position = startPos || state.position;
            throwError(state, "duplicated mapping key");
          }
          _result[keyNode] = valueNode;
          delete overridableKeys[keyNode];
        }
        return _result;
      }
      function readLineBreak(state) {
        var ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 10) {
          state.position++;
        } else if (ch === 13) {
          state.position++;
          if (state.input.charCodeAt(state.position) === 10) {
            state.position++;
          }
        } else {
          throwError(state, "a line break is expected");
        }
        state.line += 1;
        state.lineStart = state.position;
      }
      function skipSeparationSpace(state, allowComments, checkIndent) {
        var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (allowComments && ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 10 && ch !== 13 && ch !== 0);
          }
          if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while (ch === 32) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
          } else {
            break;
          }
        }
        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
          throwWarning(state, "deficient indentation");
        }
        return lineBreaks;
      }
      function testDocumentSeparator(state) {
        var _position = state.position, ch;
        ch = state.input.charCodeAt(_position);
        if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
          _position += 3;
          ch = state.input.charCodeAt(_position);
          if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
          }
        }
        return false;
      }
      function writeFoldedLines(state, count) {
        if (count === 1) {
          state.result += " ";
        } else if (count > 1) {
          state.result += common.repeat("\n", count - 1);
        }
      }
      function readPlainScalar(state, nodeIndent, withinFlowCollection) {
        var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
        ch = state.input.charCodeAt(state.position);
        if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
          return false;
        }
        if (ch === 63 || ch === 45) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            return false;
          }
        }
        state.kind = "scalar";
        state.result = "";
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
        while (ch !== 0) {
          if (ch === 58) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              break;
            }
          } else if (ch === 35) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
              break;
            }
          } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
            break;
          } else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
              hasPendingContent = true;
              ch = state.input.charCodeAt(state.position);
              continue;
            } else {
              state.position = captureEnd;
              state.line = _line;
              state.lineStart = _lineStart;
              state.lineIndent = _lineIndent;
              break;
            }
          }
          if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
          }
          if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, captureEnd, false);
        if (state.result) {
          return true;
        }
        state.kind = _kind;
        state.result = _result;
        return false;
      }
      function readSingleQuotedScalar(state, nodeIndent) {
        var ch, captureStart, captureEnd;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 39) {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        state.position++;
        captureStart = captureEnd = state.position;
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 39) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 39) {
              captureStart = state.position;
              state.position++;
              captureEnd = state.position;
            } else {
              return true;
            }
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a single quoted scalar");
          } else {
            state.position++;
            captureEnd = state.position;
          }
        }
        throwError(state, "unexpected end of the stream within a single quoted scalar");
      }
      function readDoubleQuotedScalar(state, nodeIndent) {
        var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 34) {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        state.position++;
        captureStart = captureEnd = state.position;
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 34) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
          } else if (ch === 92) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
              skipSeparationSpace(state, false, nodeIndent);
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
              state.result += simpleEscapeMap[ch];
              state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
              hexLength = tmp;
              hexResult = 0;
              for (; hexLength > 0; hexLength--) {
                ch = state.input.charCodeAt(++state.position);
                if ((tmp = fromHexCode(ch)) >= 0) {
                  hexResult = (hexResult << 4) + tmp;
                } else {
                  throwError(state, "expected hexadecimal character");
                }
              }
              state.result += charFromCodepoint(hexResult);
              state.position++;
            } else {
              throwError(state, "unknown escape sequence");
            }
            captureStart = captureEnd = state.position;
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a double quoted scalar");
          } else {
            state.position++;
            captureEnd = state.position;
          }
        }
        throwError(state, "unexpected end of the stream within a double quoted scalar");
      }
      function readFlowCollection(state, nodeIndent) {
        var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 91) {
          terminator = 93;
          isMapping = false;
          _result = [];
        } else if (ch === 123) {
          terminator = 125;
          isMapping = true;
          _result = {};
        } else {
          return false;
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(++state.position);
        while (ch !== 0) {
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
          } else if (!readNext) {
            throwError(state, "missed comma between flow collection entries");
          }
          keyTag = keyNode = valueNode = null;
          isPair = isExplicitPair = false;
          if (ch === 63) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
              isPair = isExplicitPair = true;
              state.position++;
              skipSeparationSpace(state, true, nodeIndent);
            }
          }
          _line = state.line;
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          keyTag = state.tag;
          keyNode = state.result;
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if ((isExplicitPair || state.line === _line) && ch === 58) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
          }
          if (isMapping) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
          } else if (isPair) {
            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
          } else {
            _result.push(keyNode);
          }
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if (ch === 44) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
          } else {
            readNext = false;
          }
        }
        throwError(state, "unexpected end of the stream within a flow collection");
      }
      function readBlockScalar(state, nodeIndent) {
        var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 124) {
          folding = false;
        } else if (ch === 62) {
          folding = true;
        } else {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        while (ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
          if (ch === 43 || ch === 45) {
            if (CHOMPING_CLIP === chomping) {
              chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
            } else {
              throwError(state, "repeat of a chomping mode identifier");
            }
          } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
              throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            } else if (!detectedIndent) {
              textIndent = nodeIndent + tmp - 1;
              detectedIndent = true;
            } else {
              throwError(state, "repeat of an indentation width identifier");
            }
          } else {
            break;
          }
        }
        if (is_WHITE_SPACE(ch)) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (is_WHITE_SPACE(ch));
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (!is_EOL(ch) && ch !== 0);
          }
        }
        while (ch !== 0) {
          readLineBreak(state);
          state.lineIndent = 0;
          ch = state.input.charCodeAt(state.position);
          while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
          if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
          }
          if (is_EOL(ch)) {
            emptyLines++;
            continue;
          }
          if (state.lineIndent < textIndent) {
            if (chomping === CHOMPING_KEEP) {
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (chomping === CHOMPING_CLIP) {
              if (didReadContent) {
                state.result += "\n";
              }
            }
            break;
          }
          if (folding) {
            if (is_WHITE_SPACE(ch)) {
              atMoreIndented = true;
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (atMoreIndented) {
              atMoreIndented = false;
              state.result += common.repeat("\n", emptyLines + 1);
            } else if (emptyLines === 0) {
              if (didReadContent) {
                state.result += " ";
              }
            } else {
              state.result += common.repeat("\n", emptyLines);
            }
          } else {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          }
          didReadContent = true;
          detectedIndent = true;
          emptyLines = 0;
          captureStart = state.position;
          while (!is_EOL(ch) && ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, state.position, false);
        }
        return true;
      }
      function readBlockSequence(state, nodeIndent) {
        var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          if (ch !== 45) {
            break;
          }
          following = state.input.charCodeAt(state.position + 1);
          if (!is_WS_OR_EOL(following)) {
            break;
          }
          detected = true;
          state.position++;
          if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
              _result.push(null);
              ch = state.input.charCodeAt(state.position);
              continue;
            }
          }
          _line = state.line;
          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
          _result.push(state.result);
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
          if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, "bad indentation of a sequence entry");
          } else if (state.lineIndent < nodeIndent) {
            break;
          }
        }
        if (detected) {
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = "sequence";
          state.result = _result;
          return true;
        }
        return false;
      }
      function readBlockMapping(state, nodeIndent, flowIndent) {
        var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          following = state.input.charCodeAt(state.position + 1);
          _line = state.line;
          _pos = state.position;
          if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
            if (ch === 63) {
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = true;
              allowCompact = true;
            } else if (atExplicitKey) {
              atExplicitKey = false;
              allowCompact = true;
            } else {
              throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            }
            state.position += 1;
            ch = following;
          } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
              ch = state.input.charCodeAt(state.position);
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 58) {
                ch = state.input.charCodeAt(++state.position);
                if (!is_WS_OR_EOL(ch)) {
                  throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                }
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = false;
                allowCompact = false;
                keyTag = state.tag;
                keyNode = state.result;
              } else if (detected) {
                throwError(state, "can not read an implicit mapping pair; a colon is missed");
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;
              }
            } else if (detected) {
              throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else {
            break;
          }
          if (state.line === _line || state.lineIndent > nodeIndent) {
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
              if (atExplicitKey) {
                keyNode = state.result;
              } else {
                valueNode = state.result;
              }
            }
            if (!atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
              keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
          }
          if (state.lineIndent > nodeIndent && ch !== 0) {
            throwError(state, "bad indentation of a mapping entry");
          } else if (state.lineIndent < nodeIndent) {
            break;
          }
        }
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
        }
        if (detected) {
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = "mapping";
          state.result = _result;
        }
        return detected;
      }
      function readTagProperty(state) {
        var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 33)
          return false;
        if (state.tag !== null) {
          throwError(state, "duplication of a tag property");
        }
        ch = state.input.charCodeAt(++state.position);
        if (ch === 60) {
          isVerbatim = true;
          ch = state.input.charCodeAt(++state.position);
        } else if (ch === 33) {
          isNamed = true;
          tagHandle = "!!";
          ch = state.input.charCodeAt(++state.position);
        } else {
          tagHandle = "!";
        }
        _position = state.position;
        if (isVerbatim) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && ch !== 62);
          if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
          } else {
            throwError(state, "unexpected end of the stream within a verbatim tag");
          }
        } else {
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            if (ch === 33) {
              if (!isNamed) {
                tagHandle = state.input.slice(_position - 1, state.position + 1);
                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                  throwError(state, "named tag handle cannot contain such characters");
                }
                isNamed = true;
                _position = state.position + 1;
              } else {
                throwError(state, "tag suffix cannot contain exclamation marks");
              }
            }
            ch = state.input.charCodeAt(++state.position);
          }
          tagName = state.input.slice(_position, state.position);
          if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, "tag suffix cannot contain flow indicator characters");
          }
        }
        if (tagName && !PATTERN_TAG_URI.test(tagName)) {
          throwError(state, "tag name cannot contain such characters: " + tagName);
        }
        if (isVerbatim) {
          state.tag = tagName;
        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
          state.tag = state.tagMap[tagHandle] + tagName;
        } else if (tagHandle === "!") {
          state.tag = "!" + tagName;
        } else if (tagHandle === "!!") {
          state.tag = "tag:yaml.org,2002:" + tagName;
        } else {
          throwError(state, 'undeclared tag handle "' + tagHandle + '"');
        }
        return true;
      }
      function readAnchorProperty(state) {
        var _position, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 38)
          return false;
        if (state.anchor !== null) {
          throwError(state, "duplication of an anchor property");
        }
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (state.position === _position) {
          throwError(state, "name of an anchor node must contain at least one character");
        }
        state.anchor = state.input.slice(_position, state.position);
        return true;
      }
      function readAlias(state) {
        var _position, alias, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 42)
          return false;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (state.position === _position) {
          throwError(state, "name of an alias node must contain at least one character");
        }
        alias = state.input.slice(_position, state.position);
        if (!_hasOwnProperty.call(state.anchorMap, alias)) {
          throwError(state, 'unidentified alias "' + alias + '"');
        }
        state.result = state.anchorMap[alias];
        skipSeparationSpace(state, true, -1);
        return true;
      }
      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
        var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
        if (state.listener !== null) {
          state.listener("open", state);
        }
        state.tag = null;
        state.anchor = null;
        state.kind = null;
        state.result = null;
        allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
        if (allowToSeek) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          }
        }
        if (indentStatus === 1) {
          while (readTagProperty(state) || readAnchorProperty(state)) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              allowBlockCollections = allowBlockStyles;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            } else {
              allowBlockCollections = false;
            }
          }
        }
        if (allowBlockCollections) {
          allowBlockCollections = atNewLine || allowCompact;
        }
        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
          } else {
            flowIndent = parentIndent + 1;
          }
          blockIndent = state.position - state.lineStart;
          if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
              hasContent = true;
            } else {
              if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                hasContent = true;
              } else if (readAlias(state)) {
                hasContent = true;
                if (state.tag !== null || state.anchor !== null) {
                  throwError(state, "alias node should not have any properties");
                }
              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                hasContent = true;
                if (state.tag === null) {
                  state.tag = "?";
                }
              }
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            }
          } else if (indentStatus === 0) {
            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
          }
        }
        if (state.tag !== null && state.tag !== "!") {
          if (state.tag === "?") {
            if (state.result !== null && state.kind !== "scalar") {
              throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
            }
            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
              type = state.implicitTypes[typeIndex];
              if (type.resolve(state.result)) {
                state.result = type.construct(state.result);
                state.tag = type.tag;
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
                break;
              }
            }
          } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
            if (state.result !== null && type.kind !== state.kind) {
              throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
            }
            if (!type.resolve(state.result)) {
              throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
            } else {
              state.result = type.construct(state.result);
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            }
          } else {
            throwError(state, "unknown tag !<" + state.tag + ">");
          }
        }
        if (state.listener !== null) {
          state.listener("close", state);
        }
        return state.tag !== null || state.anchor !== null || hasContent;
      }
      function readDocument(state) {
        var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
        state.version = null;
        state.checkLineBreaks = state.legacy;
        state.tagMap = {};
        state.anchorMap = {};
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
          if (state.lineIndent > 0 || ch !== 37) {
            break;
          }
          hasDirectives = true;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveName = state.input.slice(_position, state.position);
          directiveArgs = [];
          if (directiveName.length < 1) {
            throwError(state, "directive name must not be less than one character in length");
          }
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0 && !is_EOL(ch));
              break;
            }
            if (is_EOL(ch))
              break;
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
          }
          if (ch !== 0)
            readLineBreak(state);
          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
          } else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
          }
        }
        skipSeparationSpace(state, true, -1);
        if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        } else if (hasDirectives) {
          throwError(state, "directives end mark is expected");
        }
        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
        skipSeparationSpace(state, true, -1);
        if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
          throwWarning(state, "non-ASCII line breaks are interpreted as content");
        }
        state.documents.push(state.result);
        if (state.position === state.lineStart && testDocumentSeparator(state)) {
          if (state.input.charCodeAt(state.position) === 46) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          }
          return;
        }
        if (state.position < state.length - 1) {
          throwError(state, "end of the stream or a document separator is expected");
        } else {
          return;
        }
      }
      function loadDocuments(input, options2) {
        input = String(input);
        options2 = options2 || {};
        if (input.length !== 0) {
          if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
            input += "\n";
          }
          if (input.charCodeAt(0) === 65279) {
            input = input.slice(1);
          }
        }
        var state = new State(input, options2);
        var nullpos = input.indexOf("\0");
        if (nullpos !== -1) {
          state.position = nullpos;
          throwError(state, "null byte is not allowed in input");
        }
        state.input += "\0";
        while (state.input.charCodeAt(state.position) === 32) {
          state.lineIndent += 1;
          state.position += 1;
        }
        while (state.position < state.length - 1) {
          readDocument(state);
        }
        return state.documents;
      }
      function loadAll(input, iterator, options2) {
        if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
          options2 = iterator;
          iterator = null;
        }
        var documents = loadDocuments(input, options2);
        if (typeof iterator !== "function") {
          return documents;
        }
        for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
          iterator(documents[index2]);
        }
      }
      function load(input, options2) {
        var documents = loadDocuments(input, options2);
        if (documents.length === 0) {
          return void 0;
        } else if (documents.length === 1) {
          return documents[0];
        }
        throw new YAMLException("expected a single document in the stream, but found more");
      }
      function safeLoadAll(input, iterator, options2) {
        if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
          options2 = iterator;
          iterator = null;
        }
        return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
      }
      function safeLoad(input, options2) {
        return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
      }
      module2.exports.loadAll = loadAll;
      module2.exports.load = load;
      module2.exports.safeLoadAll = safeLoadAll;
      module2.exports.safeLoad = safeLoad;
    }
  });

  // node_modules/js-yaml/lib/js-yaml/dumper.js
  var require_dumper = __commonJS({
    "node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var YAMLException = require_exception();
      var DEFAULT_FULL_SCHEMA = require_default_full();
      var DEFAULT_SAFE_SCHEMA = require_default_safe();
      var _toString = Object.prototype.toString;
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var CHAR_TAB = 9;
      var CHAR_LINE_FEED = 10;
      var CHAR_CARRIAGE_RETURN = 13;
      var CHAR_SPACE = 32;
      var CHAR_EXCLAMATION = 33;
      var CHAR_DOUBLE_QUOTE = 34;
      var CHAR_SHARP = 35;
      var CHAR_PERCENT = 37;
      var CHAR_AMPERSAND = 38;
      var CHAR_SINGLE_QUOTE = 39;
      var CHAR_ASTERISK = 42;
      var CHAR_COMMA = 44;
      var CHAR_MINUS = 45;
      var CHAR_COLON = 58;
      var CHAR_EQUALS = 61;
      var CHAR_GREATER_THAN = 62;
      var CHAR_QUESTION = 63;
      var CHAR_COMMERCIAL_AT = 64;
      var CHAR_LEFT_SQUARE_BRACKET = 91;
      var CHAR_RIGHT_SQUARE_BRACKET = 93;
      var CHAR_GRAVE_ACCENT = 96;
      var CHAR_LEFT_CURLY_BRACKET = 123;
      var CHAR_VERTICAL_LINE = 124;
      var CHAR_RIGHT_CURLY_BRACKET = 125;
      var ESCAPE_SEQUENCES = {};
      ESCAPE_SEQUENCES[0] = "\\0";
      ESCAPE_SEQUENCES[7] = "\\a";
      ESCAPE_SEQUENCES[8] = "\\b";
      ESCAPE_SEQUENCES[9] = "\\t";
      ESCAPE_SEQUENCES[10] = "\\n";
      ESCAPE_SEQUENCES[11] = "\\v";
      ESCAPE_SEQUENCES[12] = "\\f";
      ESCAPE_SEQUENCES[13] = "\\r";
      ESCAPE_SEQUENCES[27] = "\\e";
      ESCAPE_SEQUENCES[34] = '\\"';
      ESCAPE_SEQUENCES[92] = "\\\\";
      ESCAPE_SEQUENCES[133] = "\\N";
      ESCAPE_SEQUENCES[160] = "\\_";
      ESCAPE_SEQUENCES[8232] = "\\L";
      ESCAPE_SEQUENCES[8233] = "\\P";
      var DEPRECATED_BOOLEANS_SYNTAX = [
        "y",
        "Y",
        "yes",
        "Yes",
        "YES",
        "on",
        "On",
        "ON",
        "n",
        "N",
        "no",
        "No",
        "NO",
        "off",
        "Off",
        "OFF"
      ];
      function compileStyleMap(schema, map) {
        var result, keys, index2, length, tag, style, type;
        if (map === null)
          return {};
        result = {};
        keys = Object.keys(map);
        for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
          tag = keys[index2];
          style = String(map[tag]);
          if (tag.slice(0, 2) === "!!") {
            tag = "tag:yaml.org,2002:" + tag.slice(2);
          }
          type = schema.compiledTypeMap["fallback"][tag];
          if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
          }
          result[tag] = style;
        }
        return result;
      }
      function encodeHex(character) {
        var string, handle, length;
        string = character.toString(16).toUpperCase();
        if (character <= 255) {
          handle = "x";
          length = 2;
        } else if (character <= 65535) {
          handle = "u";
          length = 4;
        } else if (character <= 4294967295) {
          handle = "U";
          length = 8;
        } else {
          throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
        }
        return "\\" + handle + common.repeat("0", length - string.length) + string;
      }
      function State(options2) {
        this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
        this.indent = Math.max(1, options2["indent"] || 2);
        this.noArrayIndent = options2["noArrayIndent"] || false;
        this.skipInvalid = options2["skipInvalid"] || false;
        this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
        this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
        this.sortKeys = options2["sortKeys"] || false;
        this.lineWidth = options2["lineWidth"] || 80;
        this.noRefs = options2["noRefs"] || false;
        this.noCompatMode = options2["noCompatMode"] || false;
        this.condenseFlow = options2["condenseFlow"] || false;
        this.implicitTypes = this.schema.compiledImplicit;
        this.explicitTypes = this.schema.compiledExplicit;
        this.tag = null;
        this.result = "";
        this.duplicates = [];
        this.usedDuplicates = null;
      }
      function indentString(string, spaces) {
        var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
        while (position < length) {
          next = string.indexOf("\n", position);
          if (next === -1) {
            line = string.slice(position);
            position = length;
          } else {
            line = string.slice(position, next + 1);
            position = next + 1;
          }
          if (line.length && line !== "\n")
            result += ind;
          result += line;
        }
        return result;
      }
      function generateNextLine(state, level) {
        return "\n" + common.repeat(" ", state.indent * level);
      }
      function testImplicitResolving(state, str2) {
        var index2, length, type;
        for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
          type = state.implicitTypes[index2];
          if (type.resolve(str2)) {
            return true;
          }
        }
        return false;
      }
      function isWhitespace(c) {
        return c === CHAR_SPACE || c === CHAR_TAB;
      }
      function isPrintable(c) {
        return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
      }
      function isNsChar(c) {
        return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
      }
      function isPlainSafe(c, prev) {
        return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
      }
      function isPlainSafeFirst(c) {
        return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
      }
      function needIndentIndicator(string) {
        var leadingSpaceRe = /^\n* /;
        return leadingSpaceRe.test(string);
      }
      var STYLE_PLAIN = 1;
      var STYLE_SINGLE = 2;
      var STYLE_LITERAL = 3;
      var STYLE_FOLDED = 4;
      var STYLE_DOUBLE = 5;
      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
        var i;
        var char, prev_char;
        var hasLineBreak = false;
        var hasFoldableLine = false;
        var shouldTrackWidth = lineWidth !== -1;
        var previousLineBreak = -1;
        var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
        if (singleLineOnly) {
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (!isPrintable(char)) {
              return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
          }
        } else {
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (char === CHAR_LINE_FEED) {
              hasLineBreak = true;
              if (shouldTrackWidth) {
                hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                previousLineBreak = i;
              }
            } else if (!isPrintable(char)) {
              return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
          }
          hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
        }
        if (!hasLineBreak && !hasFoldableLine) {
          return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
        }
        if (indentPerLevel > 9 && needIndentIndicator(string)) {
          return STYLE_DOUBLE;
        }
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      function writeScalar(state, string, level, iskey) {
        state.dump = function() {
          if (string.length === 0) {
            return "''";
          }
          if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
            return "'" + string + "'";
          }
          var indent = state.indent * Math.max(1, level);
          var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
          var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
          function testAmbiguity(string2) {
            return testImplicitResolving(state, string2);
          }
          switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
            case STYLE_PLAIN:
              return string;
            case STYLE_SINGLE:
              return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
              return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
              return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"';
            default:
              throw new YAMLException("impossible error: invalid scalar style");
          }
        }();
      }
      function blockHeader(string, indentPerLevel) {
        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
        var clip = string[string.length - 1] === "\n";
        var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
        var chomp = keep ? "+" : clip ? "" : "-";
        return indentIndicator + chomp + "\n";
      }
      function dropEndingNewline(string) {
        return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
      }
      function foldString(string, width) {
        var lineRe = /(\n+)([^\n]*)/g;
        var result = function() {
          var nextLF = string.indexOf("\n");
          nextLF = nextLF !== -1 ? nextLF : string.length;
          lineRe.lastIndex = nextLF;
          return foldLine(string.slice(0, nextLF), width);
        }();
        var prevMoreIndented = string[0] === "\n" || string[0] === " ";
        var moreIndented;
        var match;
        while (match = lineRe.exec(string)) {
          var prefix = match[1], line = match[2];
          moreIndented = line[0] === " ";
          result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
          prevMoreIndented = moreIndented;
        }
        return result;
      }
      function foldLine(line, width) {
        if (line === "" || line[0] === " ")
          return line;
        var breakRe = / [^ ]/g;
        var match;
        var start = 0, end, curr = 0, next = 0;
        var result = "";
        while (match = breakRe.exec(line)) {
          next = match.index;
          if (next - start > width) {
            end = curr > start ? curr : next;
            result += "\n" + line.slice(start, end);
            start = end + 1;
          }
          curr = next;
        }
        result += "\n";
        if (line.length - start > width && curr > start) {
          result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
        } else {
          result += line.slice(start);
        }
        return result.slice(1);
      }
      function escapeString(string) {
        var result = "";
        var char, nextChar;
        var escapeSeq;
        for (var i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char >= 55296 && char <= 56319) {
            nextChar = string.charCodeAt(i + 1);
            if (nextChar >= 56320 && nextChar <= 57343) {
              result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
              i++;
              continue;
            }
          }
          escapeSeq = ESCAPE_SEQUENCES[char];
          result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
        }
        return result;
      }
      function writeFlowSequence(state, level, object) {
        var _result = "", _tag = state.tag, index2, length;
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          if (writeNode(state, level, object[index2], false, false)) {
            if (index2 !== 0)
              _result += "," + (!state.condenseFlow ? " " : "");
            _result += state.dump;
          }
        }
        state.tag = _tag;
        state.dump = "[" + _result + "]";
      }
      function writeBlockSequence(state, level, object, compact) {
        var _result = "", _tag = state.tag, index2, length;
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          if (writeNode(state, level + 1, object[index2], true, true)) {
            if (!compact || index2 !== 0) {
              _result += generateNextLine(state, level);
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              _result += "-";
            } else {
              _result += "- ";
            }
            _result += state.dump;
          }
        }
        state.tag = _tag;
        state.dump = _result || "[]";
      }
      function writeFlowMapping(state, level, object) {
        var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          pairBuffer = "";
          if (index2 !== 0)
            pairBuffer += ", ";
          if (state.condenseFlow)
            pairBuffer += '"';
          objectKey = objectKeyList[index2];
          objectValue = object[objectKey];
          if (!writeNode(state, level, objectKey, false, false)) {
            continue;
          }
          if (state.dump.length > 1024)
            pairBuffer += "? ";
          pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
          if (!writeNode(state, level, objectValue, false, false)) {
            continue;
          }
          pairBuffer += state.dump;
          _result += pairBuffer;
        }
        state.tag = _tag;
        state.dump = "{" + _result + "}";
      }
      function writeBlockMapping(state, level, object, compact) {
        var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
        if (state.sortKeys === true) {
          objectKeyList.sort();
        } else if (typeof state.sortKeys === "function") {
          objectKeyList.sort(state.sortKeys);
        } else if (state.sortKeys) {
          throw new YAMLException("sortKeys must be a boolean or a function");
        }
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          pairBuffer = "";
          if (!compact || index2 !== 0) {
            pairBuffer += generateNextLine(state, level);
          }
          objectKey = objectKeyList[index2];
          objectValue = object[objectKey];
          if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue;
          }
          explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
          if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += "?";
            } else {
              pairBuffer += "? ";
            }
          }
          pairBuffer += state.dump;
          if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
          }
          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue;
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ":";
          } else {
            pairBuffer += ": ";
          }
          pairBuffer += state.dump;
          _result += pairBuffer;
        }
        state.tag = _tag;
        state.dump = _result || "{}";
      }
      function detectType(state, object, explicit) {
        var _result, typeList, index2, length, type, style;
        typeList = explicit ? state.explicitTypes : state.implicitTypes;
        for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
          type = typeList[index2];
          if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : "?";
            if (type.represent) {
              style = state.styleMap[type.tag] || type.defaultStyle;
              if (_toString.call(type.represent) === "[object Function]") {
                _result = type.represent(object, style);
              } else if (_hasOwnProperty.call(type.represent, style)) {
                _result = type.represent[style](object, style);
              } else {
                throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
              }
              state.dump = _result;
            }
            return true;
          }
        }
        return false;
      }
      function writeNode(state, level, object, block, compact, iskey) {
        state.tag = null;
        state.dump = object;
        if (!detectType(state, object, false)) {
          detectType(state, object, true);
        }
        var type = _toString.call(state.dump);
        if (block) {
          block = state.flowLevel < 0 || state.flowLevel > level;
        }
        var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
        if (objectOrArray) {
          duplicateIndex = state.duplicates.indexOf(object);
          duplicate = duplicateIndex !== -1;
        }
        if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
          compact = false;
        }
        if (duplicate && state.usedDuplicates[duplicateIndex]) {
          state.dump = "*ref_" + duplicateIndex;
        } else {
          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
          }
          if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
              writeBlockMapping(state, level, state.dump, compact);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + state.dump;
              }
            } else {
              writeFlowMapping(state, level, state.dump);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + " " + state.dump;
              }
            }
          } else if (type === "[object Array]") {
            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
            if (block && state.dump.length !== 0) {
              writeBlockSequence(state, arrayLevel, state.dump, compact);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + state.dump;
              }
            } else {
              writeFlowSequence(state, arrayLevel, state.dump);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + " " + state.dump;
              }
            }
          } else if (type === "[object String]") {
            if (state.tag !== "?") {
              writeScalar(state, state.dump, level, iskey);
            }
          } else {
            if (state.skipInvalid)
              return false;
            throw new YAMLException("unacceptable kind of an object to dump " + type);
          }
          if (state.tag !== null && state.tag !== "?") {
            state.dump = "!<" + state.tag + "> " + state.dump;
          }
        }
        return true;
      }
      function getDuplicateReferences(object, state) {
        var objects = [], duplicatesIndexes = [], index2, length;
        inspectNode(object, objects, duplicatesIndexes);
        for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
          state.duplicates.push(objects[duplicatesIndexes[index2]]);
        }
        state.usedDuplicates = new Array(length);
      }
      function inspectNode(object, objects, duplicatesIndexes) {
        var objectKeyList, index2, length;
        if (object !== null && typeof object === "object") {
          index2 = objects.indexOf(object);
          if (index2 !== -1) {
            if (duplicatesIndexes.indexOf(index2) === -1) {
              duplicatesIndexes.push(index2);
            }
          } else {
            objects.push(object);
            if (Array.isArray(object)) {
              for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
                inspectNode(object[index2], objects, duplicatesIndexes);
              }
            } else {
              objectKeyList = Object.keys(object);
              for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
                inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
              }
            }
          }
        }
      }
      function dump(input, options2) {
        options2 = options2 || {};
        var state = new State(options2);
        if (!state.noRefs)
          getDuplicateReferences(input, state);
        if (writeNode(state, 0, input, true, true))
          return state.dump + "\n";
        return "";
      }
      function safeDump(input, options2) {
        return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
      }
      module2.exports.dump = dump;
      module2.exports.safeDump = safeDump;
    }
  });

  // node_modules/js-yaml/lib/js-yaml.js
  var require_js_yaml = __commonJS({
    "node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
      "use strict";
      var loader = require_loader();
      var dumper = require_dumper();
      function deprecated(name) {
        return function() {
          throw new Error("Function " + name + " is deprecated and cannot be used.");
        };
      }
      module2.exports.Type = require_type();
      module2.exports.Schema = require_schema();
      module2.exports.FAILSAFE_SCHEMA = require_failsafe();
      module2.exports.JSON_SCHEMA = require_json();
      module2.exports.CORE_SCHEMA = require_core();
      module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
      module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
      module2.exports.load = loader.load;
      module2.exports.loadAll = loader.loadAll;
      module2.exports.safeLoad = loader.safeLoad;
      module2.exports.safeLoadAll = loader.safeLoadAll;
      module2.exports.dump = dumper.dump;
      module2.exports.safeDump = dumper.safeDump;
      module2.exports.YAMLException = require_exception();
      module2.exports.MINIMAL_SCHEMA = require_failsafe();
      module2.exports.SAFE_SCHEMA = require_default_safe();
      module2.exports.DEFAULT_SCHEMA = require_default_full();
      module2.exports.scan = deprecated("scan");
      module2.exports.parse = deprecated("parse");
      module2.exports.compose = deprecated("compose");
      module2.exports.addConstructor = deprecated("addConstructor");
    }
  });

  // node_modules/js-yaml/index.js
  var require_js_yaml2 = __commonJS({
    "node_modules/js-yaml/index.js"(exports2, module2) {
      "use strict";
      var yaml2 = require_js_yaml();
      module2.exports = yaml2;
    }
  });

  // node_modules/gray-matter/lib/engines.js
  var require_engines = __commonJS({
    "node_modules/gray-matter/lib/engines.js"(exports, module) {
      "use strict";
      var yaml = require_js_yaml2();
      var engines = exports = module.exports;
      engines.yaml = {
        parse: yaml.safeLoad.bind(yaml),
        stringify: yaml.safeDump.bind(yaml)
      };
      engines.json = {
        parse: JSON.parse.bind(JSON),
        stringify: function(obj, options2) {
          const opts = Object.assign({ replacer: null, space: 2 }, options2);
          return JSON.stringify(obj, opts.replacer, opts.space);
        }
      };
      engines.javascript = {
        parse: function parse(str, options, wrap) {
          try {
            if (wrap !== false) {
              str = "(function() {\nreturn " + str.trim() + ";\n}());";
            }
            return eval(str) || {};
          } catch (err) {
            if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
              return parse(str, options, false);
            }
            throw new SyntaxError(err);
          }
        },
        stringify: function() {
          throw new Error("stringifying JavaScript is not supported");
        }
      };
    }
  });

  // node_modules/strip-bom-string/index.js
  var require_strip_bom_string = __commonJS({
    "node_modules/strip-bom-string/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function(str2) {
        if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
          return str2.slice(1);
        }
        return str2;
      };
    }
  });

  // node_modules/gray-matter/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/gray-matter/lib/utils.js"(exports2) {
      "use strict";
      var stripBom = require_strip_bom_string();
      var typeOf = require_kind_of();
      exports2.define = function(obj, key, val) {
        Reflect.defineProperty(obj, key, {
          enumerable: false,
          configurable: true,
          writable: true,
          value: val
        });
      };
      exports2.isBuffer = function(val) {
        return typeOf(val) === "buffer";
      };
      exports2.isObject = function(val) {
        return typeOf(val) === "object";
      };
      exports2.toBuffer = function(input) {
        return typeof input === "string" ? Buffer.from(input) : input;
      };
      exports2.toString = function(input) {
        if (exports2.isBuffer(input))
          return stripBom(String(input));
        if (typeof input !== "string") {
          throw new TypeError("expected input to be a string or buffer");
        }
        return stripBom(input);
      };
      exports2.arrayify = function(val) {
        return val ? Array.isArray(val) ? val : [val] : [];
      };
      exports2.startsWith = function(str2, substr, len) {
        if (typeof len !== "number")
          len = substr.length;
        return str2.slice(0, len) === substr;
      };
    }
  });

  // node_modules/gray-matter/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/gray-matter/lib/defaults.js"(exports2, module2) {
      "use strict";
      var engines2 = require_engines();
      var utils = require_utils();
      module2.exports = function(options2) {
        const opts = Object.assign({}, options2);
        opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
        if (opts.delimiters.length === 1) {
          opts.delimiters.push(opts.delimiters[0]);
        }
        opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
        opts.engines = Object.assign({}, engines2, opts.parsers, opts.engines);
        return opts;
      };
    }
  });

  // node_modules/gray-matter/lib/engine.js
  var require_engine = __commonJS({
    "node_modules/gray-matter/lib/engine.js"(exports2, module2) {
      "use strict";
      module2.exports = function(name, options2) {
        let engine = options2.engines[name] || options2.engines[aliase(name)];
        if (typeof engine === "undefined") {
          throw new Error('gray-matter engine "' + name + '" is not registered');
        }
        if (typeof engine === "function") {
          engine = { parse: engine };
        }
        return engine;
      };
      function aliase(name) {
        switch (name.toLowerCase()) {
          case "js":
          case "javascript":
            return "javascript";
          case "coffee":
          case "coffeescript":
          case "cson":
            return "coffee";
          case "yaml":
          case "yml":
            return "yaml";
          default: {
            return name;
          }
        }
      }
    }
  });

  // node_modules/gray-matter/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/gray-matter/lib/stringify.js"(exports2, module2) {
      "use strict";
      var typeOf = require_kind_of();
      var getEngine = require_engine();
      var defaults = require_defaults();
      module2.exports = function(file, data, options2) {
        if (data == null && options2 == null) {
          switch (typeOf(file)) {
            case "object":
              data = file.data;
              options2 = {};
              break;
            case "string":
              return file;
            default: {
              throw new TypeError("expected file to be a string or object");
            }
          }
        }
        const str2 = file.content;
        const opts = defaults(options2);
        if (data == null) {
          if (!opts.data)
            return file;
          data = opts.data;
        }
        const language = file.language || opts.language;
        const engine = getEngine(language, opts);
        if (typeof engine.stringify !== "function") {
          throw new TypeError('expected "' + language + '.stringify" to be a function');
        }
        data = Object.assign({}, file.data, data);
        const open = opts.delimiters[0];
        const close = opts.delimiters[1];
        const matter2 = engine.stringify(data, options2).trim();
        let buf = "";
        if (matter2 !== "{}") {
          buf = newline(open) + newline(matter2) + newline(close);
        }
        if (typeof file.excerpt === "string" && file.excerpt !== "") {
          if (str2.indexOf(file.excerpt.trim()) === -1) {
            buf += newline(file.excerpt) + newline(close);
          }
        }
        return buf + newline(str2);
      };
      function newline(str2) {
        return str2.slice(-1) !== "\n" ? str2 + "\n" : str2;
      }
    }
  });

  // node_modules/gray-matter/lib/excerpt.js
  var require_excerpt = __commonJS({
    "node_modules/gray-matter/lib/excerpt.js"(exports2, module2) {
      "use strict";
      var defaults = require_defaults();
      module2.exports = function(file, options2) {
        const opts = defaults(options2);
        if (file.data == null) {
          file.data = {};
        }
        if (typeof opts.excerpt === "function") {
          return opts.excerpt(file, opts);
        }
        const sep = file.data.excerpt_separator || opts.excerpt_separator;
        if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
          return file;
        }
        const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
        const idx = file.content.indexOf(delimiter);
        if (idx !== -1) {
          file.excerpt = file.content.slice(0, idx);
        }
        return file;
      };
    }
  });

  // node_modules/gray-matter/lib/to-file.js
  var require_to_file = __commonJS({
    "node_modules/gray-matter/lib/to-file.js"(exports2, module2) {
      "use strict";
      var typeOf = require_kind_of();
      var stringify2 = require_stringify();
      var utils = require_utils();
      module2.exports = function(file) {
        if (typeOf(file) !== "object") {
          file = { content: file };
        }
        if (typeOf(file.data) !== "object") {
          file.data = {};
        }
        if (file.contents && file.content == null) {
          file.content = file.contents;
        }
        utils.define(file, "orig", utils.toBuffer(file.content));
        utils.define(file, "language", file.language || "");
        utils.define(file, "matter", file.matter || "");
        utils.define(file, "stringify", function(data, options2) {
          if (options2 && options2.language) {
            file.language = options2.language;
          }
          return stringify2(file, data, options2);
        });
        file.content = utils.toString(file.content);
        file.isEmpty = false;
        file.excerpt = "";
        return file;
      };
    }
  });

  // node_modules/gray-matter/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/gray-matter/lib/parse.js"(exports2, module2) {
      "use strict";
      var getEngine = require_engine();
      var defaults = require_defaults();
      module2.exports = function(language, str2, options2) {
        const opts = defaults(options2);
        const engine = getEngine(language, opts);
        if (typeof engine.parse !== "function") {
          throw new TypeError('expected "' + language + '.parse" to be a function');
        }
        return engine.parse(str2, opts);
      };
    }
  });

  // node_modules/gray-matter/index.js
  var require_gray_matter = __commonJS({
    "node_modules/gray-matter/index.js"(exports2, module2) {
      "use strict";
      var fs = __require("fs");
      var sections = require_section_matter();
      var defaults = require_defaults();
      var stringify2 = require_stringify();
      var excerpt = require_excerpt();
      var engines2 = require_engines();
      var toFile = require_to_file();
      var parse2 = require_parse();
      var utils = require_utils();
      function matter2(input, options2) {
        if (input === "") {
          return { data: {}, content: input, excerpt: "", orig: input };
        }
        let file = toFile(input);
        const cached = matter2.cache[file.content];
        if (!options2) {
          if (cached) {
            file = Object.assign({}, cached);
            file.orig = cached.orig;
            return file;
          }
          matter2.cache[file.content] = file;
        }
        return parseMatter(file, options2);
      }
      function parseMatter(file, options2) {
        const opts = defaults(options2);
        const open = opts.delimiters[0];
        const close = "\n" + opts.delimiters[1];
        let str2 = file.content;
        if (opts.language) {
          file.language = opts.language;
        }
        const openLen = open.length;
        if (!utils.startsWith(str2, open, openLen)) {
          excerpt(file, opts);
          return file;
        }
        if (str2.charAt(openLen) === open.slice(-1)) {
          return file;
        }
        str2 = str2.slice(openLen);
        const len = str2.length;
        const language = matter2.language(str2, opts);
        if (language.name) {
          file.language = language.name;
          str2 = str2.slice(language.raw.length);
        }
        let closeIndex = str2.indexOf(close);
        if (closeIndex === -1) {
          closeIndex = len;
        }
        file.matter = str2.slice(0, closeIndex);
        const block = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
        if (block === "") {
          file.isEmpty = true;
          file.empty = file.content;
          file.data = {};
        } else {
          file.data = parse2(file.language, file.matter, opts);
        }
        if (closeIndex === len) {
          file.content = "";
        } else {
          file.content = str2.slice(closeIndex + close.length);
          if (file.content[0] === "\r") {
            file.content = file.content.slice(1);
          }
          if (file.content[0] === "\n") {
            file.content = file.content.slice(1);
          }
        }
        excerpt(file, opts);
        if (opts.sections === true || typeof opts.section === "function") {
          sections(file, opts.section);
        }
        return file;
      }
      matter2.engines = engines2;
      matter2.stringify = function(file, data, options2) {
        if (typeof file === "string")
          file = matter2(file, options2);
        return stringify2(file, data, options2);
      };
      matter2.read = function(filepath, options2) {
        const str2 = fs.readFileSync(filepath, "utf8");
        const file = matter2(str2, options2);
        file.path = filepath;
        return file;
      };
      matter2.test = function(str2, options2) {
        return utils.startsWith(str2, defaults(options2).delimiters[0]);
      };
      matter2.language = function(str2, options2) {
        const opts = defaults(options2);
        const open = opts.delimiters[0];
        if (matter2.test(str2)) {
          str2 = str2.slice(open.length);
        }
        const language = str2.slice(0, str2.search(/\r?\n/));
        return {
          raw: language,
          name: language ? language.trim() : ""
        };
      };
      matter2.cache = {};
      matter2.clearCache = function() {
        matter2.cache = {};
      };
      module2.exports = matter2;
    }
  });

  // src/foundry/storage-diff.ts
  function compareStorageLayouts(layoutBefore, layoutAfter) {
    const layoutForComparisonBefore = preformatStorageLayout(layoutBefore);
    const layoutForComparisonAfter = preformatStorageLayout(layoutAfter);
    const comparison = compareStorageArrays(
      layoutForComparisonBefore,
      layoutForComparisonAfter
    );
    const md = generateMarkdownOutput(comparison);
    return md;
  }
  function preformatStorageLayout(json) {
    return json.storage.map((item) => ({
      label: item.label,
      offset: item.offset,
      slot: item.slot,
      type: json.types[item.type].label,
      numberOfBytes: json.types[item.type].numberOfBytes
    }));
  }
  function compareStorageArrays(oldArray, newArray) {
    const changes = [];
    const oldMap = new Map(
      oldArray.map((item) => [item.slot + "-" + item.offset, item])
    );
    const newMap = new Map(
      newArray.map((item) => [item.slot + "-" + item.offset, item])
    );
    oldArray.forEach((oldItem) => {
      const newItem = newMap.get(oldItem.slot + "-" + oldItem.offset);
      if (!newItem) {
        changes.push({ ...oldItem, status: "removed" });
      } else if (isDifferent(oldItem, newItem)) {
        changes.push({ ...oldItem, status: "removed" });
        changes.push({ ...newItem, status: "added" });
      } else {
        changes.push({ ...newItem, status: "unchanged" });
      }
    });
    newArray.forEach((newItem) => {
      if (!oldMap.has(newItem.slot + "-" + newItem.offset)) {
        changes.push({ ...newItem, status: "added" });
      }
    });
    changes.sort((a, b) => {
      if (a.slot === b.slot) {
        return a.offset - b.offset;
      }
      return a.slot.localeCompare(b.slot);
    });
    return changes;
  }
  function isDifferent(item1, item2) {
    return item1.offset !== item2.offset || item1.slot !== item2.slot || item1.type !== item2.type || item1.numberOfBytes !== item2.numberOfBytes;
  }
  function generateMarkdownOutput(items) {
    const columnWidths = {
      name: Math.max(...items.map((item) => item.label.length), "Label".length),
      offset: "Offset".length,
      slot: "Slot".length,
      type: Math.max(...items.map((item) => item.type.length), "Type".length),
      numberOfBytes: "Bytes".length
    };
    let markdownTable = "```diff\n";
    markdownTable += ` | ${"Label".padEnd(
      columnWidths.name,
      " "
    )} | ${"Offset".padEnd(columnWidths.offset, " ")} | ${"Slot".padEnd(
      columnWidths.slot,
      " "
    )} | ${"Type".padEnd(columnWidths.type, " ")} | ${"Bytes".padEnd(
      columnWidths.numberOfBytes,
      " "
    )} |
`;
    markdownTable += ` |${"-".repeat(columnWidths.name + 2)}|${"-".repeat(
      columnWidths.offset + 2
    )}|${"-".repeat(columnWidths.slot + 2)}|${"-".repeat(
      columnWidths.type + 2
    )}|${"-".repeat(columnWidths.numberOfBytes + 2)}||
`;
    items.forEach((item) => {
      const sign = item.status === "added" ? "+" : item.status === "removed" ? "-" : " ";
      const row = `${sign}| ${item.label.padEnd(
        columnWidths.name,
        " "
      )} | ${item.offset.toString().padEnd(columnWidths.offset, " ")} | ${item.slot.padEnd(
        columnWidths.slot,
        " "
      )} | ${item.type.padEnd(
        columnWidths.type,
        " "
      )} | ${item.numberOfBytes.padEnd(columnWidths.numberOfBytes, " ")} |
`;
      markdownTable += row;
    });
    markdownTable += "```";
    return markdownTable;
  }

  // node_modules/viem/_esm/utils/chain/defineChain.js
  function defineChain(chain) {
    return {
      formatters: void 0,
      fees: void 0,
      serializers: void 0,
      ...chain
    };
  }

  // node_modules/viem/_esm/chains/definitions/arbitrum.js
  var arbitrum = /* @__PURE__ */ defineChain({
    id: 42161,
    name: "Arbitrum One",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://arb1.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://arbiscan.io",
        apiUrl: "https://api.arbiscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7654707
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/arbitrumGoerli.js
  var arbitrumGoerli = /* @__PURE__ */ defineChain({
    id: 421613,
    name: "Arbitrum Goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://goerli.arbiscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 88114
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
  var arbitrumSepolia = /* @__PURE__ */ defineChain({
    id: 421614,
    name: "Arbitrum Sepolia",
    nativeCurrency: {
      name: "Arbitrum Sepolia Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://sepolia-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      default: {
        name: "Arbiscan",
        url: "https://sepolia.arbiscan.io",
        apiUrl: "https://sepolia.arbiscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 81930
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/definitions/avalanche.js
  var avalanche = /* @__PURE__ */ defineChain({
    id: 43114,
    name: "Avalanche",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "SnowScan",
        url: "https://snowscan.xyz",
        apiUrl: "https://api.snowscan.xyz/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 11907934
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/avalancheFuji.js
  var avalancheFuji = /* @__PURE__ */ defineChain({
    id: 43113,
    name: "Avalanche Fuji",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche Fuji",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "SnowTrace",
        url: "https://testnet.snowtrace.io",
        apiUrl: "https://api-testnet.snowtrace.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7096959
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/opStack/contracts.js
  var contracts = {
    gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
    l1Block: { address: "0x4200000000000000000000000000000000000015" },
    l2CrossDomainMessenger: {
      address: "0x4200000000000000000000000000000000000007"
    },
    l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
    l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
    l2ToL1MessagePasser: {
      address: "0x4200000000000000000000000000000000000016"
    }
  };

  // node_modules/viem/_esm/chains/opStack/formatters.js
  init_fromHex();

  // node_modules/viem/_esm/utils/formatters/block.js
  init_formatter();

  // node_modules/viem/_esm/utils/formatters/transaction.js
  init_fromHex();
  init_formatter();
  var transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559",
    "0x3": "eip4844"
  };
  function formatTransaction(transaction) {
    const transaction_ = {
      ...transaction,
      blockHash: transaction.blockHash ? transaction.blockHash : null,
      blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
      chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
      gas: transaction.gas ? BigInt(transaction.gas) : void 0,
      gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
      maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
      maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
      nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
      to: transaction.to ? transaction.to : null,
      transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
      type: transaction.type ? transactionType[transaction.type] : void 0,
      typeHex: transaction.type ? transaction.type : void 0,
      value: transaction.value ? BigInt(transaction.value) : void 0,
      v: transaction.v ? BigInt(transaction.v) : void 0
    };
    transaction_.yParity = (() => {
      if (transaction.yParity)
        return Number(transaction.yParity);
      if (typeof transaction_.v === "bigint") {
        if (transaction_.v === 0n || transaction_.v === 27n)
          return 0;
        if (transaction_.v === 1n || transaction_.v === 28n)
          return 1;
        if (transaction_.v >= 35n)
          return transaction_.v % 2n === 0n ? 1 : 0;
      }
      return void 0;
    })();
    if (transaction_.type === "legacy") {
      delete transaction_.accessList;
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
      delete transaction_.yParity;
    }
    if (transaction_.type === "eip2930") {
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
    }
    if (transaction_.type === "eip1559") {
      delete transaction_.maxFeePerBlobGas;
    }
    return transaction_;
  }
  var defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);

  // node_modules/viem/_esm/utils/formatters/block.js
  function formatBlock(block) {
    const transactions = block.transactions?.map((transaction) => {
      if (typeof transaction === "string")
        return transaction;
      return formatTransaction(transaction);
    });
    return {
      ...block,
      baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
      blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
      difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
      excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
      gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
      gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
      hash: block.hash ? block.hash : null,
      logsBloom: block.logsBloom ? block.logsBloom : null,
      nonce: block.nonce ? block.nonce : null,
      number: block.number ? BigInt(block.number) : null,
      size: block.size ? BigInt(block.size) : void 0,
      timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
      transactions,
      totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
  }
  var defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);

  // node_modules/viem/_esm/utils/formatters/transactionReceipt.js
  init_fromHex();
  init_formatter();

  // node_modules/viem/_esm/utils/formatters/log.js
  function formatLog(log, { args, eventName } = {}) {
    return {
      ...log,
      blockHash: log.blockHash ? log.blockHash : null,
      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
      logIndex: log.logIndex ? Number(log.logIndex) : null,
      transactionHash: log.transactionHash ? log.transactionHash : null,
      transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
      ...eventName ? { args, eventName } : {}
    };
  }

  // node_modules/viem/_esm/utils/formatters/transactionReceipt.js
  var statuses = {
    "0x0": "reverted",
    "0x1": "success"
  };
  function formatTransactionReceipt(transactionReceipt) {
    const receipt = {
      ...transactionReceipt,
      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
      to: transactionReceipt.to ? transactionReceipt.to : null,
      transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
      status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
      type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
    };
    if (transactionReceipt.blobGasPrice)
      receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
    if (transactionReceipt.blobGasUsed)
      receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
    return receipt;
  }
  var defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt);

  // node_modules/viem/_esm/chains/opStack/formatters.js
  var formatters = {
    block: /* @__PURE__ */ defineBlock({
      format(args) {
        const transactions = args.transactions?.map((transaction) => {
          if (typeof transaction === "string")
            return transaction;
          const formatted = formatTransaction(transaction);
          if (formatted.typeHex === "0x7e") {
            formatted.isSystemTx = transaction.isSystemTx;
            formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
            formatted.sourceHash = transaction.sourceHash;
            formatted.type = "deposit";
          }
          return formatted;
        });
        return {
          transactions,
          stateRoot: args.stateRoot
        };
      }
    }),
    transaction: /* @__PURE__ */ defineTransaction({
      format(args) {
        const transaction = {};
        if (args.type === "0x7e") {
          transaction.isSystemTx = args.isSystemTx;
          transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
          transaction.sourceHash = args.sourceHash;
          transaction.type = "deposit";
        }
        return transaction;
      }
    }),
    transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
      format(args) {
        return {
          l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
          l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
          l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
          l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
        };
      }
    })
  };

  // node_modules/viem/_esm/chains/opStack/serializers.js
  init_address();
  init_isAddress();
  init_concat();
  init_toHex();

  // node_modules/viem/_esm/index.js
  init_exports();

  // node_modules/viem/_esm/utils/abi/encodeEventTopics.js
  init_abi();

  // node_modules/viem/_esm/errors/log.js
  init_base();
  var FilterTypeNotSupportedError = class extends BaseError {
    constructor(type) {
      super(`Filter type "${type}" is not supported.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FilterTypeNotSupportedError"
      });
    }
  };

  // node_modules/viem/_esm/utils/abi/encodeEventTopics.js
  init_toBytes();
  init_keccak256();
  init_toEventSelector();
  init_encodeAbiParameters();
  init_formatAbiItem2();
  init_getAbiItem();
  var docsPath = "/docs/contract/encodeEventTopics";
  function encodeEventTopics(parameters) {
    const { abi, eventName, args } = parameters;
    let abiItem = abi[0];
    if (eventName) {
      const item = getAbiItem({ abi, name: eventName });
      if (!item)
        throw new AbiEventNotFoundError(eventName, { docsPath });
      abiItem = item;
    }
    if (abiItem.type !== "event")
      throw new AbiEventNotFoundError(void 0, { docsPath });
    const definition = formatAbiItem2(abiItem);
    const signature = toEventSelector(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
      const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
      const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
      if (args_.length > 0) {
        topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
      }
    }
    return [signature, ...topics];
  }
  function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes")
      return keccak256(toBytes(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      throw new FilterTypeNotSupportedError(param.type);
    return encodeAbiParameters([param], [value]);
  }

  // node_modules/viem/_esm/errors/block.js
  init_base();
  var BlockNotFoundError = class extends BaseError {
    constructor({ blockHash, blockNumber }) {
      let identifier = "Block";
      if (blockHash)
        identifier = `Block at hash "${blockHash}"`;
      if (blockNumber)
        identifier = `Block at number "${blockNumber}"`;
      super(`${identifier} could not be found.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BlockNotFoundError"
      });
    }
  };

  // node_modules/viem/_esm/actions/public/getBlock.js
  init_toHex();
  async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
    const blockTag = blockTag_ ?? "latest";
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let block = null;
    if (blockHash) {
      block = await client.request({
        method: "eth_getBlockByHash",
        params: [blockHash, includeTransactions]
      });
    } else {
      block = await client.request({
        method: "eth_getBlockByNumber",
        params: [blockNumberHex || blockTag, includeTransactions]
      });
    }
    if (!block)
      throw new BlockNotFoundError({ blockHash, blockNumber });
    const format = client.chain?.formatters?.block?.format || formatBlock;
    return format(block);
  }

  // node_modules/viem/_esm/utils/transaction/getTransactionType.js
  init_transaction();
  function getTransactionType(transaction) {
    if (transaction.type)
      return transaction.type;
    if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
      return "eip1559";
    if (typeof transaction.gasPrice !== "undefined") {
      if (typeof transaction.accessList !== "undefined")
        return "eip2930";
      return "legacy";
    }
    throw new InvalidSerializableTransactionError({ transaction });
  }

  // node_modules/viem/_esm/utils/abi/decodeEventLog.js
  init_abi();
  init_size();
  init_toEventSelector();
  init_cursor();
  init_decodeAbiParameters();
  init_formatAbiItem2();
  var docsPath2 = "/docs/contract/decodeEventLog";
  function decodeEventLog(parameters) {
    const { abi, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature)
      throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath2 });
    const abiItem = abi.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
    if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
      throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath2 });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
    let args = isUnnamed ? [] : {};
    const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
    for (let i = 0; i < indexedInputs.length; i++) {
      const param = indexedInputs[i];
      const topic = argTopics[i];
      if (!topic)
        throw new DecodeLogTopicsMismatch({
          abiItem,
          param
        });
      args[param.name || i] = decodeTopic({ param, value: topic });
    }
    const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
      if (data && data !== "0x") {
        try {
          const decodedData = decodeAbiParameters(nonIndexedInputs, data);
          if (decodedData) {
            if (isUnnamed)
              args = [...args, ...decodedData];
            else {
              for (let i = 0; i < nonIndexedInputs.length; i++) {
                args[nonIndexedInputs[i].name] = decodedData[i];
              }
            }
          }
        } catch (err) {
          if (strict) {
            if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
              throw new DecodeLogDataMismatch({
                abiItem,
                data,
                params: nonIndexedInputs,
                size: size(data)
              });
            throw err;
          }
        }
      } else if (strict) {
        throw new DecodeLogDataMismatch({
          abiItem,
          data: "0x",
          params: nonIndexedInputs,
          size: 0
        });
      }
    }
    return {
      eventName: name,
      args: Object.values(args).length > 0 ? args : void 0
    };
  }
  function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      return value;
    const decodedArg = decodeAbiParameters([param], value) || [];
    return decodedArg[0];
  }

  // node_modules/viem/_esm/utils/abi/parseEventLogs.js
  function parseEventLogs({ abi, eventName, logs, strict = true }) {
    return logs.map((log) => {
      try {
        const event = decodeEventLog({
          ...log,
          abi,
          strict
        });
        if (eventName && !eventName.includes(event.eventName))
          return null;
        return { ...event, ...log };
      } catch (err) {
        let eventName2;
        let isUnnamed;
        if (err instanceof AbiEventSignatureNotFoundError)
          return null;
        if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
          if (strict)
            return null;
          eventName2 = err.abiItem.name;
          isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
        }
        return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
      }
    }).filter(Boolean);
  }

  // node_modules/viem/_esm/actions/public/getLogs.js
  init_toHex();
  async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [event] : void 0);
    let topics = [];
    if (events) {
      topics = [
        events.flatMap((event2) => encodeEventTopics({
          abi: [event2],
          eventName: event2.name,
          args
        }))
      ];
      if (event)
        topics = topics[0];
    }
    let logs;
    if (blockHash) {
      logs = await client.request({
        method: "eth_getLogs",
        params: [{ address, topics, blockHash }]
      });
    } else {
      logs = await client.request({
        method: "eth_getLogs",
        params: [
          {
            address,
            topics,
            fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
          }
        ]
      });
    }
    const formattedLogs = logs.map((log) => formatLog(log));
    if (!events)
      return formattedLogs;
    return parseEventLogs({
      abi: events,
      logs: formattedLogs,
      strict
    });
  }

  // node_modules/viem/_esm/utils/wait.js
  async function wait(time) {
    return new Promise((res) => setTimeout(res, time));
  }

  // node_modules/viem/_esm/utils/accounts.js
  init_parseAccount();

  // node_modules/viem/_esm/utils/uid.js
  var size2 = 256;
  var index = size2;
  var buffer;
  function uid(length = 11) {
    if (!buffer || index + length > size2 * 2) {
      buffer = "";
      index = 0;
      for (let i = 0; i < size2; i++) {
        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
      }
    }
    return buffer.substring(index, index++ + length);
  }

  // node_modules/viem/_esm/clients/createClient.js
  function createClient(parameters) {
    const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
    const chain = parameters.chain;
    const account = parameters.account ? parseAccount(parameters.account) : void 0;
    const { config, request, value } = parameters.transport({
      chain,
      pollingInterval
    });
    const transport = { ...config, ...value };
    const client = {
      account,
      batch,
      cacheTime,
      chain,
      key,
      name,
      pollingInterval,
      request,
      transport,
      type,
      uid: uid()
    };
    function extend(base2) {
      return (extendFn) => {
        const extended = extendFn(base2);
        for (const key2 in client)
          delete extended[key2];
        const combined = { ...base2, ...extended };
        return Object.assign(combined, { extend: extend(combined) });
      };
    }
    return Object.assign(client, { extend: extend(client) });
  }

  // node_modules/viem/_esm/utils/buildRequest.js
  init_base();
  init_request();
  init_rpc();

  // node_modules/viem/_esm/utils/promise/withRetry.js
  function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
    return new Promise((resolve, reject) => {
      const attemptRetry = async ({ count = 0 } = {}) => {
        const retry = async ({ error }) => {
          const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
          if (delay)
            await wait(delay);
          attemptRetry({ count: count + 1 });
        };
        try {
          const data = await fn();
          resolve(data);
        } catch (err) {
          if (count < retryCount && await shouldRetry2({ count, error: err }))
            return retry({ error: err });
          reject(err);
        }
      };
      attemptRetry();
    });
  }

  // node_modules/viem/_esm/utils/buildRequest.js
  function buildRequest(request, options2 = {}) {
    return async (args, overrideOptions = {}) => {
      const { retryDelay = 150, retryCount = 3 } = {
        ...options2,
        ...overrideOptions
      };
      return withRetry(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case ParseRpcError.code:
              throw new ParseRpcError(err);
            case InvalidRequestRpcError.code:
              throw new InvalidRequestRpcError(err);
            case MethodNotFoundRpcError.code:
              throw new MethodNotFoundRpcError(err);
            case InvalidParamsRpcError.code:
              throw new InvalidParamsRpcError(err);
            case InternalRpcError.code:
              throw new InternalRpcError(err);
            case InvalidInputRpcError.code:
              throw new InvalidInputRpcError(err);
            case ResourceNotFoundRpcError.code:
              throw new ResourceNotFoundRpcError(err);
            case ResourceUnavailableRpcError.code:
              throw new ResourceUnavailableRpcError(err);
            case TransactionRejectedRpcError.code:
              throw new TransactionRejectedRpcError(err);
            case MethodNotSupportedRpcError.code:
              throw new MethodNotSupportedRpcError(err);
            case LimitExceededRpcError.code:
              throw new LimitExceededRpcError(err);
            case JsonRpcVersionUnsupportedError.code:
              throw new JsonRpcVersionUnsupportedError(err);
            case UserRejectedRequestError.code:
              throw new UserRejectedRequestError(err);
            case UnauthorizedProviderError.code:
              throw new UnauthorizedProviderError(err);
            case UnsupportedProviderMethodError.code:
              throw new UnsupportedProviderMethodError(err);
            case ProviderDisconnectedError.code:
              throw new ProviderDisconnectedError(err);
            case ChainDisconnectedError.code:
              throw new ChainDisconnectedError(err);
            case SwitchChainError.code:
              throw new SwitchChainError(err);
            case 5e3:
              throw new UserRejectedRequestError(err);
            default:
              if (err_ instanceof BaseError)
                throw err_;
              throw new UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => shouldRetry(error)
      });
    };
  }
  function shouldRetry(error) {
    if ("code" in error && typeof error.code === "number") {
      if (error.code === -1)
        return true;
      if (error.code === LimitExceededRpcError.code)
        return true;
      if (error.code === InternalRpcError.code)
        return true;
      return false;
    }
    if (error instanceof HttpRequestError && error.status) {
      if (error.status === 403)
        return true;
      if (error.status === 408)
        return true;
      if (error.status === 413)
        return true;
      if (error.status === 429)
        return true;
      if (error.status === 500)
        return true;
      if (error.status === 502)
        return true;
      if (error.status === 503)
        return true;
      if (error.status === 504)
        return true;
      return false;
    }
    return true;
  }

  // node_modules/viem/_esm/clients/transports/createTransport.js
  function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    return {
      config: { key, name, request, retryCount, retryDelay, timeout, type },
      request: buildRequest(request, { retryCount, retryDelay }),
      value
    };
  }

  // node_modules/viem/_esm/clients/transports/http.js
  init_request();

  // node_modules/viem/_esm/errors/transport.js
  init_base();
  var UrlRequiredError = class extends BaseError {
    constructor() {
      super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
        docsPath: "/docs/clients/intro"
      });
    }
  };

  // node_modules/viem/_esm/clients/transports/http.js
  init_createBatchScheduler();

  // node_modules/viem/_esm/utils/rpc/http.js
  init_request();

  // node_modules/viem/_esm/utils/promise/withTimeout.js
  function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
    return new Promise((resolve, reject) => {
      ;
      (async () => {
        let timeoutId;
        try {
          const controller = new AbortController();
          if (timeout > 0) {
            timeoutId = setTimeout(() => {
              if (signal) {
                controller.abort();
              } else {
                reject(errorInstance);
              }
            }, timeout);
          }
          resolve(await fn({ signal: controller?.signal }));
        } catch (err) {
          if (err.name === "AbortError")
            reject(errorInstance);
          reject(err);
        } finally {
          clearTimeout(timeoutId);
        }
      })();
    });
  }

  // node_modules/viem/_esm/utils/rpc/http.js
  init_stringify();

  // node_modules/viem/_esm/utils/rpc/id.js
  function createIdStore() {
    return {
      current: 0,
      take() {
        return this.current++;
      },
      reset() {
        this.current = 0;
      }
    };
  }
  var idCache = /* @__PURE__ */ createIdStore();

  // node_modules/viem/_esm/utils/rpc/http.js
  function getHttpRpcClient(url, options2 = {}) {
    return {
      async request(params) {
        const { body, fetchOptions = {}, timeout = options2.timeout ?? 1e4 } = params;
        const { headers, method, signal: signal_ } = { ...options2.fetchOptions, ...fetchOptions };
        try {
          const response = await withTimeout(async ({ signal }) => {
            const response2 = await fetch(url, {
              ...fetchOptions,
              body: Array.isArray(body) ? stringify(body.map((body2) => ({
                jsonrpc: "2.0",
                id: body2.id ?? idCache.take(),
                ...body2
              }))) : stringify({
                jsonrpc: "2.0",
                id: body.id ?? idCache.take(),
                ...body
              }),
              headers: {
                ...headers,
                "Content-Type": "application/json"
              },
              method: method || "POST",
              signal: signal_ || (timeout > 0 ? signal : void 0)
            });
            return response2;
          }, {
            errorInstance: new TimeoutError({ body, url }),
            timeout,
            signal: true
          });
          let data;
          if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            data = await response.json();
          } else {
            data = await response.text();
          }
          if (!response.ok) {
            throw new HttpRequestError({
              body,
              details: stringify(data.error) || response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
          }
          return data;
        } catch (err) {
          if (err instanceof HttpRequestError)
            throw err;
          if (err instanceof TimeoutError)
            throw err;
          throw new HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
    };
  }

  // node_modules/viem/_esm/clients/transports/http.js
  function http(url, config = {}) {
    const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
      const retryCount = config.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.http[0];
      if (!url_)
        throw new UrlRequiredError();
      const rpcClient = getHttpRpcClient(url_, { fetchOptions, timeout });
      return createTransport({
        key,
        name,
        async request({ method, params }) {
          const body = { method, params };
          const { schedule } = createBatchScheduler({
            id: `${url}`,
            wait: wait2,
            shouldSplitBatch(requests) {
              return requests.length > batchSize;
            },
            fn: (body2) => rpcClient.request({
              body: body2
            }),
            sort: (a, b) => a.id - b.id
          });
          const fn = async (body2) => batch ? schedule(body2) : [
            await rpcClient.request({
              body: body2
            })
          ];
          const [{ error, result }] = await fn(body);
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: url_
            });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      }, {
        fetchOptions,
        url: url_
      });
    };
  }

  // node_modules/viem/_esm/actions/public/getBytecode.js
  init_toHex();
  async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const hex = await client.request({
      method: "eth_getCode",
      params: [address, blockNumberHex || blockTag]
    });
    if (hex === "0x")
      return void 0;
    return hex;
  }

  // node_modules/viem/_esm/utils/transaction/assertTransaction.js
  init_address();
  init_base();
  init_chain();
  init_node();
  init_isAddress();
  function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (gasPrice)
      throw new BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (typeof chainId !== "undefined" && chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
    if (accessList)
      throw new BaseError("`accessList` is not a valid Legacy Transaction attribute.");
  }

  // node_modules/viem/_esm/utils/transaction/serializeTransaction.js
  init_transaction();
  init_concat();
  init_trim();
  init_toHex();

  // node_modules/viem/_esm/utils/transaction/serializeAccessList.js
  init_address();
  init_transaction();
  init_isAddress();
  function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
      return [];
    const serializedAccessList = [];
    for (let i = 0; i < accessList.length; i++) {
      const { address, storageKeys } = accessList[i];
      for (let j = 0; j < storageKeys.length; j++) {
        if (storageKeys[j].length - 2 !== 64) {
          throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
        }
      }
      if (!isAddress(address, { strict: false })) {
        throw new InvalidAddressError({ address });
      }
      serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
  }

  // node_modules/viem/_esm/utils/transaction/serializeTransaction.js
  function serializeTransaction(transaction, signature) {
    const type = getTransactionType(transaction);
    if (type === "eip1559")
      return serializeTransactionEIP1559(transaction, signature);
    if (type === "eip2930")
      return serializeTransactionEIP2930(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
  }
  function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP1559(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList
    ];
    if (signature) {
      const yParity = (() => {
        if (signature.v === 0n)
          return "0x";
        if (signature.v === 1n)
          return toHex(1);
        return signature.v === 27n ? "0x" : toHex(1);
      })();
      serializedTransaction.push(yParity, trim(signature.r), trim(signature.s));
    }
    return concatHex([
      "0x02",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    assertTransactionEIP2930(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      gasPrice ? toHex(gasPrice) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList
    ];
    if (signature) {
      const yParity = (() => {
        if (signature.v === 0n)
          return "0x";
        if (signature.v === 1n)
          return toHex(1);
        return signature.v === 27n ? "0x" : toHex(1);
      })();
      serializedTransaction.push(yParity, trim(signature.r), trim(signature.s));
    }
    return concatHex([
      "0x01",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    assertTransactionLegacy(transaction);
    let serializedTransaction = [
      nonce ? toHex(nonce) : "0x",
      gasPrice ? toHex(gasPrice) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x"
    ];
    if (signature) {
      const v = (() => {
        if (signature.v >= 35n) {
          const inferredChainId = (signature.v - 35n) / 2n;
          if (inferredChainId > 0)
            return signature.v;
          return 27n + (signature.v === 35n ? 0n : 1n);
        }
        if (chainId > 0)
          return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        const v2 = 27n + (signature.v === 27n ? 0n : 1n);
        if (signature.v !== v2)
          throw new InvalidLegacyVError({ v: signature.v });
        return v2;
      })();
      serializedTransaction = [
        ...serializedTransaction,
        toHex(v),
        signature.r,
        signature.s
      ];
    } else if (chainId > 0) {
      serializedTransaction = [
        ...serializedTransaction,
        toHex(chainId),
        "0x",
        "0x"
      ];
    }
    return toRlp(serializedTransaction);
  }

  // node_modules/viem/_esm/index.js
  init_abi();
  init_base();
  init_encodeAbiParameters();
  init_toBytes();
  init_toHex();
  init_concat();
  init_fromHex();
  init_keccak256();
  init_pad();
  init_trim();

  // node_modules/viem/_esm/utils/encoding/toRlp.js
  init_cursor2();
  init_toBytes();
  init_toHex();
  function toRlp(bytes2, to = "hex") {
    const encodable = getEncodable(bytes2);
    const cursor = createCursor(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === "hex")
      return bytesToHex(cursor.bytes);
    return cursor.bytes;
  }
  function getEncodable(bytes2) {
    if (Array.isArray(bytes2))
      return getEncodableList(bytes2.map((x) => getEncodable(x)));
    return getEncodableBytes(bytes2);
  }
  function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (() => {
      if (bodyLength <= 55)
        return 1 + bodyLength;
      return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
      length,
      encode(cursor) {
        if (bodyLength <= 55) {
          cursor.pushByte(192 + bodyLength);
        } else {
          cursor.pushByte(192 + 55 + sizeOfBodyLength);
          if (sizeOfBodyLength === 1)
            cursor.pushUint8(bodyLength);
          else if (sizeOfBodyLength === 2)
            cursor.pushUint16(bodyLength);
          else if (sizeOfBodyLength === 3)
            cursor.pushUint24(bodyLength);
          else
            cursor.pushUint32(bodyLength);
        }
        for (const { encode } of list) {
          encode(cursor);
        }
      }
    };
  }
  function getEncodableBytes(bytesOrHex) {
    const bytes2 = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes2.length);
    const length = (() => {
      if (bytes2.length === 1 && bytes2[0] < 128)
        return 1;
      if (bytes2.length <= 55)
        return 1 + bytes2.length;
      return 1 + sizeOfBytesLength + bytes2.length;
    })();
    return {
      length,
      encode(cursor) {
        if (bytes2.length === 1 && bytes2[0] < 128) {
          cursor.pushBytes(bytes2);
        } else if (bytes2.length <= 55) {
          cursor.pushByte(128 + bytes2.length);
          cursor.pushBytes(bytes2);
        } else {
          cursor.pushByte(128 + 55 + sizeOfBytesLength);
          if (sizeOfBytesLength === 1)
            cursor.pushUint8(bytes2.length);
          else if (sizeOfBytesLength === 2)
            cursor.pushUint16(bytes2.length);
          else if (sizeOfBytesLength === 3)
            cursor.pushUint24(bytes2.length);
          else
            cursor.pushUint32(bytes2.length);
          cursor.pushBytes(bytes2);
        }
      }
    };
  }
  function getSizeOfLength(length) {
    if (length < 2 ** 8)
      return 1;
    if (length < 2 ** 16)
      return 2;
    if (length < 2 ** 24)
      return 3;
    if (length < 2 ** 32)
      return 4;
    throw new BaseError("Length is too large.");
  }

  // node_modules/viem/_esm/chains/opStack/serializers.js
  var serializeTransaction2 = (transaction, signature) => {
    if (isDeposit(transaction))
      return serializeTransactionDeposit(transaction);
    return serializeTransaction(transaction, signature);
  };
  var serializers = {
    transaction: serializeTransaction2
  };
  function serializeTransactionDeposit(transaction) {
    assertTransactionDeposit(transaction);
    const { sourceHash, data, from, gas, isSystemTx, mint, to, value } = transaction;
    const serializedTransaction = [
      sourceHash,
      from,
      to ?? "0x",
      mint ? toHex(mint) : "0x",
      value ? toHex(value) : "0x",
      gas ? toHex(gas) : "0x",
      isSystemTx ? "0x1" : "0x",
      data ?? "0x"
    ];
    return concatHex([
      "0x7e",
      toRlp(serializedTransaction)
    ]);
  }
  function isDeposit(transaction) {
    if (transaction.type === "deposit")
      return true;
    if (typeof transaction.sourceHash !== "undefined")
      return true;
    return false;
  }
  function assertTransactionDeposit(transaction) {
    const { from, to } = transaction;
    if (from && !isAddress(from))
      throw new InvalidAddressError({ address: from });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
  }

  // node_modules/viem/_esm/chains/opStack/chainConfig.js
  var chainConfig = {
    contracts,
    formatters,
    serializers
  };

  // node_modules/viem/_esm/chains/definitions/base.js
  var sourceId = 1;
  var base = /* @__PURE__ */ defineChain({
    ...chainConfig,
    id: 8453,
    name: "Base",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.base.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Basescan",
        url: "https://basescan.org",
        apiUrl: "https://api.basescan.org/api"
      }
    },
    contracts: {
      ...chainConfig.contracts,
      l2OutputOracle: {
        [sourceId]: {
          address: "0x56315b90c40730925ec5485cf004d835058518A0"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 5022
      },
      portal: {
        [sourceId]: {
          address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
          blockCreated: 17482143
        }
      },
      l1StandardBridge: {
        [sourceId]: {
          address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
          blockCreated: 17482143
        }
      }
    },
    sourceId
  });

  // node_modules/viem/_esm/chains/definitions/baseSepolia.js
  var sourceId2 = 11155111;
  var baseSepolia = /* @__PURE__ */ defineChain({
    ...chainConfig,
    id: 84532,
    network: "base-sepolia",
    name: "Base Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.base.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Basescan",
        url: "https://sepolia.basescan.org",
        apiUrl: "https://api-sepolia.basescan.org/api"
      }
    },
    contracts: {
      ...chainConfig.contracts,
      l2OutputOracle: {
        [sourceId2]: {
          address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
        }
      },
      portal: {
        [sourceId2]: {
          address: "0x49f53e41452c74589e85ca1677426ba426459e85",
          blockCreated: 4446677
        }
      },
      l1StandardBridge: {
        [sourceId2]: {
          address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
          blockCreated: 4446677
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1059647
      }
    },
    testnet: true,
    sourceId: sourceId2
  });

  // node_modules/viem/_esm/chains/definitions/bsc.js
  var bsc = /* @__PURE__ */ defineChain({
    id: 56,
    name: "BNB Smart Chain",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "BNB"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/bsc"] }
    },
    blockExplorers: {
      default: {
        name: "BscScan",
        url: "https://bscscan.com",
        apiUrl: "https://api.bscscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15921452
      }
    }
  });

  // node_modules/viem/_esm/chains/celo/formatters.js
  init_fromHex();
  init_toHex();
  init_transactionRequest();

  // node_modules/viem/_esm/chains/celo/utils.js
  init_trim();
  function isEmpty(value) {
    return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
  }
  function isPresent(value) {
    return !isEmpty(value);
  }
  function isEIP1559(transaction) {
    return isPresent(transaction.maxFeePerGas) && isPresent(transaction.maxPriorityFeePerGas);
  }
  function isCIP42(transaction) {
    if (transaction.type === "cip42") {
      return true;
    }
    return isEIP1559(transaction) && (isPresent(transaction.feeCurrency) || isPresent(transaction.gatewayFeeRecipient) || isPresent(transaction.gatewayFee));
  }
  function isCIP64(transaction) {
    if (transaction.type === "cip64") {
      return true;
    }
    return isEIP1559(transaction) && isPresent(transaction.feeCurrency) && isEmpty(transaction.gatewayFee) && isEmpty(transaction.gatewayFeeRecipient);
  }

  // node_modules/viem/_esm/chains/celo/formatters.js
  var formatters2 = {
    block: /* @__PURE__ */ defineBlock({
      exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
      format(args) {
        const transactions = args.transactions?.map((transaction) => {
          if (typeof transaction === "string")
            return transaction;
          return {
            ...formatTransaction(transaction),
            feeCurrency: transaction.feeCurrency,
            ...transaction.type !== "0x7b" ? {
              gatewayFee: transaction.gatewayFee ? hexToBigInt(transaction.gatewayFee) : null,
              gatewayFeeRecipient: transaction.gatewayFeeRecipient || null
            } : {}
          };
        });
        return {
          randomness: args.randomness,
          transactions
        };
      }
    }),
    transaction: /* @__PURE__ */ defineTransaction({
      format(args) {
        const transaction = { feeCurrency: args.feeCurrency };
        if (args.type === "0x7b")
          transaction.type = "cip64";
        else {
          if (args.type === "0x7c")
            transaction.type = "cip42";
          transaction.gatewayFee = args.gatewayFee ? hexToBigInt(args.gatewayFee) : null;
          transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
        }
        return transaction;
      }
    }),
    transactionRequest: /* @__PURE__ */ defineTransactionRequest({
      format(args) {
        const request = {
          feeCurrency: args.feeCurrency
        };
        if (isCIP64(args))
          request.type = "0x7b";
        else {
          if (isCIP42(args))
            request.type = "0x7c";
          request.gatewayFee = typeof args.gatewayFee !== "undefined" ? numberToHex(args.gatewayFee) : void 0;
          request.gatewayFeeRecipient = args.gatewayFeeRecipient;
        }
        return request;
      }
    })
  };

  // node_modules/viem/_esm/chains/celo/serializers.js
  init_address();
  init_base();
  init_chain();
  init_node();
  init_isAddress();
  init_concat();
  init_trim();
  init_toHex();
  var serializeTransaction3 = (tx, signature) => {
    if (isCIP64(tx))
      return serializeTransactionCIP64(tx, signature);
    if (isCIP42(tx))
      return serializeTransactionCIP42(tx, signature);
    return serializeTransaction(tx, signature);
  };
  var serializers2 = {
    transaction: serializeTransaction3
  };
  function serializeTransactionCIP42(transaction, signature) {
    assertTransactionCIP42(transaction);
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data } = transaction;
    const serializedTransaction = [
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      feeCurrency ?? "0x",
      gatewayFeeRecipient ?? "0x",
      gatewayFee ? toHex(gatewayFee) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializeAccessList(accessList)
    ];
    if (signature) {
      serializedTransaction.push(
        signature.v === 27n ? "0x" : toHex(1),
        // yParity
        trim(signature.r),
        trim(signature.s)
      );
    }
    return concatHex([
      "0x7c",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionCIP64(transaction, signature) {
    assertTransactionCIP64(transaction);
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
    const serializedTransaction = [
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializeAccessList(accessList),
      feeCurrency
    ];
    if (signature) {
      serializedTransaction.push(
        signature.v === 27n ? "0x" : toHex(1),
        // yParity
        trim(signature.r),
        trim(signature.s)
      );
    }
    return concatHex([
      "0x7b",
      toRlp(serializedTransaction)
    ]);
  }
  var MAX_MAX_FEE_PER_GAS = 2n ** 256n - 1n;
  function assertTransactionCIP42(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (gasPrice)
      throw new BaseError("`gasPrice` is not a valid CIP-42 Transaction attribute.");
    if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    if (isPresent(gatewayFee) && isEmpty(gatewayFeeRecipient) || isPresent(gatewayFeeRecipient) && isEmpty(gatewayFee)) {
      throw new BaseError("`gatewayFee` and `gatewayFeeRecipient` must be provided together.");
    }
    if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
      throw new BaseError("`feeCurrency` MUST be a token address for CIP-42 transactions.");
    }
    if (isPresent(gatewayFeeRecipient) && !isAddress(gatewayFeeRecipient)) {
      throw new InvalidAddressError(gatewayFeeRecipient);
    }
    if (isEmpty(feeCurrency) && isEmpty(gatewayFeeRecipient)) {
      throw new BaseError("Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.");
    }
  }
  function assertTransactionCIP64(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (gasPrice)
      throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
    if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
      throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
    }
    if (isEmpty(feeCurrency)) {
      throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
    }
  }

  // node_modules/viem/_esm/chains/celo/chainConfig.js
  var chainConfig2 = {
    formatters: formatters2,
    serializers: serializers2
  };

  // node_modules/viem/_esm/chains/definitions/celo.js
  var celo = /* @__PURE__ */ defineChain({
    ...chainConfig2,
    id: 42220,
    name: "Celo",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "CELO"
    },
    rpcUrls: {
      default: { http: ["https://forno.celo.org"] }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/mainnet",
        apiUrl: "https://explorer.celo.org/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 13112599
      }
    },
    testnet: false
  });

  // node_modules/viem/_esm/chains/definitions/fantom.js
  var fantom = /* @__PURE__ */ defineChain({
    id: 250,
    name: "Fantom",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/fantom"] }
    },
    blockExplorers: {
      default: {
        name: "FTMScan",
        url: "https://ftmscan.com",
        apiUrl: "https://api.ftmscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 33001987
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/fantomTestnet.js
  var fantomTestnet = /* @__PURE__ */ defineChain({
    id: 4002,
    name: "Fantom Testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.testnet.fantom.network"] }
    },
    blockExplorers: {
      default: {
        name: "FTMScan",
        url: "https://testnet.ftmscan.com",
        apiUrl: "https://testnet.ftmscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 8328688
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/goerli.js
  var goerli = /* @__PURE__ */ defineChain({
    id: 5,
    name: "Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.ankr.com/eth_goerli"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli.etherscan.io",
        apiUrl: "https://api-goerli.etherscan.io/api"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
        blockCreated: 10339206
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/definitions/gnosis.js
  var gnosis = /* @__PURE__ */ defineChain({
    id: 100,
    name: "Gnosis",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.gnosischain.com"],
        webSocket: ["wss://rpc.gnosischain.com/wss"]
      }
    },
    blockExplorers: {
      default: {
        name: "Gnosisscan",
        url: "https://gnosisscan.io",
        apiUrl: "https://api.gnosisscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 21022491
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/harmonyOne.js
  var harmonyOne = /* @__PURE__ */ defineChain({
    id: 16666e5,
    name: "Harmony One",
    nativeCurrency: {
      name: "Harmony",
      symbol: "ONE",
      decimals: 18
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/harmony"] }
    },
    blockExplorers: {
      default: {
        name: "Harmony Explorer",
        url: "https://explorer.harmony.one"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 24185753
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/mainnet.js
  var mainnet = /* @__PURE__ */ defineChain({
    id: 1,
    name: "Ethereum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://cloudflare-eth.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://etherscan.io",
        apiUrl: "https://api.etherscan.io/api"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0x8cab227b1162f03b8338331adaad7aadc83b895e",
        blockCreated: 18958930
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/metis.js
  var metis = /* @__PURE__ */ defineChain({
    id: 1088,
    name: "Metis",
    nativeCurrency: {
      decimals: 18,
      name: "Metis",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://andromeda.metis.io/?owner=1088"] }
    },
    blockExplorers: {
      default: {
        name: "Andromeda Explorer",
        url: "https://andromeda-explorer.metis.io",
        apiUrl: "https://andromeda-explorer.metis.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2338552
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/optimism.js
  var sourceId3 = 1;
  var optimism = /* @__PURE__ */ defineChain({
    ...chainConfig,
    id: 10,
    name: "OP Mainnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.optimism.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Optimism Explorer",
        url: "https://optimistic.etherscan.io",
        apiUrl: "https://api-optimistic.etherscan.io"
      }
    },
    contracts: {
      ...chainConfig.contracts,
      l2OutputOracle: {
        [sourceId3]: {
          address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 4286263
      },
      portal: {
        [sourceId3]: {
          address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
        }
      },
      l1StandardBridge: {
        [sourceId3]: {
          address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
        }
      }
    },
    sourceId: sourceId3
  });

  // node_modules/viem/_esm/chains/definitions/optimismGoerli.js
  var sourceId4 = 5;
  var optimismGoerli = /* @__PURE__ */ defineChain({
    ...chainConfig,
    id: 420,
    name: "Optimism Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://goerli.optimism.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io",
        apiUrl: "https://goerli-optimism.etherscan.io/api"
      }
    },
    contracts: {
      ...chainConfig.contracts,
      l2OutputOracle: {
        [sourceId4]: {
          address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 49461
      },
      portal: {
        [sourceId4]: {
          address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
        }
      },
      l1StandardBridge: {
        [sourceId4]: {
          address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
        }
      }
    },
    testnet: true,
    sourceId: sourceId4
  });

  // node_modules/viem/_esm/chains/definitions/optimismSepolia.js
  var sourceId5 = 11155111;
  var optimismSepolia = /* @__PURE__ */ defineChain({
    ...chainConfig,
    id: 11155420,
    name: "OP Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.optimism.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://optimism-sepolia.blockscout.com",
        apiUrl: "https://optimism-sepolia.blockscout.com/api"
      }
    },
    contracts: {
      ...chainConfig.contracts,
      l2OutputOracle: {
        [sourceId5]: {
          address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
        }
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1620204
      },
      portal: {
        [sourceId5]: {
          address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
        }
      },
      l1StandardBridge: {
        [sourceId5]: {
          address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
        }
      }
    },
    testnet: true,
    sourceId: sourceId5
  });

  // node_modules/viem/_esm/chains/definitions/polygon.js
  var polygon = /* @__PURE__ */ defineChain({
    id: 137,
    name: "Polygon",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://polygon-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://polygonscan.com",
        apiUrl: "https://api.polygonscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/polygonMumbai.js
  var polygonMumbai = /* @__PURE__ */ defineChain({
    id: 80001,
    name: "Polygon Mumbai",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.ankr.com/polygon_mumbai"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com",
        apiUrl: "https://mumbai.polygonscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/definitions/polygonZkEvm.js
  var polygonZkEvm = /* @__PURE__ */ defineChain({
    id: 1101,
    name: "Polygon zkEVM",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://zkevm-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://zkevm.polygonscan.com",
        apiUrl: "https://api-zkevm.polygonscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 57746
      }
    }
  });

  // node_modules/viem/_esm/chains/definitions/scroll.js
  var scroll = /* @__PURE__ */ defineChain({
    id: 534352,
    name: "Scroll",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.scroll.io"],
        webSocket: ["wss://wss-rpc.scroll.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Scrollscan",
        url: "https://scrollscan.com",
        apiUrl: "https://api.scrollscan.com/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14
      }
    },
    testnet: false
  });

  // node_modules/viem/_esm/chains/definitions/scrollSepolia.js
  var scrollSepolia = /* @__PURE__ */ defineChain({
    id: 534351,
    name: "Scroll Sepolia",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia-rpc.scroll.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://sepolia-blockscout.scroll.io",
        apiUrl: "https://sepolia-blockscout.scroll.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 9473
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/definitions/sepolia.js
  var sepolia = /* @__PURE__ */ defineChain({
    id: 11155111,
    name: "Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.sepolia.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://sepolia.etherscan.io",
        apiUrl: "https://api-sepolia.etherscan.io/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 751532
      },
      ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
      ensUniversalResolver: {
        address: "0xBaBC7678D7A63104f1658c11D6AE9A21cdA09725",
        blockCreated: 5043334
      }
    },
    testnet: true
  });

  // node_modules/viem/_esm/chains/zksync/formatters.js
  init_fromHex();
  init_toBytes();
  init_toHex();
  init_transactionRequest();
  var formatters3 = {
    block: /* @__PURE__ */ defineBlock({
      format(args) {
        const transactions = args.transactions?.map((transaction) => {
          if (typeof transaction === "string")
            return transaction;
          const formatted = formatters3.transaction?.format(transaction);
          if (formatted.typeHex === "0x71")
            formatted.type = "eip712";
          else if (formatted.typeHex === "0xff")
            formatted.type = "priority";
          return formatted;
        });
        return {
          l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
          l1BatchTimestamp: args.l1BatchTimestamp ? hexToBigInt(args.l1BatchTimestamp) : null,
          transactions
        };
      }
    }),
    transaction: /* @__PURE__ */ defineTransaction({
      format(args) {
        const transaction = {};
        if (args.type === "0x71")
          transaction.type = "eip712";
        else if (args.type === "0xff")
          transaction.type = "priority";
        return {
          ...transaction,
          l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
          l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null
        };
      }
    }),
    transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
      format(args) {
        return {
          l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
          l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null,
          logs: args.logs.map((log) => {
            return {
              ...formatLog(log),
              l1BatchNumber: log.l1BatchNumber ? hexToBigInt(log.l1BatchNumber) : null,
              transactionLogIndex: hexToNumber(log.transactionLogIndex),
              logType: log.logType
            };
          }),
          l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
            return {
              blockNumber: hexToBigInt(l2ToL1Log.blockHash),
              blockHash: l2ToL1Log.blockHash,
              l1BatchNumber: hexToBigInt(l2ToL1Log.l1BatchNumber),
              transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),
              shardId: hexToBigInt(l2ToL1Log.shardId),
              isService: l2ToL1Log.isService,
              sender: l2ToL1Log.sender,
              key: l2ToL1Log.key,
              value: l2ToL1Log.value,
              transactionHash: l2ToL1Log.transactionHash,
              logIndex: hexToBigInt(l2ToL1Log.logIndex)
            };
          })
        };
      }
    }),
    transactionRequest: /* @__PURE__ */ defineTransactionRequest({
      exclude: [
        "customSignature",
        "factoryDeps",
        "gasPerPubdata",
        "paymaster",
        "paymasterInput"
      ],
      format(args) {
        if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
          return {
            eip712Meta: {
              ...args.gasPerPubdata ? { gasPerPubdata: toHex(args.gasPerPubdata) } : {},
              ...args.paymaster && args.paymasterInput ? {
                paymasterParams: {
                  paymaster: args.paymaster,
                  paymasterInput: Array.from(hexToBytes(args.paymasterInput))
                }
              } : {},
              ...args.factoryDeps ? { factoryDeps: args.factoryDeps } : {},
              ...args.customSignature ? {
                customSignature: Array.from(hexToBytes(args.customSignature))
              } : {}
            },
            type: "0x71"
          };
        return {};
      }
    })
  };

  // node_modules/viem/_esm/chains/zksync/serializers.js
  init_concat();
  init_toHex();

  // node_modules/viem/_esm/chains/zksync/utils/assertEip712Transaction.js
  init_address();
  init_base();
  init_chain();
  init_isAddress();

  // node_modules/viem/_esm/chains/zksync/errors/transaction.js
  init_base();
  var InvalidEip712TransactionError = class extends BaseError {
    constructor() {
      super([
        "Transaction is not an EIP712 transaction.",
        "",
        "Transaction must:",
        '  - include `type: "eip712"`',
        "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
      ].join("\n"));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidEip712TransactionError"
      });
    }
  };

  // node_modules/viem/_esm/chains/zksync/utils/isEip712Transaction.js
  function isEIP712Transaction(transaction) {
    if (transaction.type === "eip712")
      return true;
    if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
      return true;
    return false;
  }

  // node_modules/viem/_esm/chains/zksync/utils/assertEip712Transaction.js
  function assertEip712Transaction(transaction) {
    const { chainId, to, from, paymaster, paymasterInput } = transaction;
    if (!isEIP712Transaction(transaction))
      throw new InvalidEip712TransactionError();
    if (!chainId || chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress(to))
      throw new InvalidAddressError({ address: to });
    if (from && !isAddress(from))
      throw new InvalidAddressError({ address: from });
    if (paymaster && !isAddress(paymaster))
      throw new InvalidAddressError({ address: paymaster });
    if (paymaster && !paymasterInput) {
      throw new BaseError("`paymasterInput` must be provided when `paymaster` is defined");
    }
    if (!paymaster && paymasterInput) {
      throw new BaseError("`paymaster` must be provided when `paymasterInput` is defined");
    }
  }

  // node_modules/viem/_esm/chains/zksync/serializers.js
  var serializeTransaction4 = (tx, signature) => {
    if (isEIP712Transaction(tx))
      return serializeTransactionEIP712(tx);
    return serializeTransaction(tx, signature);
  };
  var serializers3 = {
    transaction: serializeTransaction4
  };
  function serializeTransactionEIP712(transaction) {
    const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
    assertEip712Transaction(transaction);
    const serializedTransaction = [
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x0",
      toHex(chainId),
      toHex(""),
      toHex(""),
      toHex(chainId),
      from ?? "0x",
      gasPerPubdata ? toHex(gasPerPubdata) : "0x",
      factoryDeps ?? [],
      customSignature ?? "0x",
      // EIP712 signature
      paymaster && paymasterInput ? [paymaster, paymasterInput] : []
    ];
    return concatHex([
      "0x71",
      toRlp(serializedTransaction)
    ]);
  }

  // node_modules/viem/_esm/chains/zksync/utils/getEip712Domain.js
  var getEip712Domain = (transaction) => {
    assertEip712Transaction(transaction);
    const message = transactionToMessage(transaction);
    return {
      domain: {
        name: "zkSync",
        version: "2",
        chainId: transaction.chainId
      },
      types: {
        Transaction: [
          { name: "txType", type: "uint256" },
          { name: "from", type: "uint256" },
          { name: "to", type: "uint256" },
          { name: "gasLimit", type: "uint256" },
          { name: "gasPerPubdataByteLimit", type: "uint256" },
          { name: "maxFeePerGas", type: "uint256" },
          { name: "maxPriorityFeePerGas", type: "uint256" },
          { name: "paymaster", type: "uint256" },
          { name: "nonce", type: "uint256" },
          { name: "value", type: "uint256" },
          { name: "data", type: "bytes" },
          { name: "factoryDeps", type: "bytes32[]" },
          { name: "paymasterInput", type: "bytes" }
        ]
      },
      primaryType: "Transaction",
      message
    };
  };
  function transactionToMessage(transaction) {
    const { gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
    return {
      txType: 113n,
      from: BigInt(from),
      to: to ? BigInt(to) : 0n,
      gasLimit: gas ?? 0n,
      gasPerPubdataByteLimit: gasPerPubdata ?? 0n,
      maxFeePerGas: maxFeePerGas ?? 0n,
      maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
      paymaster: paymaster ? BigInt(paymaster) : 0n,
      nonce: nonce ? BigInt(nonce) : 0n,
      value: value ?? 0n,
      data: data ? data : "0x0",
      factoryDeps: factoryDeps ?? [],
      paymasterInput: paymasterInput ? paymasterInput : "0x0"
    };
  }

  // node_modules/viem/_esm/chains/zksync/chainConfig.js
  var chainConfig3 = {
    formatters: formatters3,
    serializers: serializers3,
    custom: {
      getEip712Domain
    }
  };

  // node_modules/viem/_esm/chains/definitions/zkSync.js
  var zkSync = /* @__PURE__ */ defineChain({
    ...chainConfig3,
    id: 324,
    name: "zkSync Era",
    network: "zksync-era",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://era.zksync.network/",
        apiUrl: "https://api-era.zksync.network/api"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    }
  });

  // src/rpc/chainIds.ts
  var ChainId = {
    mainnet: mainnet.id,
    goerli: goerli.id,
    polygon: polygon.id,
    mumbai: polygonMumbai.id,
    avalanche: avalanche.id,
    fuji: avalancheFuji.id,
    arbitrum_one: arbitrum.id,
    arbitrum_goerli: arbitrumGoerli.id,
    arbitrum_sepolia: arbitrumSepolia.id,
    fantom: fantom.id,
    fantom_testnet: fantomTestnet.id,
    optimism: optimism.id,
    optimism_sepolia: optimismSepolia.id,
    optimism_goerli: optimismGoerli.id,
    harmony: harmonyOne.id,
    sepolia: sepolia.id,
    scroll: scroll.id,
    scroll_sepolia: scrollSepolia.id,
    metis: metis.id,
    base: base.id,
    base_sepolia: baseSepolia.id,
    bnb: bsc.id,
    gnosis: gnosis.id,
    zkEVM: polygonZkEvm.id,
    celo: celo.id,
    zkSync: zkSync.id
  };

  // src/rpc/helpers.ts
  var import_promise_pool = __toESM(require_dist(), 1);
  var import_node_util = __require("util");
  async function getContractDeploymentBlock({
    client,
    contractAddress,
    fromBlock,
    toBlock,
    maxDelta
  }) {
    if (fromBlock == toBlock)
      return fromBlock;
    if (fromBlock < toBlock) {
      const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
      const codeMid = await getBytecode(client, {
        blockNumber: midBlock,
        address: contractAddress
      });
      if (!codeMid) {
        if (toBlock - midBlock > maxDelta) {
          return getContractDeploymentBlock({
            client,
            contractAddress,
            fromBlock: midBlock,
            toBlock,
            maxDelta
          });
        } else {
          return midBlock;
        }
      }
      return getContractDeploymentBlock({
        client,
        contractAddress,
        fromBlock,
        toBlock: midBlock,
        maxDelta
      });
    }
    throw new Error("Could not find contract deployment block");
  }
  async function getBlockAtTimestamp({
    client,
    timestamp,
    fromBlock,
    toBlock,
    maxDelta
  }) {
    if (fromBlock <= toBlock) {
      const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
      const block = await getBlock(client, { blockNumber: midBlock });
      if (block.timestamp > timestamp) {
        return getBlockAtTimestamp({
          client,
          timestamp,
          fromBlock,
          toBlock: midBlock,
          maxDelta
        });
      } else {
        if (timestamp - block.timestamp < maxDelta) {
          return block;
        } else {
          return getBlockAtTimestamp({
            client,
            timestamp,
            fromBlock: midBlock,
            toBlock,
            maxDelta
          });
        }
      }
    }
    throw new Error("Could not find matching block");
  }
  async function strategicGetLogs({
    client,
    events,
    address,
    fromBlock,
    toBlock
  }) {
    if (client.transport.key === "http") {
      const url = client.transport.url;
      let batchSize = 0;
      if (/llamarpc/.test(url))
        batchSize = 1e5;
      if (/quiknode/.test(url))
        batchSize = 1e4;
      if (/alchemy/.test(url)) {
        getLogsRecursive({ client, events, address, fromBlock, toBlock });
      }
      if (batchSize > 0) {
        return getLogsInBatches({
          client,
          events,
          address,
          fromBlock,
          toBlock,
          batchSize
        });
      }
    }
    return getLogsRecursive({ client, events, address, fromBlock, toBlock });
  }
  async function getLogsRecursive({
    client,
    events,
    address,
    fromBlock,
    toBlock
  }) {
    (0, import_node_util.debug)("recursions")(`fetching from block ${fromBlock} to block ${toBlock}`);
    if (fromBlock <= toBlock) {
      try {
        const logs = await getLogs(client, {
          fromBlock,
          toBlock,
          events,
          address
        });
        return logs;
      } catch (error) {
        const rangeMatch = error.details?.match(/.*\[(.*),\s*(.*)\]/);
        if (rangeMatch?.length === 3) {
          const maxBlock = fromHex(rangeMatch[2], "bigint");
          const arr1 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock,
            toBlock: maxBlock
          });
          const midBlock = BigInt(maxBlock + toBlock) >> BigInt(1);
          const arr2 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock: maxBlock + BigInt(1),
            toBlock: midBlock
          });
          const arr3 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock: midBlock + BigInt(1),
            toBlock
          });
          return [...arr1, ...arr2, ...arr3];
        } else {
          const midBlock = BigInt(fromBlock + toBlock) >> BigInt(1);
          const arr1 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock,
            toBlock: midBlock
          });
          const arr2 = await getLogsRecursive({
            client,
            events,
            address,
            fromBlock: midBlock + BigInt(1),
            toBlock
          });
          return [...arr1, ...arr2];
        }
      }
    }
    return [];
  }
  async function getLogsInBatches({
    client,
    events,
    address,
    fromBlock,
    toBlock,
    batchSize
  }) {
    const batches = [];
    for (let i = Number(fromBlock); i < Number(toBlock); i = i + batchSize) {
      batches.push({
        from: BigInt(i),
        to: BigInt(i + batchSize - 1) > toBlock ? toBlock : BigInt(i + batchSize - 1)
      });
    }
    const { results, errors } = await import_promise_pool.PromisePool.for(batches).withConcurrency(5).useCorrespondingResults().process(async ({ from, to }) => {
      return getLogs(client, {
        fromBlock: from,
        toBlock: to,
        events,
        address
      });
    });
    if (errors.length !== 0) {
      throw new Error("Error fetching logs");
    }
    return results.flat();
  }

  // src/rpc/clients.ts
  var commonConfig = { timeout: 3e4 };
  var mainnetClient = createClient({
    chain: mainnet,
    transport: http(process.env.RPC_MAINNET, commonConfig)
  });
  var arbitrumClient = createClient({
    chain: arbitrum,
    transport: http(process.env.RPC_ARBITRUM, commonConfig)
  });
  var polygonClient = createClient({
    chain: polygon,
    transport: http(process.env.RPC_POLYGON, commonConfig)
  });
  var optimismClient = createClient({
    chain: optimism,
    transport: http(process.env.RPC_OPTIMISM, commonConfig)
  });
  var metisClient = createClient({
    chain: metis,
    transport: http(process.env.RPC_METIS, commonConfig)
  });
  var baseClient = createClient({
    chain: base,
    transport: http(process.env.RPC_BASE, commonConfig)
  });
  var fantomClient = createClient({
    chain: fantom,
    transport: http(process.env.RPC_FANTOM, commonConfig)
  });
  var bnbClient = createClient({
    chain: bsc,
    transport: http(process.env.RPC_BNB, commonConfig)
  });
  var avalancheClient = createClient({
    chain: avalanche,
    transport: http(process.env.RPC_AVALANCHE, commonConfig)
  });
  var gnosisClient = createClient({
    chain: gnosis,
    transport: http(process.env.RPC_GNOSIS, commonConfig)
  });
  var scrollClient = createClient({
    chain: scroll,
    transport: http(process.env.RPC_SCROLL, commonConfig)
  });
  var zkEVMClient = createClient({
    chain: polygonZkEvm,
    transport: http(process.env.RPC_ZKEVM, commonConfig)
  });
  var celoClient = createClient({
    chain: celo,
    transport: http(process.env.RPC_CELO, commonConfig)
  });
  var zkSyncClient = createClient({
    chain: zkSync,
    transport: http(process.env.RPC_ZKSYNC, commonConfig)
  });
  var harmonyClient = createClient({
    chain: harmonyOne,
    transport: http(process.env.RPC_HARMONY, commonConfig)
  });
  var fujiClient = createClient({
    chain: avalancheFuji,
    transport: http(process.env.RPC_FUJI, commonConfig)
  });
  var mumbaiClient = createClient({
    chain: polygonMumbai,
    transport: http(process.env.RPC_MUMBAI, commonConfig)
  });
  var sepoliaClient = createClient({
    chain: sepolia,
    transport: http(process.env.RPC_SEPOLIA, commonConfig)
  });
  var goerliClient = createClient({
    chain: goerli,
    transport: http(process.env.RPC_GOERLI, commonConfig)
  });
  var arbitrumGoerliClient = createClient({
    chain: arbitrumGoerli,
    transport: http(process.env.RPC_ARBITRUM_GOERLI, commonConfig)
  });
  var arbitrumSepoliaClient = createClient({
    chain: arbitrumSepolia,
    transport: http(process.env.RPC_ARBITRUM_SEPOLIA, commonConfig)
  });
  var optimismGoerliClient = createClient({
    chain: optimismGoerli,
    transport: http(process.env.RPC_OPTIMISM_GOERLI, commonConfig)
  });
  var optimismSepoliaClient = createClient({
    chain: optimismSepolia,
    transport: http(process.env.RPC_OPTIMISM_SEPOLIA, commonConfig)
  });
  var scrollSepoliaClient = createClient({
    chain: scrollSepolia,
    transport: http(process.env.RPC_SCROLL_SEPOLIA, commonConfig)
  });
  var fantomTestnetClient = createClient({
    chain: fantomTestnet,
    transport: http(process.env.RPC_FANTOM_TESTNET, commonConfig)
  });
  var baseSepoliaClient = createClient({
    chain: baseSepolia,
    transport: http(process.env.RPC_BASE_SEPOLIA, commonConfig)
  });
  var CHAIN_ID_CLIENT_MAP = {
    [ChainId.mainnet]: mainnetClient,
    [ChainId.arbitrum_one]: arbitrumClient,
    [ChainId.arbitrum_goerli]: arbitrumGoerliClient,
    [ChainId.arbitrum_sepolia]: arbitrumSepoliaClient,
    [ChainId.polygon]: polygonClient,
    [ChainId.optimism]: optimismClient,
    [ChainId.optimism_goerli]: optimismGoerliClient,
    [ChainId.optimism_sepolia]: optimismSepoliaClient,
    [ChainId.metis]: metisClient,
    [ChainId.base]: baseClient,
    [ChainId.base_sepolia]: baseSepoliaClient,
    [ChainId.sepolia]: sepoliaClient,
    [ChainId.goerli]: goerliClient,
    [ChainId.fantom]: fantomClient,
    [ChainId.fantom_testnet]: fantomTestnetClient,
    [ChainId.bnb]: bnbClient,
    [ChainId.avalanche]: avalancheClient,
    [ChainId.gnosis]: gnosisClient,
    [ChainId.scroll]: scrollClient,
    [ChainId.scroll_sepolia]: scrollSepoliaClient,
    [ChainId.zkEVM]: zkEVMClient,
    [ChainId.celo]: celoClient,
    [ChainId.zkSync]: zkSyncClient,
    [ChainId.fuji]: fujiClient,
    [ChainId.mumbai]: mumbaiClient,
    [ChainId.harmony]: harmonyClient
  };

  // src/ipfs/hash.ts
  var import_bs58 = __toESM(require_bs58(), 1);
  function baseToCidv0(hash2) {
    return import_bs58.default.encode(Buffer.from(`1220${hash2.slice(2)}`, "hex"));
  }

  // src/ipfs/upload.ts
  async function uploadToPinata(source) {
    const PINATA_KEY = process.env.PINATA_KEY;
    if (!PINATA_KEY)
      throw new Error("PINATA_KEY env must be set");
    const PINATA_SECRET = process.env.PINATA_SECRET;
    if (!PINATA_SECRET)
      throw new Error("PINATA_SECRET env must be set");
    const data = new FormData();
    data.append("file", new Blob([source]));
    const res = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
      method: "POST",
      body: data,
      headers: {
        pinata_api_key: PINATA_KEY,
        pinata_secret_api_key: PINATA_SECRET
      }
    });
    if (!res.ok) {
      throw Error(await res.text());
    }
    const result = await res.json();
    if (result.error)
      throw { message: result.error };
    return result;
  }
  async function uploadToTheGraph(source) {
    const data = new FormData();
    data.append("file", new Blob([source]));
    const res = await fetch("https://api.thegraph.com/ipfs/api/v0/add", {
      method: "POST",
      body: data
    });
    return res.json();
  }
  async function uploadToQuicknode(source, key) {
    const apiKey = process.env.QUICKNODE_API_KEY;
    const headers = new Headers();
    headers.append("x-api-key", apiKey);
    const data = new FormData();
    data.append("Body", new Blob([source]));
    data.append("Key", key || "unknownKey");
    data.append("ContentType", "text/plain");
    const res = await fetch(
      "https://api.quicknode.com/ipfs/rest/v1/s3/put-object",
      {
        method: "POST",
        headers,
        body: data,
        redirect: "follow"
      }
    );
    return res.text();
  }

  // src/ipfs/parseIpfs.ts
  var import_gray_matter = __toESM(require_gray_matter(), 1);
  function getLink(hash2, gateway) {
    return `${gateway}/${hash2}`;
  }
  async function getProposalMetadata(hash2, gateway = "https://cloudflare-ipfs.com/ipfs") {
    const ipfsHash = hash2.startsWith("0x") ? baseToCidv0(hash2) : hash2;
    const ipfsPath = getLink(ipfsHash, gateway);
    const ipfsResponse = await fetch(ipfsPath, {
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!ipfsResponse.ok)
      throw Error(`IPFS: error fetching ${ipfsPath}`);
    const clone = ipfsResponse.clone();
    try {
      const response = await ipfsResponse.json();
      const { content, data } = (0, import_gray_matter.default)(response.description);
      return {
        ...response,
        ipfsHash,
        description: content,
        ...data
      };
    } catch (e) {
      const { content, data } = (0, import_gray_matter.default)(await clone.text());
      return {
        ...ipfsResponse,
        ipfsHash,
        description: content,
        ...data
      };
    }
  }

  // src/storage/storageSlots.ts
  function getSolidityStorageSlotBytes(mappingSlot, key) {
    const slot = pad(mappingSlot, { size: 32 });
    return trim(
      keccak256(
        encodeAbiParameters(parseAbiParameters("bytes32, uint256"), [
          key,
          BigInt(slot)
        ])
      )
    );
  }
  function getSolidityStorageSlotUint(mappingSlot, key) {
    return keccak256(
      encodeAbiParameters(parseAbiParameters("uint256, uint256"), [
        key,
        mappingSlot
      ])
    );
  }
  function getSolidityStorageSlotAddress(mappingSlot, key) {
    return keccak256(
      encodeAbiParameters(parseAbiParameters("address, uint256"), [
        key,
        BigInt(mappingSlot)
      ])
    );
  }
  function getDynamicArraySlot(baseSlot, arrayIndex, itemSize) {
    return pad(
      toHex(
        fromHex(
          keccak256(
            encodeAbiParameters(parseAbiParameters("uint256"), [baseSlot])
          ),
          "bigint"
        ) + BigInt(arrayIndex * itemSize)
      ),
      { size: 32 }
    );
  }
  function getBytesValue(value) {
    const bytesString = toBytes(value);
    if (bytesString.length > 31)
      throw new Error("Error: strings > 31 bytes are not implemented");
    return concat([
      toHex(pad(bytesString, { size: 31, dir: "right" })),
      toHex(bytesString.length * 2, { size: 1 })
    ]);
  }
  function getBits(_bigIntValue, startBit, _endBit) {
    let endBit = _endBit;
    const bigIntValue = BigInt(_bigIntValue);
    if (startBit > endBit) {
      throw new Error(
        "Invalid bit range: startBit must be less than or equal to endBit"
      );
    }
    const bitLength = BigInt(bigIntValue.toString(2)).toString().length;
    if (endBit >= bitLength) {
      endBit = BigInt(bitLength - 1);
    }
    const mask = (1n << endBit - startBit + 1n) - 1n;
    const maskedValue = bigIntValue >> startBit & mask;
    return maskedValue.toString();
  }
  function setBits(_bigIntBase, startBit, endBit, _replaceValue) {
    const bigIntBase = BigInt(_bigIntBase);
    const bigIntReplaceValue = BigInt(_replaceValue);
    let mask = BigInt(0);
    for (let i = startBit; i < endBit; i++) {
      mask |= BigInt(1) << BigInt(i);
    }
    const clearedNumber = bigIntBase & ~mask;
    const result = clearedNumber | bigIntReplaceValue << BigInt(startBit);
    return result;
  }

  // src/storage/poolStorage.ts
  function decodeReserveConfigV2(data) {
    const ltv = getBits(data, 0n, 15n);
    const liquidationThreshold = getBits(data, 16n, 31n);
    const liquidationBonus = getBits(data, 32n, 47n);
    const decimals = getBits(data, 48n, 55n);
    const active = Number(getBits(data, 56n, 56n));
    const frozen = Number(getBits(data, 57n, 57n));
    const borrowingEnabled = Number(getBits(data, 58n, 58n));
    const stableBorrowingEnabled = Number(getBits(data, 59n, 59n));
    const reserveFactor = getBits(data, 64n, 79n);
    return {
      ltv,
      liquidationThreshold,
      liquidationBonus,
      decimals,
      active: !!active,
      frozen: !!frozen,
      borrowingEnabled: !!borrowingEnabled,
      stableBorrowingEnabled: !!stableBorrowingEnabled,
      reserveFactor
    };
  }
  function decodeReserveConfigV3(data) {
    const ltv = getBits(data, 0n, 15n);
    const liquidationThreshold = getBits(data, 16n, 31n);
    const liquidationBonus = getBits(data, 32n, 47n);
    const decimals = getBits(data, 48n, 55n);
    const active = Number(getBits(data, 56n, 56n));
    const frozen = Number(getBits(data, 57n, 57n));
    const borrowingEnabled = Number(getBits(data, 58n, 58n));
    const stableRateBorrowingEnabled = Number(getBits(data, 59n, 59n));
    const paused = Number(getBits(data, 60n, 60n));
    const borrowingInIsolation = Number(getBits(data, 61n, 61n));
    const siloedBorrowingEnabled = Number(getBits(data, 62n, 62n));
    const flashloaningEnabled = Number(getBits(data, 63n, 63n));
    const reserveFactor = getBits(data, 64n, 79n);
    const borrowCap = getBits(data, 80n, 115n);
    const supplyCap = getBits(data, 116n, 151n);
    const liquidationProtocolFee = getBits(data, 152n, 167n);
    const eModeCategory = getBits(data, 168n, 175n);
    const unbackedMintCap = getBits(data, 176n, 211n);
    const debtCeiling = getBits(data, 212n, 251n);
    return {
      ltv,
      liquidationThreshold,
      liquidationBonus,
      decimals,
      active: !!active,
      frozen: !!frozen,
      borrowingEnabled: !!borrowingEnabled,
      stableRateBorrowingEnabled: !!stableRateBorrowingEnabled,
      paused: !!paused,
      borrowingInIsolation: !!borrowingInIsolation,
      reserveFactor,
      borrowCap,
      supplyCap,
      liquidationProtocolFee,
      eModeCategory,
      unbackedMintCap,
      debtCeiling,
      siloedBorrowingEnabled: !!siloedBorrowingEnabled,
      flashloaningEnabled: !!flashloaningEnabled
    };
  }
})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

is-extendable/index.js:
  (*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

strip-bom-string/index.js:
  (*!
   * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=browser.global.js.map